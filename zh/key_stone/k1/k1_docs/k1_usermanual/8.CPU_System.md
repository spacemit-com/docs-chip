# 8. CPU System

```
Last Version: 2025/11/18
```

## 8.1 Overview

The CPU System ok K1 consists of

- A SpacemiT®X60™ RISC-V Main CPU (hereafter **CPU Subsystem**)
- A RISC-V Real-Time CPU (hereafter **RCPU**)

## 8.2 CPU Subsystem

### Introduction

The **CPU Subsystem** of K1 includes the following components:

- Two X60™ clusters
- A Cache Coherency Unit
- A Dragon CIU for configuration
- Additional components to ensure high performance and system efficiency

### Features

- **X60™ Clusters**

  - Each cluster contains four cores with 512KB L2 cache
  - The BOOST cluster also includes 512KB TCM
  - Each X60™ core has 32KB L1-I cache and 32KB L1-D cache

- **Cache Coherency Unit**

  - Maintenance of data coherency between X60™ clusters

- **Dragon CIU Registers**

  - Availability of multiple configuration registers for X60™ clusters and cores

- **Generic Counter Register**

  - SoC Counter Registers

### Functional Description

Reserved

### Generic Counter Registers Description

Starting from the **base address 0xD500_1000**, there are several **Generic Counter Registers** which configuration details are provided in the following subsections.

#### CNTCR_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:2</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1</td>
<td>HDBG</td>
<td>RW</td>
<td>0x0</td>
<td>Halt on debug. The possible values are:<br/>- 0: HLTDBG signal into the counter has no effect<br/>- 1: HLTDBG signal into the counter halts the counter</td>
</tr>
<tr>
<td>0</td>
<td>EN</td>
<td>RW</td>
<td>0x0</td>
<td>Enable/Disable counter. The possible values are:<br/>- 0: The counter is disabled and not incrementing<br/>- 1: The counter is enabled and is incrementing </td>
</tr>
</tbody>
</table>

#### CNTSR_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:2</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1</td>
<td>HDBG</td>
<td>RW</td>
<td>0x0</td>
<td>Debug halted</td>
</tr>
<tr>
<td>0</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### CNTCVLW_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CNTCVLW</td>
<td>RW</td>
<td>0x0</td>
<td>Value of counter [31:0]</td>
</tr>
</tbody>
</table>

#### CNTCVUP_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CNTCVUP</td>
<td>RW</td>
<td>0x0</td>
<td>Value of counter [63:32]</td>
</tr>
</tbody>
</table>

#### CNTFID_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x20</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>FREQ</td>
<td>RW</td>
<td>0x0</td>
<td>Frequency in number of ticks per second</td>
</tr>
</tbody>
</table>

### Dragon CIU Registers Description

Starting from the **base address 0xD844_0000**, there are many **Dragon CIU Registers** which configuration details are provided in the following subsections.

#### CLUSTER0_CPU_SRAM_CTRL0_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x14</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CLUSTER0_MEM_EMA_CFG_31_0</td>
<td>RW</td>
<td>0x00035102</td>
<td>MEM_EMA_CFG_31_0 for Cluster0 CPU memory<br/></td>
</tr>
</tbody>
</table>

#### CLUSTER0_CPU_SRAM_CTRL1_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x18</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CLUSTER0_MEM_EMA_CFG_63_32</td>
<td>RW</td>
<td>0x59454000</td>
<td>MEM_EMA_CFG_63_32 for Cluster0 CPU memory</td>
</tr>
</tbody>
</table>

#### CLUSTER1_CPU_SRAM_CTRL0_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x54</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CLUSTER1_MEM_EMA_CFG_31_0</td>
<td>RW</td>
<td>0x00035102</td>
<td>MEM_EMA_CFG_31_0 for Cluster1 CPU memory</td>
</tr>
</tbody>
</table>

#### CLUSTER1_CPU_SRAM_CTRL1_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x58</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CLUSTER1_MEM_EMA_CFG_63_32</td>
<td>RW</td>
<td>0x59454000</td>
<td>MEM_EMA_CFG_63_32 for Cluster1 CPU memory</td>
</tr>
</tbody>
</table>

#### CKG_CTRL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x88</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:26</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>25:16</td>
<td>CCI dynamic clock gate timer</td>
<td>RW</td>
<td>0x0</td>
<td>When dynamic clock gating is enabled, the CCI clock turns off after the number of cycles set by <strong>CCI_CLKOFF_TIMER</strong></td>
</tr>
<tr>
<td>15:4</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>Dragon CIU dynamic gate enable</td>
<td>RW</td>
<td>0x0</td>
<td>- 0: Clock is always on <br/>- 1: Dynamic clock gating enabled</td>
</tr>
<tr>
<td>2</td>
<td>CCI clock dynamic gate enable</td>
<td>RW</td>
<td>0x0</td>
<td>- 0: Clock is always on <br/>- 1: Dynamic clock gating enabled </td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>nic400_cci550_2x5 clock dynamic gate enable</td>
<td>RW</td>
<td>0x0</td>
<td>- 0: Clock is always on <br/>- 1: Dynamic clock gating enabled </td>
</tr>
</tbody>
</table>

#### CCI_DBG_CTRL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x90</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:4</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>Invasive debug enable</td>
<td>RW</td>
<td>0x0</td>
<td>If HIGH, the counting and export of PMU events are enabled</td>
</tr>
<tr>
<td>2</td>
<td>Secure invasive debug enable</td>
<td>RW</td>
<td>0x0</td>
<td>If both SPIDEN and DBGEN are HIGH, the counting of both Non-Secure and Secure events are enabled </td>
</tr>
<tr>
<td>1</td>
<td>Non-Invasive debug enable</td>
<td>RW</td>
<td>0x0</td>
<td>If HIGH, the counting and export of PMU events are enabled </td>
</tr>
<tr>
<td>0</td>
<td>Secure privileged non-invasive debug enable</td>
<td>RW</td>
<td>0x0</td>
<td>If both SPNIDEN and NIDEN are HIGH, the counting of both Non-Secure and Secure events are enabled </td>
</tr>
</tbody>
</table>

#### CCI_INF_QOS_CTRL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x98</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:12</td>
<td>C1_ARQOS_CFG</td>
<td>RW</td>
<td>0x0</td>
<td>ALZO_ARQOS configuration</td>
</tr>
<tr>
<td>11:8</td>
<td>C1_AWQOS_CFG</td>
<td>RW</td>
<td>0x0</td>
<td>ALZO_AWQOS configuration</td>
</tr>
<tr>
<td>7:4</td>
<td>C0_ARQOS_CFG</td>
<td>RW</td>
<td>0x0</td>
<td>CPU ARQOS configuration</td>
</tr>
<tr>
<td>3:0</td>
<td>C0_AWQOS_CFG</td>
<td>RW</td>
<td>0x0</td>
<td>CPU AWQOS configuration</td>
</tr>
</tbody>
</table>

#### CCI_SFRAM_CTL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x9C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>MEM_EMA_CFG_31_0</td>
<td>RW</td>
<td>0x00035102</td>
<td> MEM_EMA_CFG_31_0 for CCI CPU memory</td>
</tr>
</tbody>
</table>

#### X60_OUTER_COH_EN_CTRL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xF0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:2</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1</td>
<td>C1_cpu_outer_coh_en</td>
<td>RW</td>
<td>0x1</td>
<td>0: Cluster 1 outer cache coherency disabled<br/>1: Cluster 1 outer cache coherency enabled</td>
</tr>
<tr>
<td>0</td>
<td>C0_cpu_outer_coh_en</td>
<td>RW</td>
<td>0x1</td>
<td>0: Cluster 1 outer cache coherency disabled<br/>1: Cluster 0 outer cache coherency enabled</td>
</tr>
</tbody>
</table>

#### FAB_TOM_RD_STS0_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x118</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Ranking number of AXI read to Monitor 1</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout occurred, write clear <br/>1: Timeout occurred</td>
</tr>
<tr>
<td>27:24</td>
<td>Ranking number of AXI read to Monitor 0</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout occurred, write clear <br/>1: Timeout occurred</td>
</tr>
<tr>
<td>23:20</td>
<td>Ranking number of AXI Write to Monitor 4</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout occurred, write clear <br/>1: Timeout occurred</td>
</tr>
<tr>
<td>19:16</td>
<td>Ranking number of AXI Write to Monitor 3</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout occurred, write clear <br/>1: Timeout occurred</td>
</tr>
<tr>
<td>15:12</td>
<td>Ranking number of AXI Write to Monitor 2</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout occurred, write clear <br/>1: Timeout occurred</td>
</tr>
<tr>
<td>11:8</td>
<td>Ranking number of AXI Write to Monitor 1</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout occurred, write clear <br/>1: Timeout occurred</td>
</tr>
<tr>
<td>7:4</td>
<td>Ranking number of AXI Write to Monitor 0</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout occurred, write clear <br/>1: Timeout occurred</td>
</tr>
<tr>
<td>3:0</td>
<td>Total timeout number</td>
<td>RO</td>
<td>0x0</td>
<td>It Indicates the timeout status of various ranks as follows:<br/>- RANK4:  s7_sec<br/>- RANK3:  s5_axidec2       <br/>- RANK2:  s4_audio     <br/>- RANK1:  s0_mc        <br/>- RANK0:  s2_axidec   <br/>> <strong>Note</strong><strong>.</strong> 0 indicates no timeout. Write clear is required before using this register and fab_tom_wr_sts</td>
</tr>
</tbody>
</table>

#### FAB_TOM_RD_STS1_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x11C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:8</td>
<td>Ranking number of AXI Read to Monitor 4</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout, write clear by FAB_TOM_RD_STS<br/>1: Timeout occurred</td>
</tr>
<tr>
<td>7:4</td>
<td>Ranking number of AXI Read to Monitor 3</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout, write clear by FAB_TOM_RD_STS<br/>1: Timeout occurred</td>
</tr>
<tr>
<td>3:0</td>
<td>Ranking number of AXI Read to Monitor 2</td>
<td>RO</td>
<td>0x0</td>
<td>0: No timeout, write clear by FAB_TOM_RD_STS<br/>1: Timeout occurred</td>
</tr>
</tbody>
</table>

#### FAB_TIMEOUT_CTRL_X_REG

This register controls the timeout for the AXI bus monitor on the Fabric#1 S2 port.

If there is a pending request on the AXI Fabric#1 S2 port and the request duration exceeds the timeout value, a timeout interrupt will be asserted. In particular,

- The interrupt can be de-asserted by writing a "0" to TIMEOUT_VAL
- The default timeout value is 0xC000 where one unit represents one AXI clock cycle

> **Notes.**
>
> - Only the Fabric#1 S2 port is monitored, and this feature is intended for debugging purposes
> - To ensure a proper access to the registers when a timeout occurs on the Fabric#1 S2 port, these timeout control registers should be placed alongside the SQU registers on the Fabric#1 S4 port

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x120~0x160（0x10）</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Timeout auto response type</td>
<td>RW</td>
<td>0x0</td>
<td>- 0: Auto response type is SLVERR <br/>- 1: Auto response type is OKAY </td>
</tr>
<tr>
<td>30</td>
<td>Timeout auto response enable</td>
<td>RW</td>
<td>0x0</td>
<td>- 0: Disable auto response when fabric timeout happens <br/>- 1: Enable auto response when fabric timeout happens (this can help taking CPU out of a hanging state)</td>
</tr>
<tr>
<td>29</td>
<td>Timeout interrupt mask</td>
<td>RW</td>
<td>0x0</td>
<td>This bit determines whether a timeout interrupt is triggered when a timeout event occurs, in particular:<br/>- 0: Interrupt is not masked (an interrupt will be asserted when the timeout event happens)<br/>- 1: Interrupt is masked (no interrupt will be asserted when the timeout event happens)</td>
</tr>
<tr>
<td>28</td>
<td>Fabric monitor reset</td>
<td>RW</td>
<td>0x0</td>
<td>- 0: Reset fabric monitor <br/>- 1: Release fabric monitor </td>
</tr>
<tr>
<td>27</td>
<td>Fabric monitor register clear</td>
<td>RW</td>
<td>0x0</td>
<td>Clear the information saved when the latest timeout occurred, in particular: <br/>- 0: The relevant registers are kept  <br/>- 1: The relevant registers are cleared  </td>
</tr>
<tr>
<td>26</td>
<td>Timeout interrupt clear</td>
<td>RW</td>
<td>0x0</td>
<td>- 0: No effect<br/>- 1: Auto-clear (by hardware) AXI fabric S2 port timeout interrupt</td>
</tr>
<tr>
<td>25</td>
<td>no_ready_check_en</td>
<td>RW</td>
<td>0x0</td>
<td>Enable/Disable checking AWREADY or ARREADY signals as follows:<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>24</td>
<td>new_feature_en</td>
<td>RW</td>
<td>0x0</td>
<td>Enable/Disable the AXI fabric timeout monitor new feature as follows:<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>23:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15</td>
<td>Clock gating disable</td>
<td>RW</td>
<td>0x0</td>
<td>[DOVE_A0] Disable monitor clock gating, in particular:   <br/>- 1: Clock runs freely (i.e. clock gating for monitor disabled)   <br/>- 0: Clock is gated if FAB_MON_RST==0</td>
</tr>
<tr>
<td>14:0</td>
<td>AXI fabric timeout value</td>
<td>RW</td>
<td>0xC000</td>
<td>This field indicates the timeout value for AXI fabric.<br/>The real timeout time is 2048*TIMEOUT_VAL.<br/>One unit represents one AXI clock cycle.</td>
</tr>
</tbody>
</table>

#### FAB_TIMEOUT_ID_X_REG

This register provides information gathered by AXI bus monitor on the Fabric#1 S2 port, and it is updated when the first timeout event occurs.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x124~0x164（0x10）</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Write timeout indicator</td>
<td>RO</td>
<td>0x0</td>
<td>- 0: No write request timeout <br/>- 1: Write request timeout occurs </td>
</tr>
<tr>
<td>30:22</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21:16</td>
<td>Timeout transaction WID</td>
<td>RO</td>
<td>0x0</td>
<td>It is the Write ID (WID) of a Write Transaction that triggers the first timeout event, and is valid only when bit[31], WR_TIMEOUT_IND is asserted </td>
</tr>
<tr>
<td>15</td>
<td>Read timeout indicator</td>
<td>RO</td>
<td>0x0</td>
<td>- 0: No read request timeout <br/>- 1: Read request timeout occurs </td>
</tr>
<tr>
<td>14:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:0</td>
<td>Timeout transaction RID</td>
<td>RO</td>
<td>0x0</td>
<td>It is the Read ID (RID) of a Read Transaction that triggers the first timeout event, and is valid only when bit[15], RD_TIMEOUT_IND is asserted </td>
</tr>
</tbody>
</table>

#### FAB_TIMEOUT_STATUS0_X_REG

This register provides information gathered by AXI bus monitor on Fabric#1 S2 port, and it is updated when the first timeout event occurs.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x128~0x168（0x10）</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:2</td>
<td>Write timeout Address</td>
<td>RO</td>
<td>0x0</td>
<td>The write address being accessed during the first write timeout event</td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>Write timeout Indicator</td>
<td>RO</td>
<td>0x0</td>
<td>- 0: No write request timeout occurred<br/>- 1: Write request timeout occurred </td>
</tr>
</tbody>
</table>

#### FAB_TIMEOUT_STATUS1_X_REG

This register provides information gathered by AXI bus monitor on Fabric#1 S2 port, and is updated when the first timeout event occurs.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x12C~0x16C（0x10）</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:2</td>
<td>Read timeout address</td>
<td>RO</td>
<td>0x0</td>
<td>It is the address being accessed during the first read timeout event</td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>Read timeout indicator</td>
<td>RO</td>
<td>0x0</td>
<td>- 0: No read request timeout occurred<br/>- 1: Read request timeout occurred</td>
</tr>
</tbody>
</table>

#### FAB_DEBUG_REG_X_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x170~0x17C（0x4）</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>AXI fabric debug register</td>
<td>RO</td>
<td>0x0</td>
<td>- [0] = debug_axifab_cp_dec    <br/>- [1] = debug_axifab_axi_dec2<br/>- [2] = debug_axifab_csap_fab  <br/>- [3] = debug_axifab_vpu_lte<br/>- [4] = debug_axifab_isp_lcd    <br/>- [5] = debug_axifab_cp_mfab<br/>- [6] = debug_axifab_apfab    <br/>- [7] = 32'h0<br/>- [8] = debug_axifab_cpu_dec    <br/>- [9] = debug_axifab_cpu_gpu  <br/>> <strong>Note.</strong> debug_axifab = mas_bready, mas_rready, slv_awready, slv_arready, slv_wready, clk_axi_en_nd     </td>
</tr>
</tbody>
</table>

#### PAD_PIC_PLIC_INT_0_CTL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: Reserved</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>pad_pic_plic_int_0_ctl_</td>
<td>RW</td>
<td>0x0</td>
<td>This register controls the interrupts for [31:0]. For each bit,<br/>- 0: Level-triggered interrupt<br/>- 1: Edge-triggered interrupt</td>
</tr>
</tbody>
</table>

#### PAD_PIC_PLIC_INT_1_CTL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: Reserved</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>pad_pic_plic_int_1_ctl_</td>
<td>RW</td>
<td>0x0</td>
<td>This register controls the interrupts for [63:32]. For each bit:<br/>- 0: Level-triggered interrupt<br/>- 1: Edge-triggered interrupt</td>
</tr>
</tbody>
</table>

#### PAD_PIC_PLIC_INT_2_CTL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: Reserved</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>pad_pic_plic_int_2_ctl_</td>
<td>RW</td>
<td>0x0</td>
<td>This register controls the interrupts for [95:64]. For each bit:<br/>- 0: Level-triggered interrupt<br/>- 1: Edge-triggered interrupt</td>
</tr>
</tbody>
</table>

#### PAD_PIC_PLIC_INT_3_CTL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: Reserved</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>pad_pic_plic_int_3_ctl_</td>
<td>RW</td>
<td>0x0</td>
<td>This register controls the interrupts for [127:96]. For each bit:<br/>- 0: Level-triggered interrupt<br/>- 1: Edge-triggered interrupt</td>
</tr>
</tbody>
</table>

#### PAD_PIC_PLIC_INT_4_CTL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: Reserved</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>pad_pic_plic_int_4_ctl_</td>
<td>RW</td>
<td>0x0</td>
<td>This register controls the interrupts for [159:128]. For each bit:<br/>- 0: Level-triggered interrupt<br/>- 1: Edge-triggered interrupt</td>
</tr>
</tbody>
</table>

#### C0_INT_WAKEUP_MASK_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1A4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:10</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>9</td>
<td>C0_ms_int_core_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_ms_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>8</td>
<td>C0_mt_int_core_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_mt_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>7</td>
<td>C0_ss_int_core_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_ss_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>6</td>
<td>C0_me_int_core_mask<br/></td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_me_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>5</td>
<td>C0_se_int_core_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_se_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>4</td>
<td>C0_ms_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_ms_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>3</td>
<td>C0_mt_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_mt_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>2</td>
<td>C0_ss_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_ss_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>1</td>
<td>C0_me_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_me_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>0</td>
<td>C0_se_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C0_se_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
</tbody>
</table>

#### C1_INT_WAKEUP_MASK_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1A8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:10</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>9</td>
<td>C1_ms_int_core_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_ms_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>8</td>
<td>C1_mt_int_core_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_mt_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>7</td>
<td>C1_ss_int_core_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_ss_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>6</td>
<td>C1_me_int_core_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_me_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>5</td>
<td>C1_se_int_core_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_se_int to core:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>4</td>
<td>C1_ms_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_ms_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>3</td>
<td>C1_mt_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_mt_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>2</td>
<td>C1_ss_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_ss_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>1</td>
<td>C1_me_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_me_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
<tr>
<td>0</td>
<td>C1_se_int_pmu_wakeup_mask</td>
<td>RW</td>
<td>0x0</td>
<td>Mask for C1_se_int to PMU wakeup:<br/>- 1: Mask<br/>- 0: Unmask</td>
</tr>
</tbody>
</table>

#### CPU_SYS_SW_RESET_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1AC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:2</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1</td>
<td>hap_top_sw_reset</td>
<td>RW</td>
<td>0x0</td>
<td>Perform a software reset on hap_top by first writing 1, then writing 0</td>
</tr>
<tr>
<td>0</td>
<td>pic_top_sw_reset</td>
<td>RW</td>
<td>0x0</td>
<td>Perform a software reset on pic_top by first writing 1, then writing 0</td>
</tr>
</tbody>
</table>

#### C0_L2_FLUSH_CTL_RESET_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1B0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:5</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>C0_l2_hw_flush_done_mask</td>
<td>RW</td>
<td>0x0</td>
<td>- 0: L2 flush completion status not masked<br/>- 1: L2 flush completion status masked (i.e. C0_l2_flush_done_status =1)</td>
</tr>
<tr>
<td>3</td>
<td>C0_l2_flush_done_status</td>
<td>RO</td>
<td>0x0</td>
<td>Status of the L2 flush operation:<br/>- 0: L2 flush not completed<br/>- 1: L2 flush completed</td>
</tr>
<tr>
<td>2</td>
<td>C0_l2_flush_hw_en</td>
<td>RO</td>
<td>0x0</td>
<td>Enable of hardware L2 flush:<br/>- 0: Hardware L2 flush disabled<br/>- 1: Hardware L2 flush enabled (only valid if C0_l2_flush_ctl[0] is 1)</td>
</tr>
<tr>
<td>1</td>
<td>C0_l2_flush_sw_req</td>
<td>RW</td>
<td>0x0</td>
<td>Software request for L2 flush:<br/>- 0: Not request a software-initiated L2 flush<br/>- 1: Request a software-initiated L2 flush (clear this bit (i.e. set to 0) after completed the flush (when C0_l2_flush_done_status=1))</td>
</tr>
<tr>
<td>0</td>
<td>C0_l2_flush_type</td>
<td>RW</td>
<td>0x0</td>
<td>- 1: Hardware PMU mode<br/>- 0: Software mode</td>
</tr>
</tbody>
</table>

#### C1_L2_FLUSH_CTL_RESET_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1B4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:5</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>C1_l2_hw_flush_done_mask</td>
<td>RW</td>
<td>0x0</td>
<td>- 0: L2 flush completion status not masked<br/>- 1: L2 flush completion status masked (i.e. C1_l2_flush_done_status =1)</td>
</tr>
<tr>
<td>3</td>
<td>C1_l2_flush_done_status</td>
<td>RO</td>
<td>0x0</td>
<td>Status of the L2 flush operation:<br/>- 0: L2 flush not completed<br/>- 1: L2 flush completed</td>
</tr>
<tr>
<td>2</td>
<td>C1_l2_flush_hw_en</td>
<td>RO</td>
<td>0x0</td>
<td>Enable/Disable hardware L2 flush as follows:<br/>- 0: Disabled<br/>- 1: Enabled (only valid if C1_l2_flush_ctl[0] is 1)</td>
</tr>
<tr>
<td>1</td>
<td>C1_l2_flush_sw_req</td>
<td>RW</td>
<td>0x0</td>
<td>Software request for L2 flush:<br/>- 0: Not request a software-initiated L2 flush<br/>- 1: Request a software-initiated L2 flush (clear this bit (i.e. set to 0) after completed the flush (when C1_l2_flush_done_status is 1))</td>
</tr>
<tr>
<td>0</td>
<td>C1_l2_flush_type</td>
<td>RW</td>
<td>0x0</td>
<td>- 1: Hardware PMU mode<br/>- 0: Software mode</td>
</tr>
</tbody>
</table>

#### CPU_ACCESS_DDR_REMAP_EN_RESET_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1B8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>cpu_access_ddr_remap_en_</td>
<td>RW</td>
<td>0x1</td>
<td>- 0: DDR remap disabled<br/>- 1: DDR remap enabled</td>
</tr>
</tbody>
</table>

#### HAP_DM_CTL_REG

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1BC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:5</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>C01_hap_dm_ndmreset_n_mask</td>
<td>RO</td>
<td>0x0</td>
<td>Enable/Disable preventing hap_sys_apb_rst_n and power-on cluster's sys_apb_rst_n from being set to 0 during SoC WDT reset caused by hap_dm_ndmreset_n as follow:<br/>- 1: Enabled<br/>- 0: Disabled</td>
</tr>
<tr>
<td>3</td>
<td>core_iso_hold_en<br/></td>
<td>RW</td>
<td>0x0</td>
<td>Enable/Disable holding the isolation of cores 1 to 7 during the SoC WDT reset caused by hap_dm_ndmreset_n as follows:<br/>- 1: Enabled<br/>- 0: Disabled</td>
</tr>
<tr>
<td>2</td>
<td>C1_pwr_hold_en</td>
<td>RW</td>
<td>0x0</td>
<td>Enable/Disable holding the power to cluster 1 during the SoC WDT reset caused by hap_dm_ndmreset_n as follows:<br/>- 1: Enabled<br/>- 0: Disabled</td>
</tr>
<tr>
<td>1</td>
<td>hap_dm_ndmreset_clr</td>
<td>RW</td>
<td>0x0</td>
<td>Used to clear C01_hap_dm_ndmreset_n_mask = 1 (from hap_dm_ctl[4]) as per the following steps:<br/>- First, write 1 to this bit<br/>- Then, write 0 to this bit</td>
</tr>
<tr>
<td>0</td>
<td>hap_dm_ndmreset_n_dis</td>
<td>RW</td>
<td>0x1</td>
<td>Enable/Disable the SoC WDT reset caused by hap_dm_ndmreset_n as follows:<br/>- 0: Enabled<br/>- 1: Disabled</td>
</tr>
</tbody>
</table>

## 8.3 Real-Time CPU

### Introduction

The **Real-Time CPU (RCPU)** of K1 is a **32-bit RISC-V N308 High-Efficiency Processor Core** designed by **Nuclei System Technology Co. Ltd.**, and is used for IoT and low-power applications.

### Features

- Support for 3-stage pipeline, single-issue micro-architecture
- Support for RV32I/M/A/F/D/C/P/B instruction extensions
- Support for privileged mode
- Support for low power management as follows:

  - WFI and WFE schemes to enter sleep mode
  - Two-level sleep modes: shallow & deep
- Support for 16KB D-Cache
- Support for a 64-bit Real-Time Core-Private Timer (TIMER)
- Support for an Enhanced Core-Level Interrupt Controller (ECLIC) which

  - Support for RISC-V architecturally defined software, timer and external interrupts
  - Support for configurable interrupt levels and priorities
  - Support for vectored interrupt processing mode
- Support for  Non-Maskable Interrupt (NMI)
- Support for  8 PMP entries with 4KB minimal granularity
- Support for  RISC-V debug framework

### Functional Description

#### Clock Domains

The RCPU core has two asynchronous clock domains as follows:

- **Main clock domain**
  It drives most of the functional logic in RCPU, and consists of

  - The **rcpu_clk** clock as the primary working clock that drives the main domain inside RCPU, and is automatically clock-gated during sleep mode
  - The **rcpu_clk_aon** clock as an always-on clock that drives the always-on logic in RCPU, including **DEBUG**, **ECLIC**, **TIMER**
- **JTAG clock domain**
  It drives the JTAG logic of the DEBUG unit, and consist of

  - The **tck_s** clock created inside JTAG dividing by 3 the **jtag_TCK** clock

As said, both clock domains are asynchronous and an **asynchronous cross-clock domain process** has been implemented within RCPU to ensure proper operations.

The RCPU clock domains are depicted below.

![](static/RCPU_clock_domains.png)

#### Private Peripherals

In addition to the uCore, the RCPU hierarchy includes the following private peripherals:

- A handler of the JTAG interface and related debugging features (**DEBUG) **
- An Enhanced Core-Level Interrupt Controller (**ECLIC**)
- A Real-Time Core-Private Timer (**TIMER**)

Details are provided in the following subsections.

##### Address Spaces

Each private peripheral has its own address space as tabled below.

<table>
<tbody>
<tr>
<td><strong>Private Peripherals</strong></td>
<td><strong>Address Space </strong><strong>Size</strong></td>
<td><strong>Offset</strong></td>
<td><strong>Comments</strong></td>
</tr>
<tr>
<td>DEBUG</td>
<td>64KB</td>
<td>0x000~0xFFF</td>
<td>This address space is used for debugging functionality, regular application software should NOT access it.</td>
</tr>
<tr>
<td>ECLIC</td>
<td>64KB</td>
<td>0x0000~0xFFFF</td>
<td></td>
</tr>
<tr>
<td>TIMER</td>
<td>64KB</td>
<td>0x000~0xFFF</td>
<td></td>
</tr>
</tbody>
</table>

##### TIMER

###### Introduction

It is used to generate the timer and software interrupts in the RCPU core. The configuration details of TIMER registers are provided in **Section 3.4.3**. Its key functionality are provided in the following sections.

###### Time counting

TIMER implements a 64-bit register (**mtime**) consisting of the registers

- **mtime_hi (high)**
- **mtime_lo (low)**

for counting time. In particular, **mtime** is turned on by default and continues counting time after the reset de-assertion. The increase of its frequency is controlled by

- Either the core's input signal **mtime_toggle_a**
- Or the core's always-on clock **rcpu_aon_clk**

###### Timer interrupts generation

TIMER implements a 64-bit register (**mtimecmp**) consisting of the registers

- **mtimecmp_hi (high)**
- **mtimecmp_lo (low)**

for comparing the value of **mtime **with the value of **mtimecmp **to generate or not a timer interrupt. In particular,

- If **mtimectl.CMPCLREN** = **1**, then **mtime** will be automatically cleared to zero when its value is greater than the value of **mtimecmp**, and then the timer will restart from zero.
- If **mtimectl.CMPCLREN**= **0**, then **mtime** will continue to increase normally. The software can clear the timer interrupt by modifying either the value of **mtimecmp** or **mtime**, in order to ensure that the value of **mtimecmp** is greater than the value of **mtime**.

> **Note.** The timer interrupt is connected to ECLIC for unified interrupt management.

###### Software interrupts generation

TIMER implements a register (**msip**) to generate software interrupts. With reference to its configuration details tabled in **Section 9.3.4.3.9**, only the least significant bit (LSB) is effective for this purpose, which

- Is written to **1** by the software to generate a software interrupt
- Is written to **0** by the software to clear a software interrupt

> **Note.** The software interrupt is connected to **ECLIC** as unified interrupt management.

###### Software-Reset request generation

TIMER implement a register **msftrst** to generate a software-reset request. With reference to its configuration details provided later in **Section 9.3.4.3.7**, only the most significant bit (MSB) is effective for this purpose, which

- Is written to **0x80000a5f** to generate a software-reset request (this specific value is used to avoid the random mis-operation of software writing)
- Can be clear only by a reset (when the SoC resets the core in response to a software-reset request, **msftrst** register will be reset and cleared to zero)

> **Note.** The core's output signal **sysrstreq** (active high) is used to carry out the software-reset request, and is response to it, the SoC should reset the core by asserting **rcpu_reset_n** instead of **por_reset_n**.

##### ECLIC

###### Introduction


For real-time or microcontroller applications, the fast interrupt handling scheme is very important. To address this, RCPU includes an **Enhanced Core Local Interrupt Controller (ECLIC)**, which is the optimized version of the RISC-V standard CLIC, to manage all interrupt sources. To be highlighted:

- ECLIC only serves one core and privately operates inside the core
- To enable ECLIC, set the LSB bit of CSR registers **mtvec** as ECLIC mode
- ECLIC is functionally exclusive to PLIC
- ECLIC is used to manage multiple internal and external interrupts, send interrupt requests to core, and support interrupt preemption.

The configuration details of ECLIC registers are provided in **Section 9.3.4.4**. **Its key functionality are provided in the following sections.

###### Interrupt target

When ECLIC is enabled, it arbitrates interrupt sources and sends them to the processor core (the interrupt target) through a dedicated line as depicted below

![](static/ECLIC.png)

###### Interrupt Source ID

ECLIC assigns a unique ID to each interrupt source for supporting up to 64 interrupts, where

- Interrupt ID from 0 to 18 are reserved for the core-specified internal interrupts. Among these, ID 3 & 7 are fixed for software interrupt and timer interrupt respectively.
- Interrupt ID greater than 18 can be used by user to connect external interrupt sources.

Details are tabled below.

<table>
<tbody>
<tr>
<td><strong>ECLIC </strong><strong>I</strong><strong>nterrupt ID</strong></td>
<td><strong>Function</strong></td>
<td>ECLIC <strong>I</strong><strong>nterrupt Source Description</strong></td>
</tr>
<tr>
<td>0</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>2</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>3</td>
<td>Software interrupt</td>
<td>Software interrupt generated by TIMER</td>
</tr>
<tr>
<td>4</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>5</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>6</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>7</td>
<td>Timer interrupt</td>
<td>Timer interrupt generated by TIMER</td>
</tr>
<tr>
<td>8</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>9</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>10</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>11</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>12</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>13</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>14</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>15</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>16</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>17</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>18</td>
<td>Reserved</td>
<td>This source is not used</td>
</tr>
<tr>
<td>19~63</td>
<td>External interrupt</td>
<td>Normal external interrupt defined by user.<br/>> <strong>Note</strong><strong>. </strong>Although ECLIC can support up to 4096 interrupt sources under programming mode, the actual number of supported interrupt sources is indicated in the field <strong>clicinfo.NUM_INTERRUPT</strong></td>
</tr>
</tbody>
</table>

###### Interrupt Level & Priority

As depicted in **Section 9.3.3.2.3.2**, each interrupt source of **ECLIC** can be configured with specified level and priority. The key points are as follows:

- The **clicintctl** register of each interrupt source is 8-bit width, and the number of effective bits actually implemented by the hardware is specified by the **CLICINTCTLBITS** field in the **clicinfo** register.

  **[Example]** If the value of the **clicinfo.CLICINTCTLBITS** field is 6, it means that only the upper 6-bit of the **clicintctl** register are true valid bits, and the lowest 2 bits are tied to 1, as depicted below.

  > **Note.** The **CLICINTCTLBITS** field is a constant readable value, and software cannot overwrite it. Its valid value range is **2** ≤ **CLICINTCTLBITS** ≤ **8**.
  >
- The effective bits of the **clicintctl** register are divided into

  - One dynamic field for the **interrupt level**
  - One dynamic field for the **interrupt priority**

  The width of the level field is defined by **cliccfg.nlbits**.

  **[Example]** If the value of **cliccfg.nlbits** is 4, it means that the upper 4-bit of the effective bits in **clicintctl** represent the level field, while the remaining lower effective bits represent the priority field, as depicted below.

  > **Note.** The **cliccfg.nlbits** field is both readable and writeable, which means the software can modify its value.
  >

  ![](static/cliccfg.nlbits.png)

About **interrupt level**:

- The value of level is read in a left-aligned manner. Except the effective bits, defined by the value of **cliccfg.nlbits**, the lower ineffective bits are all filled with the constant **1**, in particular

  - If **cliccfg.nlbits \> clicinfo.CLICINTCTLBITS**, the number of bits indicated by **nlbits** exceeds the effective bits of the **clicintctl** register, and the excess bits are filled with constant **1**
  - If **cliccfg.nlbits = 0**, the value of level will be regarded as a fixed value of **255**
  - A greater value of level corresponds to higher priority
- **Interrupt preemption**: Higher-level interrupts can preempt lower-level interrupts. When multiple interrupts are pending (**IP**=**1**), **ECLIC** performs arbitration to determine which interrupt needs to be sent to the core. The level of each interrupt source is a key factor in this arbitration process.
  An example of how the level value is decoded is depicted below.

  ![](static/level_value.png)

Instead, about **interrupt priority:**

- The priority value is also read in a left-aligned manner. Except for the effective bits, defined by **clicinfo.CLICINTCTLBITS - cliccfg.nlbits**, the lower ineffective bits are filled with the constant **1**, in particular

  - A greater value of priority corresponds to higher priority

  > **Note.** The priority of the interrupt does not influence interrupt preemption, which means whether an interrupt can preempt another interrupt is independent of its priority value.
  >

  When multiple interrupts are simultaneously pending, **ECLIC** needs to perform arbitration to determine which interrupt can be sent to the core. This arbitration needs to consider both the value of level and the value of priority of each interrupt source.

#### Control & Status Registers (CSRs)

Some Control & Status Registers (CSRs) are defined in the RISC-V architecture to configure or record the status of execution, where

- CSRs are internal registers within the core which uses a 12-bit encoding space to access their values
- Extended CSR registers are defined for **D-Cache Control and Maintenance (CCM)** operations, including

  - FLUSH
  - INVAL
  - LOCK
  - UNLOCK

  These operations can be performed on specific **addresses** (ADDR) or applied **globally** (ALL).

#### Performance Monitor

The RISC-V architecture defines two performance counters as follows:

- **Cycle Counter**:

  - It is a 64-bit wide clock cycle counter that tracks the number of clock cycles the core has executed. This counter continuously increases as long as the core's **rcpu_clk_aon** is on.
  - The CSR **mcycle** reflects the lower 32 bits of this counter, while the CSR **mcycleh**_ _reflects the upper 32 bits.

- **Instruction Retirement Counter**:

  - It is a 64-bit counter that tracks the number of instructions the core has executed successfully. The counter will increase if the processor executes an instruction successfully.
  - The CSR **minstret** reflects the lower 32 bits of this counter, while the CSR **minstreth** reflects the upper 32 bits.

Both the **Cycle Counter** and **Instruction Retirement Counter** are typically used to measure performance.

By default, the counter value starts from zero after a reset and increases continuously. In order to save power, an extra bit in the customized CSR **mcountinhibit** can pause the counter to save power when performance monitoring is not needed.

#### Low-Power Mechanism

The low-power mechanism of the RCPU core operates as follows:

- The clocks of the core's main units are automatically gated off when they are idle for reducing static power consumption.
- The core supports different sleep modes (**shallow sleep mode** or **deep sleep mode**) through **WFI (Wait For Interrupt)** and **WFE (Wait For Event)** mechanisms to achieve lower dynamic and static power consumption.

#### Clock Control

Two cases are distinguished:

- For the case that the core is waiting for an interrupt to wake up, because the core can only handle the interrupt processed and distributed by **ECLIC**, then only the interrupt, which is enabled and has a greater interrupt level than the interrupt threshold level, can wake up the core. Furthermore, whether to enable the **rcpu_clk_aon** inside the core needs to be handled carefully:

  - **TIMER** is clocked by **rcpu_clk_aon**, so if the SoC system has disabled the always-on clock **rcpu_clk_aon**, **TIMER** cannot generate timer or software interrupt because it has no working clock, and the core cannnot be woken up.
  - **ECLIC** is clocked by **rcpu_clk_aon**, so if the SoC system has disabled the always-on clock **rcpu_clk_aon**, then the external interrupt signal must keep asserted until the SoC enables the **rcpu_clk_aon** again. Otherwise, **ECLIC** cannot sample the external interrupt signal because it has no working clock, and the core cannot be woken up.
- For the case that the core is waiting for an event or NMI to wake up, if the core sampled (by the **rcpu_clk_aon**) the input signal **rx_evt** (which indicates there is one event) or the input signal **nmi** (which indicates there is one NMI), the core will be woken up. Furthermore, whether to enable the **rcpu_clk_aon** inside the core needs to be handled carefully:

  - If the SoC system has disabled the always-on clock **rcpu_clk_aon**, then the input signal **rx_evt** or **nmi** must be kept as 1 until the SoC turns on the clock **rcpu_aon_clk**. Otherwise, the core cannot sample the **rx_evt** or **nmi** as the sample logic has no working clock, and the core will not wake up.

#### Physical Memory Protection

Since the RCPU is a low-power core designed for micro-controllers, it does not support the Memory Management Unit (MMU), so all the address access operations use physical addresses. In order to perform memory access protection and isolation according to memory physical address and execution privilege mode, the RISC-V standard architecture defines a physical memory protection (PMP) mechanism.

RCPU is configured to support

- 8 PMP entries, each with 4KB minimal granularity
- The PMP TOR (Top of Range) mode

### Registers Description

#### Core Control & Status Registers (CSRs)

##### mnvec

**mnvec** is a customized CSR holding the NMI entry address. When an NMI is triggered while the processor is running a program, the program is forced to jump into a new PC address, which is determined by the value of **mnvec**. And the value of **mnvec** register is controlled by the **mmisc_ctl** register.

##### msubm

**msubm** holds:

- The current machine sub-mode
- The machine sub-mode before the current trap

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x07C4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:10</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0</td>
</tr>
<tr>
<td>9:8</td>
<td>PTYP</td>
<td>RW</td>
<td>0x0</td>
<td>Machine sub-mode before entering the trap:<br/>- 0: Normal Machine Mode<br/>- 1: Interrupt Handling Mode<br/>- 2: Exception Handling Mode<br/>- 3: NMI Handling Mode</td>
</tr>
<tr>
<td>7:6</td>
<td>TYP</td>
<td>RW</td>
<td>0x0</td>
<td>Current sub-mode:<br/>- 0: Normal Machine Mode<br/>- 1: Interrupt Handling Mode<br/>- 2: Exception Handling Mode<br/>- 3: NMI Handling Mode</td>
</tr>
<tr>
<td>5:0</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, ties to 0.</td>
</tr>
</tbody>
</table>

##### mdcause

**mdcause** is used to further record the exception difference.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x07C9</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0</td>
</tr>
<tr>
<td>2:0</td>
<td>PTYP</td>
<td>RW</td>
<td>0x0</td>
<td>Further record the detailed information about the exception. <br/>When mcause.EXCCODE=1 (instruction access fault):<br/>- 0: Reserved<br/>- 1: PMP permission violation<br/>- 2: Bus error<br/>- 3-7: Reserved<br/>When mcause.EXCCODE=5 (load access fault):<br/>- 0: Reserved<br/>- 1: PMP permission violation bus error<br/>- 2: Bus error caused by core memory read<br/>- 4-7: Reserved<br/>When mcause.EXCCODE=7 (store/AMO access fault):<br/>- 0: Reserved<br/>- 1: PMP permission violation bus error<br/>- 2: Bus error caused by core memory write<br/>- 3-7: Reserved</td>
</tr>
</tbody>
</table>

##### mcache_ct

**mcache_ctl** is used to control the I-Cache and D-Cache features.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x07CA</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:21</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
<tr>
<td>20:17</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
<tr>
<td>16</td>
<td>DC_EN</td>
<td>RW</td>
<td>0x0</td>
<td>D-Cache enable control:<br/>- 0: D-Cache disabled (default)<br/>- 1: D-Cache enabled<br/>> <strong>Note</strong><strong>.</strong> When D-Cache is disabled in runtime, it just bypasses D-Cache. Users should writeback and invalidate all D-Cache before disabling it.</td>
</tr>
<tr>
<td>15:1</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
<tr>
<td>0</td>
<td>IC_EN</td>
<td>RW</td>
<td>0x0</td>
<td>I-Cache enable control:<br/>- 0: I-Cache disable (default)<br/>- 1: I-Cache enable<br/>> <strong>Note</strong><strong>.</strong> When I-Cache is disabled in runtime, it just bypasses I-Cache. Users should writeback and invalidate all I-Cache before disabling it.</td>
</tr>
</tbody>
</table>

##### mmisc_ctl

**mmisc_ctl** is used to control many micro-architecture implementation-related features.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x07D0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:13</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
<tr>
<td>12</td>
<td>LDSPEC_ENABLE</td>
<td>RW</td>
<td>0x0</td>
<td>Enable or disable the load speculative going to memory interface:<br/>- 0: Disable<br/>- 1: Enable</td>
</tr>
<tr>
<td>11</td>
<td>SIJUMP_ENABLE</td>
<td>RW</td>
<td>0x0</td>
<td>Control the SIJUMP mode of trace:<br/>- 0: SIJUMP mode is off<br/>- 1: SIJUMP mode is on</td>
</tr>
<tr>
<td>10</td>
<td>IMRETURN_ENABLE</td>
<td>RW</td>
<td>0x0</td>
<td>Control the IMRETURN mode of trace:<br/>- 0: IMRETURN mode is off<br/>- 1: IMRETURN mode is on</td>
</tr>
<tr>
<td>9</td>
<td>NMI_CAUSE_FFF</td>
<td>RW</td>
<td>0x0</td>
<td>Control mnvec and mcause.EXCCODE of NMI:<br/>- 0: The value of nmvec equals the PC address after reset, mcause.EXCCODE of NMI is 0x1<br/>- 1: The value of mnvec is the same as the value of mtvec, mcause.EXCCODE of NMI is 0xfff</td>
</tr>
<tr>
<td>8</td>
<td>CORE_BUS_ERR</td>
<td>RW</td>
<td>0x0</td>
<td>Control the bus error caused by core is exception or interrupt:<br/>- 0: Core bus error caused by core is an exception<br/>- 1: Core bus error caused by core is an interrupt</td>
</tr>
<tr>
<td>7</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
<tr>
<td>6</td>
<td>UNALGN_ENABLE</td>
<td>RW</td>
<td>0x0</td>
<td>Enable or disable misaligned load/store access:<br/>- 0: Disable, then accessing misaligned memory locations will trigger an Address Misaligned exception:<br/>- 1: Enable<br/>> <strong>Note</strong><strong>.</strong> This field only takes effect on load/store specified in I/F/D extension. For load/store specified in A extension, misaligned accesses always trigger an address misaligned exception.</td>
</tr>
<tr>
<td>5:4</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
<tr>
<td>3</td>
<td>BPU_ENABLE</td>
<td>RW</td>
<td>0x1</td>
<td>Enable or disable the BPU Unit:<br/>- 0: Disable<br/>- 1: Enable<br/>> <strong>Note</strong><strong>.</strong> If BPU is disabled by software, all branches are predicted to jump statically until the BPU is enabled again.</td>
</tr>
<tr>
<td>2:0</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
</tbody>
</table>

#### Performance Monitor CSRs

##### Introduction

RCPU supports configurable performance monitor CSR used for counting on various events for performance profiling, and their implementation follow exactly RISC-V privilege specification (user can refer to it for a detailed description).

##### mhpmcounter[i] (3 ≤ i ≤ 6)

**mhpmcounter[i] (3 ≤ i ≤ 6)** is used to record specific micro-architecture event numbers.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xB00+i</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>MXLEN-1:32</td>
<td>Reserved</td>
<td>RW</td>
<td>0x0<br/></td>
<td>Tied to 0 for RV32, applicable only for RV64</td>
</tr>
<tr>
<td>31:0</td>
<td>mhpmcounteri</td>
<td>RW</td>
<td>0x0</td>
<td>Machine performance monitor counter i.<br/>(where 3 ≤ i ≤ 6)</td>
</tr>
</tbody>
</table>

##### mhpmcounter[i] (7 ≤ i ≤ 31)

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xB00+i</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>MXLEN-1:32</td>
<td>Reserved</td>
<td>R</td>
<td>0x0</td>
<td>Tied to 0, applicable only for RV64.</td>
</tr>
<tr>
<td>31:0</td>
<td>mhpmcounteri</td>
<td>RW</td>
<td>0x0</td>
<td>Tie 0.<br/>(where 7 ≤ i ≤ 31)</td>
</tr>
</tbody>
</table>

##### mhpmcounterh[i]

**mhpmcounterh[i]** is used to record the upper 32 bit numbers of specific micro-architecture event. It is only for RV32.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xB80+i</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>MXLEN-1:0</td>
<td>mhpmcounterhi</td>
<td>R</td>
<td>0x0</td>
<td>Tied to 0, applicable only for RV32.<br/>(where 0 ≤ i ≤ 31)</td>
</tr>
</tbody>
</table>

##### mcountinhibit

The counter-inhibit **mcountinhibit** CSR is a **MXLEN-bit WARL** register that controls which hardware performance-monitoring counters increment. The settings in this CSR register affect only the increment behavior of the counters, and they do not influence the accessibility of the counters, in particular:

- When the **CY**, **IR** or **HPMn** bit in the **mcountinhibit** register is clear (set to 0), the corresponding counter (**cycle**, **instret**, or **hpmcountern**) increments as usual.
- When the **CY**, **IR**, or **HPMn** bit is set (set to 1), the corresponding counter (**cycle**, **instret**, or **hpmcountern**) does not increment.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x320</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>MXLEN-1:7</td>
<td>Reserved</td>
<td>R</td>
<td>0x0</td>
<td>-</td>
</tr>
<tr>
<td>6</td>
<td>HPM6</td>
<td>RW</td>
<td>0x0</td>
<td>If set, the increment of the performance monitor counter 6 is stopped</td>
</tr>
<tr>
<td>5</td>
<td>HPM5</td>
<td>RW</td>
<td>0x0</td>
<td>If set, the increment of the performance monitor counter 5 is stopped</td>
</tr>
<tr>
<td>4</td>
<td>HPM4</td>
<td>RW</td>
<td>0x0</td>
<td>If set, the increment of the performance monitor counter 4 is stopped</td>
</tr>
<tr>
<td>3</td>
<td>HPM3</td>
<td>RW</td>
<td>0x0</td>
<td>If set, the increment of the performance monitor counter 3 is stopped</td>
</tr>
<tr>
<td>2</td>
<td>IR</td>
<td>RW</td>
<td>0x0</td>
<td>If set, the increment of the instret counter is stopped</td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td>R</td>
<td>0x0</td>
<td>-</td>
</tr>
<tr>
<td>0</td>
<td>CY</td>
<td>RW</td>
<td>0x0</td>
<td>If set, the increment of the cycle counter is stopped</td>
</tr>
</tbody>
</table>

##### mhpmevent3~6

The event selector **mhpmevent3~mhpmevent31** CSR, are **MXLEN-bit WARL** registers that control which event causes the corresponding counter to increase.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x320+i</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>MXLEN-1:32</td>
<td>Reserved</td>
<td>R</td>
<td>0x0</td>
<td>-</td>
</tr>
<tr>
<td>31</td>
<td>mevent_enable</td>
<td>RW</td>
<td>0x1</td>
<td>Enable the corresponding performance monitor counter increment for events in Machine Mode.</td>
</tr>
<tr>
<td>30</td>
<td>Reserved</td>
<td>R</td>
<td>0x0</td>
<td>0</td>
</tr>
<tr>
<td>29</td>
<td>sevent_enable</td>
<td>RW</td>
<td>0x1</td>
<td>Enable the corresponding performance monitor counter increment for events in Supervisor Mode.</td>
</tr>
<tr>
<td>28</td>
<td>uevent_enable</td>
<td>RW</td>
<td>0x1</td>
<td>Enable the corresponding performance monitor counter increment for events in User Mode.</td>
</tr>
<tr>
<td>27:9</td>
<td>Reserved</td>
<td>R</td>
<td>0x0</td>
<td>-</td>
</tr>
<tr>
<td>8:4</td>
<td>event_idx<br/></td>
<td>RW</td>
<td>0x0</td>
<td>Detailed event selector.<br/>For instruction commit events, see <strong>Section 9.3.4.2.8</strong> for more details.<br/>For memory access events, see <strong>Section 9.3.4.2.9</strong> for more details.</td>
</tr>
<tr>
<td>3:0</td>
<td>event_sel<br/></td>
<td>RW</td>
<td>0x0</td>
<td>0: Select the instruction commit events, such as load, store, bjp ect. (see <strong>Section 9.3.4.2.8</strong> for more details).<br/>1: Select the memory access events, such as icache miss, dcache miss ect. (see <strong>Section</strong><strong> </strong><strong>9.3.4.2.9</strong> for more details).</td>
</tr>
</tbody>
</table>

##### mhpmevent7~3

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x320+i</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>MXLEN-1:0</td>
<td>Reserved</td>
<td>R</td>
<td>0x0</td>
<td>-</td>
</tr>
</tbody>
</table>

##### mhpeventi[3:0]==0

Event selection value for instruction commit events are tabled below.

<table>
<tbody>
<tr>
<td><strong>event_idx</strong><br/><strong>(mhpeventi[3:0]==0)</strong></td>
<td><strong>Event Name</strong></td>
</tr>
<tr>
<td>1</td>
<td>Cycle count</td>
</tr>
<tr>
<td>2</td>
<td>Retired instruction count</td>
</tr>
<tr>
<td>3</td>
<td>Integer load instruction (includes LR)</td>
</tr>
<tr>
<td>4</td>
<td>Integer store instruction (includes SC)</td>
</tr>
<tr>
<td>5</td>
<td>Atomic memory operation (do not include LR and SC)</td>
</tr>
<tr>
<td>6</td>
<td>System instruction</td>
</tr>
<tr>
<td>7</td>
<td>Integer computational instruction (excluding multiplication/division/remainder)</td>
</tr>
<tr>
<td>8</td>
<td>Conditional branch</td>
</tr>
<tr>
<td>9</td>
<td>Taken conditional branch</td>
</tr>
<tr>
<td>10</td>
<td>JAL instruction</td>
</tr>
<tr>
<td>11</td>
<td>JALR instruction</td>
</tr>
<tr>
<td>12</td>
<td>Return instruction</td>
</tr>
<tr>
<td>13</td>
<td>Control transfer instruction (CBR+JAL+JALR)</td>
</tr>
<tr>
<td>14</td>
<td>-</td>
</tr>
<tr>
<td>15</td>
<td>Integer multiplication instruction</td>
</tr>
<tr>
<td>16</td>
<td>Integer division/remainder instruction</td>
</tr>
<tr>
<td>17</td>
<td>Floating-point load instruction</td>
</tr>
<tr>
<td>18</td>
<td>Floating-point store instruction</td>
</tr>
<tr>
<td>19</td>
<td>Floating-point addition/substraction</td>
</tr>
<tr>
<td>20</td>
<td>Floating-point multiplication</td>
</tr>
<tr>
<td>21</td>
<td>Floating-point fused multiply-add (FMADD, FMSUB, FNMSUB, FNMADD)</td>
</tr>
<tr>
<td>22</td>
<td>Floating-point division or square-root</td>
</tr>
<tr>
<td>23</td>
<td>Other floating-point instruction</td>
</tr>
<tr>
<td>24</td>
<td>Conditional branch prediction fail</td>
</tr>
<tr>
<td>25</td>
<td>JAL prediction fail</td>
</tr>
<tr>
<td>26</td>
<td>JALR prediction fail</td>
</tr>
</tbody>
</table>

##### mhpeventi[3:0]==1

Event selection value for instruction commit events are tabled below.

<table>
<tbody>
<tr>
<td><strong>event_idx</strong><br/><strong>(mhpeventi[3:0]==1)</strong></td>
<td><strong>Event Name</strong></td>
</tr>
<tr>
<td>1</td>
<td>Icache miss</td>
</tr>
<tr>
<td>2</td>
<td>Dcache miss</td>
</tr>
<tr>
<td>3</td>
<td>ITLB miss</td>
</tr>
<tr>
<td>4</td>
<td>DLTB miss</td>
</tr>
<tr>
<td>5</td>
<td>Main TLB miss</td>
</tr>
</tbody>
</table>

#### TIMER Registers

##### Introduction

The **base address** of **TIME** registers is **0xE003_0000**

##### mtime_lo

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5>##### <strong>Offset: 0x0000</strong></td>
<td>##### </td>
<td>##### </td>
<td>##### </td>
<td>##### </td>
</tr>
<tr>
<td>##### <strong>Bits</strong></td>
<td>##### <strong>Field</strong></td>
<td>##### <strong>Type</strong></td>
<td>##### <strong>Reset</strong></td>
<td>##### <strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>mtime</td>
<td>RW</td>
<td>0x0</td>
<td>Reflect the lower 32-bit value of mtime.<br/>Shadow copy of MTIME in CLINT mode</td>
</tr>
</tbody>
</table>

##### mtime_hi

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0004</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>mtime</td>
<td>RW</td>
<td>0x0</td>
<td>Reflect the upper 32-bit value of mtime.<br/>Shadow copy of MTIME in CLINT mode</td>
</tr>
</tbody>
</table>

##### mtimecmp_l

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0008</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>mtimecmp</td>
<td>RW</td>
<td>0xFFFFFFFF</td>
<td>Set the lower 32-bit value of mtimecmp.<br/>Shadow copy of MTIMECMP for Hart-0 in CLINT mode.</td>
</tr>
</tbody>
</table>

##### mtimecmp_hi

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x000C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>mtimecmp</td>
<td>RW</td>
<td>0xFFFFFFFF</td>
<td>Set the upper 32-bit value of mtimecmp.<br/>Shadow copy of MTIMECMP for Hart-0 in CLINT mode.</td>
</tr>
</tbody>
</table>

##### mtime_srw_ctrl

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0FEC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Control S-mode can access this timer or not.</td>
</tr>
<tr>
<td>0</td>
<td>mtime_srw_ctrl</td>
<td>RW</td>
<td>0x0</td>
<td>Control S-mode can read or write timer registers or not:<br/>- 0: S-Mode can read/write all timer registers<br/>- 1: S-Mode can not read/write timer registers</td>
</tr>
</tbody>
</table>

##### msftrst

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0FF0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>MSFTRST</td>
<td>RW</td>
<td>0x0</td>
<td>Generate a software-reset request</td>
</tr>
<tr>
<td>30:0</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
</tbody>
</table>

##### mtimectl

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0FF8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0</td>
</tr>
<tr>
<td>2</td>
<td>CLKSRC</td>
<td>RW</td>
<td>0x0</td>
<td>Select the source of increment frequency.<br/>If this field is 1, then the increment frequency is rcpu_aon_clk, otherwise the increment frequency is controlled by mtime_toggle_a.</td>
</tr>
<tr>
<td>1</td>
<td>CMPCLREN</td>
<td>RW</td>
<td>0x0</td>
<td>Control the timer count to clear-to-zero or not.<br/>If this field is 1, then the mtime register will be cleared to zero after generating timer interrupt, otherwise it increases normally.<br/>> <strong>Note</strong><strong>.</strong> If CMPCLREN is enabled, the timer interrupt request will be a pulse request. In this case, timer interrupt should be set to edge-trigger mode.</td>
</tr>
<tr>
<td>0</td>
<td>TIMESTOP</td>
<td></td>
<td></td>
<td>Control the timer count or pause.<br/>If this field is 1, then the timer pauses, otherwise it increases normally.</td>
</tr>
</tbody>
</table>

##### msip

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0FFC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Reserved</td>
<td>N/A</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
<tr>
<td>0</td>
<td>MSIP</td>
<td>RW</td>
<td>0x0</td>
<td>This bit is used to generate a software interrupt.<br/>Shadow copy of MSIP for Hart-0 in CLINT mode</td>
</tr>
</tbody>
</table>

#### ECLIC Registers

##### Introduction

The **base address** of **ECLIC** registers is **0xE002_0000**

##### cliccfg

**cliccfg** is a global configurations setting register, the software can write into it.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0000</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>7:5</td>
<td>Reserved</td>
<td>R</td>
<td>N/A</td>
<td>Reserved, tied to 0</td>
</tr>
<tr>
<td>4:1</td>
<td>nlbits</td>
<td>RW</td>
<td>0x0</td>
<td>Used to specify the bit-width of level and priority in the register clicintctl[i]</td>
</tr>
<tr>
<td>0</td>
<td>Reserved</td>
<td>R</td>
<td>N/A</td>
<td>Reserved, tied to 1</td>
</tr>
</tbody>
</table>

##### clicinfo

**clicinfo** is a global parameters register, the software can query it.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0004</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:25</td>
<td>Reserved</td>
<td>R</td>
<td>N/A</td>
<td>Reserved, tied to 0</td>
</tr>
<tr>
<td>24:21</td>
<td>CLICINTCTLBITS</td>
<td>R</td>
<td>N/A</td>
<td>Used to specify the effective bit-width of the register clicintctl[i]</td>
</tr>
<tr>
<td>20:13</td>
<td>VERSION</td>
<td>R</td>
<td>N/A</td>
<td>Hardware implementation version number</td>
</tr>
<tr>
<td>12:0</td>
<td>NUM_INTERRUPT</td>
<td>R</td>
<td>N/A</td>
<td>Number of interrupt sources supported by the hardware</td>
</tr>
</tbody>
</table>

##### mth

**mth** is used to set the target interrupt threshold level, the software can write into it.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x000b</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>7:0</td>
<td>mth</td>
<td>RW</td>
<td>N/A</td>
<td>Target threshold level register.<br/>> <strong>Note</strong><strong>. </strong>Only when the level of the interrupt finally arbitrated by ECLIC is higher than the level in this register, the interrupt can be sent to the processor core.</td>
</tr>
</tbody>
</table>

##### clicintip[i]

**clicintip[i]** is the pending flag register for the interrupt source.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1000+4*i</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>7:1</td>
<td>Reserved</td>
<td>RO</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
<tr>
<td>0</td>
<td>IP</td>
<td>RW</td>
<td>0x0</td>
<td>Interrupt source pending flag:<br/>- 0: interrupt is not triggered<br/>- 1: interrupt is triggered<br/>> <strong>Note</strong><strong>.</strong> For edge-triggered interrupt source, the IP bit may be cleared by the hardware itself.</td>
</tr>
</tbody>
</table>

##### clicintie[i]

**clicintie[i]** is the enable bit register for the interrupt source.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1001+4*i</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>7:1</td>
<td>Reserved</td>
<td>R</td>
<td>N/A</td>
<td>Reserved, tied to 0.</td>
</tr>
<tr>
<td>0</td>
<td>IE</td>
<td>RW</td>
<td>0x0</td>
<td>Interrupt enable bit:<br/>- 0: interrupt source is masked<br/>- 1: interrupt is enabled</td>
</tr>
</tbody>
</table>

##### clicintattr[i]

**clicintattr[i]** is used to indicate the attribute of the interrupt source, the software can write into it.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1002+4*i</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>7:6</td>
<td>Reserved</td>
<td>R</td>
<td>N/A</td>
<td>Reserved, tied to 2'b11</td>
</tr>
<tr>
<td>5:3</td>
<td>Reserved</td>
<td>R</td>
<td>N/A</td>
<td>Reserved, tied to 0</td>
</tr>
<tr>
<td>2:1</td>
<td>trig</td>
<td>RW</td>
<td>0x0</td>
<td>Used to set the level or edge triggered attribute of the interrupt source:<br/>- 2'b00: level-triggered interrupt. The IP bit of the interrupt source will reflect the level of the interrupt source in real time. The software writing to this IP bit is ignored. The IP bit can only be cleared by clearing the original source of the interrupt.<br/>- 2'b01: Rising edge-triggered interrupt the software can set or clear the IP bit by writing operations.<br/>- 2'b11: Falling edge-triggered interrupt, the software can set or clear the IP bit by writing operations.<br/>> <strong>Note</strong><strong>.</strong> In order to improve the efficiency of the interrupt processing, when the interrupt is taken and the core jumps to the ISR (Interrupt Service Routine), the hardware of ECLIC will clear the IP bit automatically, and the software needs not to clear the IP bit in ISR.</td>
</tr>
<tr>
<td>0</td>
<td>shv</td>
<td>RW</td>
<td>0x0</td>
<td>Used to set whether the interrupt is vectored or non-vectored:<br/>- 0: Non-vectored mode. The core will jump to the common base entry shared by all interrupts when the interrupt is taken.<br/>- 1: Vectored mode. The core will directly jump to the target address stored in the vector table entry when the interrupt is taken.</td>
</tr>
</tbody>
</table>

##### clicintctl[i]

**clicintctl[i]** is the control register of the interrupt source, the software can set the level and priority into it. The level and priority field are dynamically allocated based on the value of **cliccfg.nlbits**.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1003+4*i</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>7:7-(nlbits-1)</td>
<td>Level</td>
<td>RW</td>
<td>N/A</td>
<td>Interrupt source level, a greater value of level results in a higher ECLIC arbitration priority.</td>
</tr>
<tr>
<td>7-(nlbits-1):7-(CLICINTCTLBITS-1)</td>
<td>Priority</td>
<td>RW</td>
<td>N/A</td>
<td>Interrupt source priority, a greater value of level results in a higher ECLIC arbitration priority.</td>
</tr>
<tr>
<td>7-(CLICINTCTLBITS-1):0</td>
<td>Reserved</td>
<td>RO</td>
<td>N/A<br/></td>
<td>Reserved, tied to 1.</td>
</tr>
</tbody>
</table>
