# 13. Display Subsystem

```
Last Version: 2025/11/18
```

## 13.1 Display Controller

### Introduction

The Display Controller is a hardware block that is used to transfer display data from the display’s internal memory to the DSI controller. It supports one independent display device through MIPI DSI.

### Features

- Support for up to Full HD (1920x1080@60fps)
- Support for up to 4-full-size-layer composer and maximum 8 layer-composers by up-down layer reuse in the RDMA channel
- Support for _cmdlist_ mechanism allowing hardware register parameters to be configured
- Support for concurrent write-back operations with both raw and AFBC format
- Support for dithering, cropping, rotation in write-back path
- Advanced MMU (virtual address) mechanism for nearly no page missing during 90° and 270° rotation
- Support for color keying and solid color generation
- Support for both advanced error diffusion and pattern-based dithering for the panel
- Support for both AFBC and raw format image sources
- Color saturation and contrast enhancement
- Support for both video mode and _cmd_ mode (with frame buffer in LCM) for the panel
- Support for dynamic DDR frequency adjustment with an embedded DFC buffer
- Support for the following **input formats** (see also the map shown immediately after):

  - A2BGR101010, A2RGB101010, BGR101010A2, RGB101010A2
  - ABGR8888, ARGB8888, BGRA8888, RGBA8888
  - XBGR8888, XRGB8888, BGRX8888, RGBX8888
  - BGR888, RGB888, ABGR1555, RGBA5551, BGR565/RGB565
  - XYUV_444_P1_8, XYUV_444_P1_10, YVYU_422_P1_8, VYUY_422_P1_8
  - YUV_420_P2_8, YUV_420_P3_8
    ![](static/input_formats.png)
- Support for the following **output formats**:

  - RGB888, RGB565, RGB666

### Block Diagram

The micro-architecture of the display subsystem is depicted below.

![](static/display_subsystem.png)

## 13.2 HDMI Interface

### Features

- Compliance with HDMI Specification v1.4
- Dual-channel audio stream within the range 32~192KHz
- Physical lane speed up to 2.4Gbps/lane × 3lane
- Support for up to 1920x1440@60Hz
- Support for RGB and YcbCr 4:2:2 / 4:4:4 input video format
- Support for RGB and YcbCr 4:2:2 / 4:4:4 output video formats
- Support for 8bpc / 10bpc / 12bpc input and output color depths
- Support for EIA/CEA-861-F video timing and InfoFrame structure
- Support for L-PCM(IEC 60958), 32~192KHz dual channel audio data
- Support for Consumer Electronic Control (CEC) standard packets and user-defined packets
- Inclusion of an Internal I2C Master for remote ED access, supporting 100~400Kbps speed

### Block Diagram

The architecture of the HDMI interface is depicted below.

![](static/HDMI_interface.png)

## 13.3 MIPI-DSI

### Introduction

The MIPI Display Serial Interface (MIPI DSI) is a high-speed interface between a host processor and peripheral devices that adheres to MIPI Alliance specifications for mobile device interfaces.

### Features

- Compliance with the MIPI DSI standard v1.0
- Compliance with the MIPI DPHY specification v1.1
- Support for MIPI DPHY up to 4 data lanes and speed up to 1200Mbps per lane
- Support for 1 active panel per DPHY link
- Compliance with the Display Command Set (DCS) standard
- Support for all pixel formats defined in DSI and DCS
- Support for video burst mode with DPHY up to 1.2Ghz per lane
- Support for virtual channels in the MIPI Link
- Support for up to 1080p resolution
- Support for command, video and burst modes
- Support for HS-TX, LP-TX, LP-RX and LP-CD signaling

### Functional Description

The DSI packet arbitration is depicted below.

![](static/DSI.png)

As can be seen, the DSI packet arbitration is based on the timing period of the DSI internal timing control, which divides the H line time into 4 periods, in particular:

- **Control packet period:** HSS, HSA, and HSE
- **Blanking period 1**: BL or smart panel packet + LP
- **Active video**: RGB
- **Blanking period 2**: BL or smart panel packet + LP

The BL packet word count is programmable and is defined as bytes in byte clock. If smart panel packet is inserted, DSI hardware switches to LP after the smart panel packet is sent.

The DSI Timing Relationship with LCD Timing is as follows:

- The DSI controller generates its timing based in LCD vsync
- The DSI syncs up every frame with the LCD controller
- Both DSI and LCD share the same H total value and run at the same pixel clock rate. As a result, the horizontal line time is the same for both the DSI and LCD controllers.
- Additionally, the shift between LCD controller line to DSI line is programmable

### Register Description

> **Note.** Base address = **0xD421_A800**

#### DSI_CTRL_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CFG_SOFT_RST</td>
<td>RW<br/></td>
<td>0x0</td>
<td>Software Reset DSI Module <br/>1: Reset DSI module <br/>0: De-assert software reset </td>
</tr>
<tr>
<td>30<br/></td>
<td>CFG_SOFT_RST_REG</td>
<td>RW</td>
<td>0x0</td>
<td>Software Reset Configuration Registers <br/>1: Reset DSI configuration registers to default values <br/>0: De-assert reset </td>
</tr>
<tr>
<td>29</td>
<td>CFG_CLR_PHY_FIFO</td>
<td>RW</td>
<td>0x0</td>
<td>Configure Clear PHY Tx FIFO <br/>1: Clear FIFO data to 0 <br/>0: De-assert clear <br/>It is NOT used currently and reserved for future use. </td>
</tr>
<tr>
<td>28</td>
<td>CFG_RST_TXLP</td>
<td>RW</td>
<td>0x0</td>
<td>Software Reset LP TX submodule <br/>1: Reset LP TX module <br/>0: De-assert software reset </td>
</tr>
<tr>
<td>27</td>
<td>CFG_RST_CPU</td>
<td>RW</td>
<td>0x0</td>
<td>Software Reset CPU TX submodule <br/>1: Reset CPU TX module <br/>0: De-assert software reset </td>
</tr>
<tr>
<td>26</td>
<td>CFG_RST_CPN</td>
<td>RW</td>
<td>0x0</td>
<td>Software Reset CPN TX submodule <br/>1: Reset CPN TX module <br/>0: De-assert software reset </td>
</tr>
<tr>
<td>25</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>24</td>
<td>CFG_RST_VPN</td>
<td>RW</td>
<td>0x0</td>
<td>Software Reset Video Panel submodule <br/>1: Reset VPN module <br/>0: De-assert software reset </td>
</tr>
<tr>
<td>23</td>
<td>CFG_DSI_PHY_RST</td>
<td>RW</td>
<td>0x0</td>
<td>Software Reset DPHY submodule <br/>1: Reset DPHY <br/>0: De-assert software reset </td>
</tr>
<tr>
<td>22:18</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use<br/></td>
</tr>
<tr>
<td>17</td>
<td>CFG_DSI_HCLK_DIS</td>
<td>RW</td>
<td>0x0</td>
<td>DSI AHB Clock Disable<br/>> <strong>Note</strong><strong>.</strong> DSI configuration registers can still be written or read even if the DSI AHB clock is disabled. <br/>1: DSI AHB clock will be gated <br/>0: DSI AHB clock is passed to DSI module </td>
</tr>
<tr>
<td>16</td>
<td>CFG_DSI_CLK_DIS</td>
<td>RW</td>
<td>0x0</td>
<td>DSI Clock disable <br/>1: DSI clock will be gated  <br/>0: DSI clock is passed to DSI module </td>
</tr>
<tr>
<td>15:9</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>8</td>
<td>CFG_VPN_TX_EN</td>
<td>RW</td>
<td>0x1</td>
<td>Video Panel Interface TX Enable <br/>1: Enable Video Panel TX packet to DPHY. DSI will send video packets to peripherals.  <br/>0: Disable Video Panel interface TX.  </td>
</tr>
<tr>
<td>7:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>CFG_VPN_SLV</td>
<td>RW</td>
<td>0x1</td>
<td>Video Panel Interface in slave mode <br/>1: Video Panel works in slave mode. It receives VSYNC from input LCD interface, and is used to control the internal timing.  <br/>0: Video Panel interface works in master mode. DSI sends VSYNC to LCD module, and controls the V timing and H timing.  <br/>> <strong>Note</strong><strong>.</strong><strong> </strong>This bit must set to 1, VPN only supports slave mode. </td>
</tr>
<tr>
<td>3</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>CFG_CPN_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Command Panel Interface Enable <br/>1: Command panel is running and can accept data from the Command Panel interface <br/>0: Disable Command Panel interface </td>
</tr>
<tr>
<td>1</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>CFG_VPN_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Video Panel Interface Enable <br/>1: Video Panel is active and running.<br/>0: Video Panel interface is disabled.<br/>> <strong>Note. </strong>Set this field to 1 to start the Video Panel timing. </td>
</tr>
</tbody>
</table>

#### DSI_CTRL_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:9</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>8</td>
<td>CFG_EOTP_EN</td>
<td>RW</td>
<td>0x0</td>
<td>EOTP Enable <br/>1: Enable EOTP packet <br/>0: Disable EOTP packet </td>
</tr>
<tr>
<td>7:6</td>
<td>CFG_CPN_VCH_NO</td>
<td>RW</td>
<td>0x3</td>
<td>Command Panel Virtual Channel Number </td>
</tr>
<tr>
<td>5:2</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1:0</td>
<td>CFG_VPN_VCH_NO</td>
<td>RW</td>
<td>0x0</td>
<td>Video Panel Virtual Channel Number for Active Panel 1 <br/>This parameter defines the virtual channel number for VPN </td>
</tr>
</tbody>
</table>

#### DSI_IRQ_ST1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:4</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>IRQ_DPHY_ERR_HS_RXP</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY HSTX contention RXP Error </td>
</tr>
<tr>
<td>2</td>
<td>IRQ_DPHY_ERR_HS_RXN</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY HSTX contention RXN Error </td>
</tr>
<tr>
<td>1</td>
<td>IRQ_DPHY_ERR_HS_CONTP</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY HSTX contention contp Error </td>
</tr>
<tr>
<td>0</td>
<td>IRQ_DPHY_ERR_HS_CONTN</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY HSTX contention contn Error </td>
</tr>
</tbody>
</table>

#### DSI_IRQ_MASK1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xc</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:4</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3:0</td>
<td>CFG_IRQ_MASK1</td>
<td>RW</td>
<td>0x0</td>
<td>DSI interrupt mask <br/>This field is used to mask interrupt requests. <br/>If one bit is set to 0x1, the corresponding interrupt status is masked. </td>
</tr>
</tbody>
</table>

#### DSI_IRQ_ST REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x10</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>IRQ_LAST_LINE</td>
<td>RO</td>
<td>0x0</td>
<td>Last Line interrupt </td>
</tr>
<tr>
<td>30</td>
<td>IRQ_CPN_TE</td>
<td>RO</td>
<td>0x0</td>
<td>Command Panel Tearing Effect.  </td>
</tr>
<tr>
<td>29</td>
<td>IRQ_TA_TIMEOUT</td>
<td>RO</td>
<td>0x0</td>
<td>Turnaround Acknowledgement Timeout for DPHY </td>
</tr>
<tr>
<td>28</td>
<td>IRQ_RX_TIMEOUT</td>
<td>RO</td>
<td>0x0</td>
<td>LP-RX Timeout for DPHY </td>
</tr>
<tr>
<td>27</td>
<td>IRQ_TX_TIMEOUT</td>
<td>RO</td>
<td>0x0</td>
<td>HS TX Timeout for DPHY </td>
</tr>
<tr>
<td>26</td>
<td>IRQ_RX_STATE_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>Peripheral Status Error <br/>After DSI receives an acknowledgement with error report packet from slave, it will mark this bit if an error status is reported. </td>
</tr>
<tr>
<td>25</td>
<td>IRQ_RX_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>DSI RX Packet Error <br/>DSI receives a packet (with error status, such as ecc error/crc error/unknown packet) from slave </td>
</tr>
<tr>
<td>24</td>
<td>IRQ_RX_FIFO_FULL_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>RX FIFO Full Error </td>
</tr>
<tr>
<td>23</td>
<td>IRQ_PHY_FIFO_UNDERRUN</td>
<td>RO</td>
<td>0x0</td>
<td>PHY FIFO Underrun Error </td>
</tr>
<tr>
<td>22</td>
<td>IRQ_REQ_CNT_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>TX Request Count Error <br/>This error occurs when the delays between an Active Panel TX request and the DPHY ready signal are inconsistent.</td>
</tr>
<tr>
<td>21</td>
<td>IRQ_RXPSR_FIFO_FULL_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>RX Parser FIFO Full Error </td>
</tr>
<tr>
<td>20</td>
<td>IRQ_VPN_REQ_PHY_DLY_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>VPN Request Delay Error at PHY Interface <br/>VPN packets are delayed at the PHY interface. </td>
</tr>
<tr>
<td>19</td>
<td>IRQ_VPN_BF_UNDERRUN_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>VPN Buffer Underrun Error </td>
</tr>
<tr>
<td>18</td>
<td>IRQ_VPN_REQ_ARB_DLY_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>VPN Request Delay Error at Arbiter Interface <br/>VPN packets are delayed at arbiter point. </td>
</tr>
<tr>
<td>17</td>
<td>IRQ_VPN_BF_OVERRUN_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>VPN Buffer Overrun Error </td>
</tr>
<tr>
<td>16</td>
<td>IRQ_VPN_TIMING_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>VPN Data Timing Error <br/>This error indicates that pixel data might be incorrect. It occurs when the Data FIFO for the VPN path is read too early or too late, leading to an empty FIFO when it is accessed.</td>
</tr>
<tr>
<td>15</td>
<td>IRQ_VPN_VACT_DONE</td>
<td>RO</td>
<td>0x0</td>
<td>VPN VACT Done </td>
</tr>
<tr>
<td>14</td>
<td>IRQ_VPN_BF_FULL</td>
<td>RO</td>
<td>0x0</td>
<td>VPN Buffer Full Error <br/>Pixel data may be incorrect.  </td>
</tr>
<tr>
<td>13</td>
<td>IRQ_CPN_BF_FULL</td>
<td>RO</td>
<td>0x0</td>
<td>CPN Buffer Full Error <br/>Pixel data may be incorrect.  </td>
</tr>
<tr>
<td>12</td>
<td>IRQ_DPHY_ERR_CONT_LP1</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY LP1 Contention Detect PPI ErrContertionLP1 </td>
</tr>
<tr>
<td>11</td>
<td>IRQ_DPHY_ERR_CONT_LP0</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY LP0 Contention Detect PPI ErrContertionLP0 </td>
</tr>
<tr>
<td>10</td>
<td>IRQ_DPHY_ERR_SYNC_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY Sync Error PPI ErrSyncEsc<br/>Partial byte is detected <br/></td>
</tr>
<tr>
<td>9</td>
<td>IRQ_DPHY_ERR_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY Invalid Command Detect PPI ErrEsc<br/>Invalid ESC command is detected </td>
</tr>
<tr>
<td>8</td>
<td>IRQ_DPHY_RX_LINE_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY Invalid Line State Detect PPI ErrControl </td>
</tr>
<tr>
<td>7</td>
<td>IRQ_RX_TRG3</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY RX Trigger 3 Received <br/>By default, the value of trigger 3 is 0x05, <br/>Note: Its exact meaning is not defined by specification. </td>
</tr>
<tr>
<td>6</td>
<td>IRQ_RX_TRG2</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY RX Trigger 2 Received <br/>By default, trigger 2 is for acknowledgement Trigger, and its value is 0x84. </td>
</tr>
<tr>
<td>5</td>
<td>IRQ_RX_TRG1</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY RX Trigger 1 Received <br/>By default, trigger 1 is for TE Trigger, and its value is 0xBA. </td>
</tr>
<tr>
<td>4</td>
<td>IRQ_RX_TRG0</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY RX Trigger 0 Received <br/>By default, trigger 0 is for Reset Trigger, and its value is 0x46. </td>
</tr>
<tr>
<td>3</td>
<td>IRQ_RX_ULPS</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY RX ULPS Received </td>
</tr>
<tr>
<td>2</td>
<td>IRQ_RX_PKT</td>
<td>RO</td>
<td>0x0</td>
<td>DPHY RX Packet Received </td>
</tr>
<tr>
<td>1</td>
<td>IRQ_CPN_TX_DONE</td>
<td>RO</td>
<td>0x0</td>
<td>Command Panel Data Transmission Done </td>
</tr>
<tr>
<td>0</td>
<td>IRQ_CPU_TX_DONE</td>
<td>RO</td>
<td>0x0</td>
<td>CPU Packet Transmission Done </td>
</tr>
</tbody>
</table>

#### DSI_IRQ_MASK REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x14</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_IRQ_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>DSI interrupt mask <br/>This field is used to mask interrupt requests. <br/>If one bit is set to 0x1, the corresponding interrupt status is masked. </td>
</tr>
</tbody>
</table>

#### DSI_CPU_CMD_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x20</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CFG_CPU_CMD_REQ</td>
<td>RW</td>
<td>0x0</td>
<td>CPU Command Request <br/>1: CPU packet request <br/>0: No request or request done <br/>After software writes a command with this bit set to 1, the DSI module sends out a packet as requested. DSI de-asserts this field after packet is sent. </td>
</tr>
<tr>
<td>30</td>
<td>CFG_CPU_SP</td>
<td>RW</td>
<td>0x0</td>
<td>CPU Short Packet <br/>1: CPU packet is a short packet <br/>0: CPU packet is a long packet </td>
</tr>
<tr>
<td>29</td>
<td>CFG_CPU_TURN</td>
<td>RW</td>
<td>0x0</td>
<td>CPU Turn Around <br/>1: After CPU packet, turn around the bus <br/>0: Don't turn around bus after CPU packet </td>
</tr>
<tr>
<td>28</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27</td>
<td>CFG_CPU_TXLP</td>
<td>RW</td>
<td>0x0</td>
<td>Low Power TX for CPU Packets <br/>1 = Transfer CPU packets in low power mode <br/>0 = Use high-speed mode to send CPU packets </td>
</tr>
<tr>
<td>26:16</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_CPU_WC</td>
<td>RW</td>
<td>0x0</td>
<td>CPU Packet Byte Count <br/>For high-speed transfer, this represents the payload byte count for long packets (excluding CRC bytes).<br/>For high-speed short packet transfer, this field is ignored.<br/>For low power transfer, this is the byte count for the entire packet, including CRC bytes, and CFG_CPU_SP is ignored.</td>
</tr>
</tbody>
</table>

#### DSI_CPU_CMD_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x24</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:20</td>
<td>CFG_TXLP_LPDT</td>
<td>RW</td>
<td>0x0</td>
<td>LPDT TX Enable <br/>LPDT TX enables signals for low power TX </td>
</tr>
<tr>
<td>19:16</td>
<td>CFG_TXLP_ULPS</td>
<td>RW</td>
<td>0x0</td>
<td>ULPS TX Enable <br/>ULPS TX enables signals for Low power TX </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_TXLP_TRIGGER_CODE</td>
<td>RW</td>
<td>0x0</td>
<td>Low Power TX Trigger Code </td>
</tr>
</tbody>
</table>

#### DSI_CPU_CMD_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x2c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CFG_CPU_DAT_REQ</td>
<td>RW</td>
<td>0x0</td>
<td>CPU Packet Data Buffer Read/Write Request <br/>1: CPU packet data request  <br/>0: No request or request done <br/>After software writes a command with this bit set to 1, the DSI module will write data to the packet data buffer or read data from the data buffer as requested. DSI will de-assert this bit after write/read operation is done. Read data will be valid after this bit is reset to 0. </td>
</tr>
<tr>
<td>30</td>
<td>CFG_CPU_DAT_RW</td>
<td>RW</td>
<td>0x0</td>
<td>CPU Packet Data Buffer Read/Write Operation <br/>1: CPU packet data write operation  <br/>0: CPU packet data read operation </td>
</tr>
<tr>
<td>29:24</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:16</td>
<td>CFG_CPU_DAT_ADDR</td>
<td>RW</td>
<td>0x0</td>
<td>CPU Packet Data Address <br/>This is the byte address for the packet data.<br/>- For each read/write operation, 4 bytes of data are written or read. Software should increment the address by 4 after each operation.<br/>- The packet data starts with the packet header:<br/>	1. At address 0:<br/>		- Bits [7:0] represent Type_id<br/>		- Bits [23:8] represent Length<br/>		- Bits [31:24] represent ECC<br/>	2. At address 4: Payload data if it's a long packet, and so on.<br/>- The maximum packet data buffer is 256 bytes.</td>
</tr>
<tr>
<td>15:0</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### DSI_CPU_WDAT REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x30</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_CPU_WDAT</td>
<td>RW</td>
<td>0x0</td>
<td>CPU Data Write Register (wdata 0)<br/>This register defines the data for CPU packets. It holds the CPU packet data that will be written to the packet data buffer.<br/>- Software should first program the packet data into this register, then configure the DSI CPU Packet Command Register 3 to load the packet data into the Tx packet data buffer.<br/>- For each read/write operation, 4 bytes of data are written or read.<br/>	1. Bits [7:0]: LSB<br/>	2. Bits [31:24]: MSB<br/>- For packet data at address 0:<br/>	1. Bits [7:0]: Type_id<br/>	2. Bits [23:8]: Length<br/>	3. Bits [31:24]: ECC<br/>- For data at address 4: The payload data if it's a long packet, and so on.<br/>- High-speed transmission: Hardware automatically generates ECC and CRC codes, replacing them in the packet data buffer.<br/>- Low-power transmission: Hardware does not insert ECC/CRC, and instead sends out the ECC/CRC from the packet data buffer</td>
</tr>
</tbody>
</table>

#### DSI_CPU_STATUS_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x34</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_CPU_PKT_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>CPU Packet Counter <br/>This counter counts the number of CPU packets sent out through DSI. <br/>This register is write clear. </td>
</tr>
</tbody>
</table>

####DSI_CPU_STATUS_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x38</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_CPU_CMD_TX_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>CPU CMD TX Counter <br/>This counter counts the number of byte clock cycles required to transfer the current CPU command. <br/>It begins to count after CPU command is received, and stops to counter after DPHY gets ready for another TX request. <br/>This counter could help to decide the values of DSI_VPN_SLOT_CNT_0 and DSI_VPN_SLOT_CNT_1 register.</td>
</tr>
</tbody>
</table>

#### DSI_CPU_STATUS_2 REGIST

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x3c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_CPU_CMD_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>CPU CMD Execution Counter <br/>This counter counts the number of byte clock cycles required to execute the current CPU command. <br/>This counter only counts the cycles which CPU engine is busy. <br/>This counter could help to decide the values of DSI_VPN_SLOT_CNT_0 and DSI_VPN_SLOT_CNT_1 register.</td>
</tr>
</tbody>
</table>

#### DSI_CPU_STATUS_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x40</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0<br/></td>
<td>CFG_TXLP_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>Low Power TX byte clock count<br/>This counter counts the number of byte clock cycles required to transfer a low power packet. </td>
</tr>
</tbody>
</table>

#### DSI_CPU_STATUS_4 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x44</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_BTA_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>Bus Turn Around byte clock count<br/>This counter counts the number of byte clock cycles required to complete a bus turn around operation. </td>
</tr>
</tbody>
</table>

#### DSI_CPN_STATUS_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0<br/></td>
<td>CFG_CPN_STATUS_1</td>
<td>RW</td>
<td>0x0</td>
<td>Command Panel Path Status 1<br/>It includes the following fields:<br/>- smt_bf_cnt[5:0]<br/>- smt_fifo_bcnt[9:0]<br/>- smt_cs[4:0]<br/>- smt_wr_on<br/>- smt_dma_on<br/>- smt_fifo_empty<br/>- smt_bf_empty<br/>- smt_fifo_full_r<br/>- smt_bf_full_r</td>
</tr>
</tbody>
</table>

#### DSI_CPN_CMD REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x50</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>CFG_CPN_TE_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Command Panel Tearing Effect Signal Enable </td>
</tr>
<tr>
<td>27</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26:24</td>
<td>CFG_CPN_RGB_TYPE</td>
<td>RW</td>
<td>0x0</td>
<td>Command Panel Data RGB Type <br/>0x0: 888 mode <br/>0x1: 666 unpacked mode <br/>0x2: 565 mode <br/>0x3: 444 mode <br/>0x4: 332 mode <br/>0x5: 111 mode </td>
</tr>
<tr>
<td>23:4</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>CFG_CPN_BURST_MODE</td>
<td>RW</td>
<td>0x1</td>
<td>Command Panel Interface Burst Mode Enable  <br/>0: Enable Previous Command Pandel interface.  <br/>1: Burst mode interface between LCD and DSI will take effect. <br/>This interface provides a more efficient connection than the previous mode</td>
</tr>
<tr>
<td>2</td>
<td>CFG_CPN_FIRSTP_SEL</td>
<td>RW</td>
<td>0x0</td>
<td>Command panel First packet select  <br/>0: FIFO empty <br/>1: vsync from DP650 </td>
</tr>
<tr>
<td>1</td>
<td>CFG_CPN_DMA_DIS</td>
<td>RW</td>
<td>0x0</td>
<td>Command Panel dma_on Disable <br/>1: Disable smt_dma_on signal from LCD controller. DSI will not receive Command Panel interface data from LCD even smt_dma_on signal is active high. <br/>0 = Receive LCD Command Panel interface data when smt_dma_on is high. </td>
</tr>
<tr>
<td>0</td>
<td>CFG_CPN_ADDR0_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Command Panel Address Bit Indicator<br/>0 : When smt_addr = 1, bus data is for pixel RGB data. <br/>When smt_addr = 0, bus data is ignored.<br/>1 : When smt_addr = 0, bus data is for pixel RGB data. <br/>When smt_addr = 1, bus data is ignored. </td>
</tr>
</tbody>
</table>

#### DSI_CPN_CTRL_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x54</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:22</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21:16</td>
<td>CFG_DCS_LONGWR_CODE</td>
<td>RW</td>
<td>0x39</td>
<td>DSI Command Code for Writing Command Panel Data <br/>The default data is 0x39 from DSI specification. </td>
</tr>
<tr>
<td>15:8</td>
<td>CFG_DCS_WR_CON_CODE</td>
<td>RW</td>
<td>0x3C</td>
<td>DCS Command for Continuous Write<br/>The default value is 0x3C in MIPI Alliance Standard for Display Command Set Specification. </td>
</tr>
<tr>
<td>7:0</td>
<td>CFG_DCS_WR_STR_CODE</td>
<td>RW</td>
<td>0x2C</td>
<td>DCS Command for First Write <br/>The default value is 0x2C in the MIPI Alliance Standard for Display Command Set Specification. </td>
</tr>
</tbody>
</table>

#### DSI_CPN_CTRL_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x58</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:26</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>25:16</td>
<td>CFG_CPN_PKT_CNT</td>
<td>RW</td>
<td>0x100</td>
<td>Command Panel Packet Length <br/>This field defines the packet length for Command Panel packets. </td>
</tr>
<tr>
<td>15:10</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>9:0</td>
<td>CFG_CPN_FIFO_FULL_LEVEL</td>
<td>RW</td>
<td>0x200</td>
<td> Command Panel FIFO Full Level, in byte count </td>
</tr>
</tbody>
</table>

#### DSI_CPN_STATUS_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x5c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_CPN_FRM_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>Command Panel Frame Counter <br/>This counter counts the numbers of Command Panel frames sent  through DSI. <br/>This register is write clear. </td>
</tr>
</tbody>
</table>

#### DSI_RX_PKT_ST_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x60</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>RX_PKT0_ST_VLD</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 Status Valid <br/>1: Valid status <br/>0: Invalid status </td>
</tr>
<tr>
<td>30:27</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>RX_PKT0_ST_EOTP</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 is EOTP <br/>1: Received packet is EOTP packet <br/>0: Other packet. It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>25</td>
<td>RX_PKT0_ST_ACK</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 is ACK Packet <br/>1: Received packet is an ACK packet, with or without errors.<br/>0 :Other packet. It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>24</td>
<td>RX_PKT0_ST_SP</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 Short Packet <br/>1: Received packet is a short packet.<br/>0: Long packet, it is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>23:22</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21:16</td>
<td>RX_PKT0_PKT_PTR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 Data Pointer <br/>Packet header in FIFO is the raw data from DPHY and is before ECC correction. <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>15:14</td>
<td>RX_PKT0_VCH</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 Virtual Channel Number <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>13:12</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:8</td>
<td>RX_PKT0_ECC_FLAGS</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 ECC Error Flags <br/>Bit [11]:<br/>1: No ECC error <br/>0: ECC error  <br/>Bit [10]: <br/>1: Correctable error in data bits. <br/>Bit [9]: <br/>1: Correctable error happens at parity bits.  <br/>Bit [8]: <br/>1: Incorrectable error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>7:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>RX_PKT0_NO_CRC</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 Without CRC <br/>Rx packet does not include CRC, and CRC part contains 0x0000. <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>3</td>
<td>RX_PKT0_UNKNOWN_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 Type Unknown Error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>2</td>
<td>RX_PKT0_ST_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 ack Status Error <br/>Indicates an error in the acknowledge packet status.<br/>The DSI_RX_PKT_HDR_0 should be checked to identify the specific error. <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>1</td>
<td>RX_PKT0_ECC_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 0 ECC Error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>0</td>
<td>RX_PKT0_CRC_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet CRC Error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
</tbody>
</table>

#### DSI_RX_PKT_HDR_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x64</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>RX_PKT0_HDR</td>
<td>RW</td>
<td>0x0</td>
<td>Rx Packet 0 Header <br/>Bits [7:0]: DataID <br/>Bits [23:8]: Length <br/>Bits [31:23]: ECC--Corrected if an error is detected</td>
</tr>
</tbody>
</table>

#### DSI_RX_PKT_ST_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x68</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31<br/></td>
<td>RX_PKT1_ST_VLD</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 Status Valid <br/>1: Valid status <br/>0: Invalid status </td>
</tr>
<tr>
<td>30:27</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>RX_PKT1_ST_EOTP</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 is EOTP <br/>1: Received packet is EOTP packet.<br/>0: Other packet. It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>25</td>
<td>RX_PKT1_ST_ACK</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 is ACK Packet <br/>1 = Received packet is an ACK packet, with or without error. <br/>0 = Other packet. It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>24</td>
<td>RX_PKT1_ST_SP</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 Short Packet <br/>1: Received packet is a short packet.<br/>0: Long packet valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>23:22</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21:16</td>
<td>RX_PKT1_PKT_PTR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 Data Pointer <br/>Packet header in FIFO is the raw data from DPHY before ECC correction. <br/>Valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>15:14</td>
<td>RX_PKT1_VCH</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 Virtual Channel Number <br/>Valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>13:12</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:8</td>
<td>RX_PKT1_ECC_FLAGS</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 ECC Error Flags <br/>Bit [11]: <br/>1: No ECC error <br/>0: ECC error  <br/>Bit [10]: <br/>1: Correctable error in data bits  <br/>Bit [9]: <br/>1: Correctable error happens at parity bits  <br/>Bit [8]: <br/>1: Incorrectable error. It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>7:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>RX_PKT1_NO_CRC</td>
<td>RWC</td>
<td>0x0</td>
<td> Rx Packet 1 Without CRC <br/>Rx packet does not include CRC, and CRC part contains 0x0000. <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>3</td>
<td>RX_PKT1_UNKNOWN_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet Type Unknown Error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>2</td>
<td>RX_PKT1_ST_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 ack Status Error <br/>DSI_RX_PKT_HDR_0 should be checked to identify the specific error. <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>1</td>
<td>RX_PKT1_ECC_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 ECC Error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>0</td>
<td>RX_PKT1_CRC_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 1 CRC Error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
</tbody>
</table>

#### DSI_RX_PKT_HDR_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x6c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>RX_PKT1_HDR</td>
<td>RW</td>
<td>0x0</td>
<td>Rx Packet 1 Header <br/>Bits [7:0]: DataID <br/>Bits [23:8]: Length <br/>Bits [31:23]: ECC--Corrected if an error is detected</td>
</tr>
</tbody>
</table>

#### DSI_RX_PKT_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x70</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>RX_PKT_RD_REQ</td>
<td>RW</td>
<td>0x0</td>
<td>Rx Packet FIFO Read Request <br/>1 = Read request <br/>0 = Invalid request <br/>This bit will be cleared to 0 after read operation is done, and Rx data is valid. </td>
</tr>
<tr>
<td>30:22</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21:16</td>
<td>RX_PKT_RD_PTR</td>
<td>RW</td>
<td>0x0</td>
<td>Rx Packet Data FIFO Read Pointer <br/>For every read operation, the hardware returns data from the current pointer address. Software must increment this pointer for the next data after each byte is read. </td>
</tr>
<tr>
<td>15:8</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7:0</td>
<td>RX_PKT_RD_DATA</td>
<td>RW</td>
<td>0x0</td>
<td>Rx FIFO Read Data Valid when RX_PKT_RD_REQ = 0. <br/>- First byte: DataID <br/>- Second byte: wc0 <br/>- Third byte: wc1 <br/>- Fourth byte: raw ECC received from DPHY, not corrected <br/>- Fifth byte and beyond: long packet data </td>
</tr>
</tbody>
</table>

#### DSI_RX_PKT_CTRL_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x74</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:12</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:8</td>
<td>RX_PKT_CNT</td>
<td>RWC</td>
<td>0x0</td>
<td>RX Packet Count in Rx FIFO All LP <br/>RX packets are stored in the FIFO and start from address 0. </td>
</tr>
<tr>
<td>7:0</td>
<td>RX_PKT_BCNT</td>
<td>RWC</td>
<td>0x0</td>
<td>RX Byte Count in Rx FIFO <br/>The whole LP RX data is stored in the FIFO and starts from address 0. </td>
</tr>
</tbody>
</table>

#### DSI_RX_PKT_ST_2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x78</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>RX_PKT2_ST_VLD</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 Status Valid <br/>1: Valid status <br/>0: Invalid status </td>
</tr>
<tr>
<td>30:27</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>RX_PKT2_ST_EOTP</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 is EOTP <br/>1: Received packet is EOTP packet<br/>0: Other packet. It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>25</td>
<td>RX_PKT2_ST_ACK</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 is an ACK Packet <br/>1: Received packet is an ACK packet, with or without error<br/>0: Other packet. It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>24</td>
<td>RX_PKT2_ST_SP</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 Short Packet <br/>1: Received packet is a short packet <br/>0: Long packet Valid only when RX_PKT0_ST_VLD = 1</td>
</tr>
<tr>
<td>23:22</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21:16</td>
<td>RX_PKT2_PKT_PTR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 Data Pointer <br/>The packet header in FIFO is the raw data from DPHY before ECC correction. <br/>Valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>15:14</td>
<td>RX_PKT2_VCH</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 Virtual Channel Number <br/>Valid only when RX_PKT0_ST_VLD = 1</td>
</tr>
<tr>
<td>13:12</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:8</td>
<td>RX_PKT2_ECC_FLAGS</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 ECC Error Flags <br/>bit [11]:  <br/>1: No ECC error <br/>0: ECC error  <br/>Bit [10]: <br/>1: Correctable error in data bits  <br/>Bit [9]: <br/>1: Correctable error happens at parity bits  <br/>Bit [8]: <br/>1: Incorrectable error. It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>7:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>RX_PKT2_NO_CRC</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 Without CRC <br/>Rx packet does not include CRC and CRC part contains 0x0000. <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>3</td>
<td>RX_PKT2_UNKNOWN_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 Type Unknown Error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>2</td>
<td>RX_PKT2_ST_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 ack Status Error <br/>DSI_RX_PKT_HDR_0 should be checked to identify the specific error. <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>1</td>
<td>RX_PKT2_ECC_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 ECC Error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
<tr>
<td>0</td>
<td>RX_PKT2_CRC_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>Rx Packet 2 CRC Error <br/>It is valid only when RX_PKT0_ST_VLD = 1. </td>
</tr>
</tbody>
</table>

#### DSI_RX_PKT_HDR_2REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x7c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>RX_PKT2_HDR</td>
<td>RW</td>
<td>0x0</td>
<td> Rx Packet 2 Header </td>
</tr>
</tbody>
</table>

#### DSI_LCD_BDG_CTRL0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x84</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>CFG_VPN_FIFO_AFULL_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>DSI VPN FIFO Almost Full Count  <br/>The difference between the FIFO read pointer and write pointer must be greater than this value.</td>
</tr>
<tr>
<td>15:10</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>9</td>
<td>CFG_HSYNC_MISSING_FIX</td>
<td>RW</td>
<td>0x0</td>
<td>Fix for the Hsync missing bug </td>
</tr>
<tr>
<td>8</td>
<td>CFG_TXLP_LANE_TURN_FIX</td>
<td>RW</td>
<td>0x0</td>
<td>Fix for the TXLP lane turn bug <br/></td>
</tr>
<tr>
<td>7</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6</td>
<td>CFG_VPN_FIFO_AFULL_BYPASS</td>
<td>RW</td>
<td>0x0</td>
<td>Bypass VPN FIFO almost full <br/>0: Not bypass <br/>1: Bypass (LCD outputs pixel data to VPN FIFO regardless of the almost full signal)</td>
</tr>
<tr>
<td>5</td>
<td>CFG_CPN_VSYNC_EDGE</td>
<td>RW</td>
<td>0x0</td>
<td>CPN Vsync signal edge select <br/>0: posedge (Positive edge) select <br/>1: negedge (Negative edge) select </td>
</tr>
<tr>
<td>4</td>
<td>CFG_CPN_TE_EDGE</td>
<td>RW</td>
<td>0x0</td>
<td>CPN tearing effect signal edge select <br/>0: posedge (Positive edge) select <br/>1: negedge (Negative edge) select </td>
</tr>
<tr>
<td>3:2</td>
<td>CFG_CPN_TE_MODE</td>
<td>RW</td>
<td>0x0</td>
<td>CPN tearing effect mode select <br/>0: No Tearing Effect<br/>1: Mode A – Tearing effect signal consists of V-Blanking only<br/>2: Mode B – Tearing effect signal consists of both V-Blanking and H-Blanking<br/>3: Mode C – Tearing effect signal outputs the N H-Blanking</td>
</tr>
<tr>
<td>1</td>
<td>CFG_PIXEL_SWAP</td>
<td>RW</td>
<td>0x0</td>
<td>LCD output pixel swap <br/>0: Do not swap LCD output pixel data <br/>1: Swap LCD output pixel data </td>
</tr>
<tr>
<td>0</td>
<td>CFG_SPLIT_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Split Mode enable<br/>This bit should be set as same as LCD split mode <br/>0: Split mode disable, only DSIA is used for display  <br/>1: Split mode enable, both DSIA and DSIB are used for display </td>
</tr>
</tbody>
</table>

#### DSI_LCD_BDG_CTRL1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x88</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_CPN_TE_DLY_CNT</td>
<td>RW</td>
<td>0x10</td>
<td>CPN Tearing Effect Delay Count<br/>The LCD output pixel data will be delayed by the number of cycles specified in this field after the TE pulse.</td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_CPN_TE_LINE_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>CPN Tearing Effect line Count<br/>When TE_MODE = 2, this field takes effect. <br/>The LCD output pixel data will be delayed for a number of TE pulses specified by this field.</td>
</tr>
</tbody>
</table>

#### DSI_TX_TIMER REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xe4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_TX_TIMER_CNT</td>
<td>RW</td>
<td>0xffffffff</td>
<td>Tx Transmission Timer Value <br/>This timer monitors the Tx operation on the DSI output side. <br/>It could generate IRQ after timer timeout. <br/>By default setting, timeout will not occur because the reset value is set to the maximum value (0xffffffff). </td>
</tr>
</tbody>
</table>

#### DSI_RX_TIMER REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xe8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_RX_TIMER_CNT</td>
<td>RW</td>
<td>0xffffffff</td>
<td>Rx Timer Value <br/>This timer monitors the Rx operation on the DSI operation. <br/>It could generate IRQ after timer timeout. <br/>By default setting, timeout will not occur because the reset value is set to the maximum value (0xffffffff). </td>
</tr>
</tbody>
</table>

#### DSI_TURN_TIMER REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xec</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_TURN_TIMER_CNT</td>
<td>RW</td>
<td>0xffffffff</td>
<td>Bus Turn Around Timer Value <br/>This timer monitors the turn around operation on the DSI. <br/>It could generate IRQ after timer timeout. <br/>By default setting, timeout will not occur because the reset value is set to the maximum value (0xffffffff). </td>
</tr>
</tbody>
</table>

#### DSI_VPN_CTRL_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x100</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_DLY_CNT</td>
<td>RW</td>
<td>0x100</td>
<td>VPN Vsync Delay Count in slave mode.   <br/>In slave mode, the DSI begins H/V timing based on the input Vsync from the LCD module. After receiving the Vsync from the LCD controller, the DSI will start the Vsync timing by delaying it for the number of clock cycles specified by this field.</td>
</tr>
<tr>
<td>15:8</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7:0<br/></td>
<td>CFG_VPN_TX_DLY_CNT</td>
<td>RW</td>
<td>0x10</td>
<td>VPN TX Delay Count <br/>After the DSI starts Hsync timing, this field defines the delay in DPHY byte clock cycles before initiating a VSS packet transfer. This internal delay ensures a fixed TX timing at the DPHY interface.</td>
</tr>
</tbody>
</table>

#### DSI_VPN_CTRL_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x104</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CFG_VPN_VSYNC_RST_EN</td>
<td>RW</td>
<td>0x0</td>
<td>LCD Vsync Reset Enable in slave mode <br/>1: Reset DSI vertical state machine when LCD Vsync comes. This will only take effect when LCD is in slave mode. <br/>0: Do not reset the DSI vertical state machine </td>
</tr>
<tr>
<td>30:28</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27</td>
<td>CFG_VPN_AUTO_WC_DIS</td>
<td>RW</td>
<td>0x0</td>
<td>VPN Auto Word Count Disable <br/>This bit has lower priority than CFG_VPN_HACT_WC_EN <br/>0x0: Enable auto word count calculation, and hardware automatically calculates the number of bytes that will be sent in each H line slot <br/>0x1: Auto word count calculation will not be effective </td>
</tr>
<tr>
<td>26</td>
<td>CFG_VPN_HACT_WC_EN</td>
<td>RW</td>
<td>0x0</td>
<td>VPN Hact Word Count Enable <br/>This bit has higher priority than CFG_VPN_AUTO_WC_EN <br/>0x0: CFG_HACT_WC will not be effective if CFG_VPN_AUTO_WC_DIS is set to 0 <br/>0x1: Enable Hact word count parameter, and CFG_HACT_WC will be used to decide the number of bytes that are sent </td>
</tr>
<tr>
<td>25</td>
<td>CFG_VPN_TIMING_CHECK_DIS</td>
<td>RW</td>
<td>0x0</td>
<td>VPN Hss/Hse/Hact TX Timing Check Disable<br/>0x0: Check timing before requesting DPHY for TX <br/>0x1: No check timing before requesting DPHY for TX </td>
</tr>
<tr>
<td>24</td>
<td>CFG_VPN_AUTO_DLY_DIS</td>
<td>RW</td>
<td>0x0</td>
<td>VPN Auto Vsync Delay Count Disable <br/>0x0: Enable automatic Vsync delay count calculation, and hardware will automatically use half of CFG_HTOTAL_CNT to replace CFG_VPN_DLY_CNT for Vsync delay.<br/>0x1: Disables the auto Vsync delay count. The hardware will use the value in CFG_VPN_DLY_CNT for Vsync delay.</td>
</tr>
<tr>
<td>23</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>22</td>
<td>CFG_VPN_HLP_PKT_EN<br/></td>
<td>RW</td>
<td>0x0</td>
<td>Long Blanking Packet Enable <br/>1: DSI sends out a long blanking packet during the HLP time slot.<br/>0: Long blanking packet is disabled. DSI will enter low power during this time slot (In most cases, this field should be programmed to 0x0) </td>
</tr>
<tr>
<td>21</td>
<td>CFG_VPN_HEX_PKT_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Extra Long Blanking Packet Enable <br/>1: DSI sends out a long blanking packet after pixel data transmission and before the hfp.<br/>0: Extra long blanking packet is disabled. DSI enter low power during this time slot (In most cases, this field should be programmed to 0x0)</td>
</tr>
<tr>
<td>20</td>
<td>CFG_VPN_HFP_PKT_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Front Porch Packet Enable <br/>1: DSI sends out a long blanking packet during the hfp time slot <br/>0: hfp long blanking packet is disabled<br/>DSI will go to low power during this time slot If front porch period is not long enough for DPHY to go to low power state and come back to HS again timely for next Hss packet, this field should be programmed to 0x1. </td>
</tr>
<tr>
<td>19</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>18</td>
<td>CFG_VPN_HBP_PKT_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Back Porch Packet Enable <br/>1: DSI sends out a long blanking packet during the hbp time slot <br/>0: hbp long blanking packet is disabled. DSI will enter low power during this time slot <br/>If the back porch period is not long enough for DPHY to go to low power state and return to HS mode in time for next pixel data packet, this field should be programmed to 0x1. </td>
</tr>
<tr>
<td>17</td>
<td>CFG_VPN_HSE_PKT_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Hse Packet Enable <br/>1: DSI will send out hse packet during hbp time slot <br/>0: hse packet is disabled<br/>DSI will go to low power during this time slot <br/>> <strong>Note</strong><strong>.</strong><strong> </strong>Enable this bit when transmission mode is in Non-burst mode with sync pulse. </td>
</tr>
<tr>
<td>16</td>
<td>CFG_VPN_HSA_PKT_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Hsa Packet Enable <br/>1: DSI sends out hsa long blanking packet during the hbp time slot <br/>0: hsa packet is disabled. DSI will go to low power during this time slot <br/>- If transmission mode is in non-burst mode (with sync event) or burst mode, this field should be disabled. <br/>- If transmission mode is non-burst mode (with sync pulse), this field can be programmed to 0x1.  </td>
</tr>
<tr>
<td>15</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14</td>
<td>CFG_VPN_HEX_SLOT_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Extra Long Packet Enable after Pixel Data <br/>1: Enable extra long packet after pixel data transfer, this will insert a long blanking packet before hfp <br/>0: No extra long packet is inserted after pixel data transfer <br/>This field takes effect only in burst mode. In most cases, this field should be programmed to 0x0. </td>
</tr>
<tr>
<td>13:11</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>10</td>
<td>CFG_VPN_LAST_LINE_TURN</td>
<td>RW</td>
<td>0x0</td>
<td>Turn Around Bus at Last h Line <br/>1: DSI will turn around the bus at the last horizontal line of each frame. This will request the slave to return an acknowledgment or an acknowledgment with an error.<br/>0: DSI will not turn around the bus during the last horizontal line of the frame.<br/>In most cases, this field should be set to 0x0.</td>
</tr>
<tr>
<td>9</td>
<td>CFG_VPN_LPM_FRAME_EN</td>
<td>RW</td>
<td>0x0</td>
<td>Go to Low Power Every Frame <br/>1: DSI will go to low power mode during the last horizontal line of every frame  <br/>0: DSI will not go to low power mode during the last h line <br/>In most cases, this field should be programmed to 0x0. </td>
</tr>
<tr>
<td>8:4</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3:2</td>
<td>CFG_VPN_BURST_MODE</td>
<td>RW</td>
<td>0x0</td>
<td>DSI Transmission Mode for LCD 1 <br/>0x0: Non-burst mode with sync pulse <br/>0x1: Non-burst mode with sync event <br/>0x2: Burst mode </td>
</tr>
<tr>
<td>1:0</td>
<td>CFG_VPN_RGB_TYPE</td>
<td>RW</td>
<td>0x0</td>
<td>LCD 1 Input Data RGB Mode for LCD 1 <br/>0x0: 565 RGB mode <br/>0x1: 666 packet mode <br/>0x2: 666 un-packet mode <br/>0x3: 888 RGB mode </td>
</tr>
</tbody>
</table>

#### DSI_VPN_TIMING_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x110</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_HACT_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>VPN hact Clock Count in byte clock domain<br/>This parameter defines the byte clock cycle numbers for horizontal line pixel data period   <br/>The data byte number for this period is <br/>HACT_BYTE_CNT= HACT_CNT*lane_num </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_HTOTAL_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>VPN htotal Clock Count in byte clock domain. <br/>This parameter defines the byte clock cycle numbers for horizontal line period   <br/>The data byte number for this period is <br/>HTOTAL_BYTE_CNT = HTOTAL_CNT*lane_num </td>
</tr>
</tbody>
</table>

#### DSI_VPN_TIMING_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x114</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16<br/></td>
<td>CFG_VPN_HSYNC_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>VPN hsync Clock Count in byte clock domain. <br/>This parameter defines the byte clock cycle numbers for horizontal line hsync period   <br/>The data byte number for this period is <br/>HSYNC__BYTE_CNT= HSYNC_CNT*lane_num </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_HBP_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>VPN hbp Clock Count in byte clock domain. <br/>This parameter defines the byte clock cycle numbers for horizontal line back porch period   <br/>- The data byte number for this period is <br/>	HBP_BYTE_CNT= HBP_CNT*lane_num   <br/>- Front porch clock count can be calculated by: <br/>	HFP_CNT = HTOTAL_CNT - HSYNC_CNT - HACT_CNT - HBP_CNT   <br/>- The data byte number for front porch period is <br/>	HFP_BYTE_CNT= HFP_CNT*lane_num </td>
</tr>
</tbody>
</table>

#### DSI_VPN_TIMING_2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x118</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_VACT_CNT</td>
<td>RW</td>
<td>0x0</td>
<td> VPN vact Line Count </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_VTOTAL_CNT</td>
<td>RW</td>
<td>0x0</td>
<td> VPN vtotal Line Count </td>
</tr>
</tbody>
</table>

#### DSI_VPN_TIMING_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x11c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_VSYNC_CNT</td>
<td>RW</td>
<td>0x0</td>
<td> VPN vsync Line Count </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_VBP_CNT</td>
<td>RW</td>
<td>0x0</td>
<td> VPN vbp Line Count </td>
</tr>
</tbody>
</table>

#### DSI_VPN_WC_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x120</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_HBP_WC</td>
<td>RW</td>
<td>0x0</td>
<td>VPN hbp packet payload data Byte Count <br/>This parameter must be programmed if HBP_PKT_EN is 0x1, otherwise it can be kept as 0x0  <br/>- If transmission mode is non-burst mode with sync pulse, the formula is:<br/>	HBP_WC=HBP_BYTE_CNT−HSE_BYTE_CNT(4)−HBP_PKT_OVERHEAD(6)<br/>- If transmission mode is non-burst mode with sync event or burst mode, the formula is:<br/>	HBP_WC=HSYNC_BYTE_CNT+HBP_BYTE_CNT−HSS_BYTE_CNT(4)−HBP_PKT_OVERHEAD(6)</td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_HSA_WC</td>
<td>RW</td>
<td>0x0</td>
<td>VPN hsa packet payload data Byte Count <br/>This parameter must be programmed if HSA_PKT_EN is 0x1, otherwise it can be kept as 0x0  <br/>- If transmission mode is non-burst mode with sync pulse, the formula is:<br/>	HSA_WC = HSYNC_BYTE_CNT - HSS_BYTE_CNT(4) - HSA_PKT_OVERHEAD(6)<br/>- Otherwise it is 0x0 </td>
</tr>
</tbody>
</table>

#### DSI_VPN_WC_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x124</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_HFP_WC</td>
<td>RW</td>
<td>0x0</td>
<td>VPN hfp packet payload data Byte Count <br/>This parameter must be programmed if HFP_PKT_EN is 0x1, otherwise it can be kept as 0x0  <br/>- If transmission mode is non-burst mode with sync pulse, or non-burst mode with sync event, the formula is:<br/>	HFP_WC = HFP_BYTE_CNT - HACT_PKT_OVERHEAD(6) - HFP_PKT_OVERHEAD(6)<br/>- If transmission mode is burst mode and HEX_PKT_EN = 1, the formula is:<br/>	HFP_WC = HFP_BYTE_CNT - HACT_PKT_OVERHEAD(6) - HFP_PKT_OVERHEAD(6)<br/>- If transmission mode is burst mode and HEX_PKT_EN = 0, the formula is:<br/>	HFP_WC = HFP_BYTE_CNT + (HACT_BYTE_CNT - HACT_WC) - HACT_PKT_OVERHEAD(6) - HFP_PKT_OVERHEAD(6)</td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_HACT_WC</td>
<td>RW</td>
<td>0x0</td>
<td>VPN hact packet payload data Byte Count   <br/>This parameter is equal to Active pixel RGB data total byte count </td>
</tr>
</tbody>
</table>

#### DSI_VPN_WC_2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x128</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16<br/></td>
<td>CFG_VPN_HEX_WC</td>
<td>RW</td>
<td>0x0</td>
<td>VPN hex packet payload data Byte Count <br/>This parameter must be programmed if HEX_PKT_EN is 0x1, otherwise it can be kept as 0x0  <br/>- If transmission mode is burst mode, the formula is:<br/>	HEX_WC = HACT_BYTE_CNT - HACT_WC - HEX_PKT_OVERHEAD(6)<br/>- Otherwise HEX_WC = 0 </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_HLP_WC</td>
<td>RW</td>
<td>0x0</td>
<td>VPN hlp packet payload data Byte Count <br/>This parameter must be programmed if HLP_PKT_EN is 0x1, otherwise it can be kept as 0x0  <br/>- If transmission mode is non-burst mode with sync pulse, the formula is:<br/>	HLP_WC = HTOTAL_BYTE_CNT - HSYNC_BYTE_CNT - HSE_BYTE_CNT(4) - HLP_PKT_OVERHEAD(6)<br/>- If transmission mode is non-burst mode with sync event or burst mode, the formula is:<br/>	HLP_WC = HTOTAL_BYTE_CNT - HSS_BYTE_CNT(4) - HLP_PKT_OVERHEAD(6) </td>
</tr>
</tbody>
</table>

#### DSI_VPN_SLOT_CNT_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x130</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_SLOT_SP_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>VPN Time Slot Count for Short Packet. <br/>This parameter defines a MIN slot period for short packet transmission, which should ensure DPHY can go to low power, send the short packet, and return to HS again in time for the next active panel packet which has a strict timing requirement.  <br/>If any DSI active panel data flow is working, and CPU or smart interface wants to send short packet between the active panel packets, the internal state machine will try to find a time slot between active panel packets which has a larger period than the defined value. <br/>DSI will only send CPU or Command Panel short packet during such slot to ensure DPHY has enough time to go to low power, send the packet, and return to HS again in time for next active panel packet which has a strict timing requirement. <br/>The programming of this parameter is necessary only when multiple panels or data paths are working simultaneously. </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_SLOT_LP_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>VPN Time Slot Count for Long Packet. <br/>This parameter defines a minimum slot period for long packet transmission, which should ensure DPHY can enter low power mode, send the long packet, and return to HS again in time for the next active panel packet which has a strict timing requirement.  <br/>The programming of this parameter is necessary only when multiple panels or data paths are working simultaneously. </td>
</tr>
</tbody>
</table>

#### DSI_VPN_SLOT_CNT_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x134</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_SLOT_TXLP_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>VPN Time Slot Count for Low Power packet TX. <br/>This parameter defines a minimum slot period for Low Power packet transmission, which should ensure DPHY can enter low power mode, send the Low Power packet, and return to HS again in time for the next active panel packet which has a strict timing requirement.  <br/>The programming of this parameter is necessary only when multiple panels or data paths are working simultaneously. </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_SLOT_TN_CNT</td>
<td>RW</td>
<td>0x0</td>
<td>VPN Time Slot Count for Bus Turn Around. <br/>This parameter defines a minimum slot period for short packet transmission, which should ensure DPHY can enter low power mode, turn around the bus, and return to HS again in time for the next active panel packet which has a strict timing requirement.  </td>
</tr>
</tbody>
</table>

#### DSI_VPN_SYNC_CODE REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x138</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>29:24</td>
<td>CFG_VPN_HSE_CODE</td>
<td>RW</td>
<td>0x31</td>
<td>MIPI DSI Hsync End Code </td>
</tr>
<tr>
<td>23:22</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21:16</td>
<td>CFG_VPN_HSS_CODE</td>
<td>RW</td>
<td>0x21</td>
<td>MIPI DSI Hsync Start Code </td>
</tr>
<tr>
<td>15:14</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>13:8</td>
<td>CFG_VPN_VSE_CODE</td>
<td>RW</td>
<td>0x11</td>
<td>MIPI DSI Vsync End Code </td>
</tr>
<tr>
<td>7:6</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:0</td>
<td>CFG_VPN_VSS_CODE</td>
<td>RW</td>
<td>0x01</td>
<td>MIPI DSI Vsync Start Code </td>
</tr>
</tbody>
</table>

#### DSI_VPN_STATUS_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x140</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CFG_VPN_RD_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>VPN input buffer read error<br/>It includes <br/>- CFG_VPN_RD_2EARLY <br/>- CFG_VPN_LINE_MISS<br/>- CFG_VPN_RD_UNDERRUN</td>
</tr>
<tr>
<td>30</td>
<td>CFG_VPN_LINE_MISS</td>
<td>RO</td>
<td>0x0</td>
<td>VPN input buffer line miss<br/>This indicates a whole H line pixel data is missed. </td>
</tr>
<tr>
<td>29</td>
<td>CFG_VPN_RD_2EARLY</td>
<td>RO</td>
<td>0x0</td>
<td>VPN input buffer read too early </td>
</tr>
<tr>
<td>28</td>
<td>CFG_VPN_RD_UNDERRUN</td>
<td>RO</td>
<td>0x0</td>
<td>VPN input buffer underrun  </td>
</tr>
<tr>
<td>27</td>
<td>CFG_VPN_BF_FULL</td>
<td>RO</td>
<td>0x0</td>
<td>VPN input buffer full  </td>
</tr>
<tr>
<td>26</td>
<td>CFG_VPN_RD_DELAY_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>VPN Request Delay Error at arbiter </td>
</tr>
<tr>
<td>25:21</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>20:0</td>
<td>CFG_VPN_STATUS_0</td>
<td>RO</td>
<td>0x811</td>
<td>DSI VPN Status Register for debug purpose<br/>It includes the following fields:<br/>- l1_lcd 4:0_cs<br/>- l1_vst 6:0<br/>- l1_hst 8:0</td>
</tr>
</tbody>
</table>

#### DSI_VPN_STATUS_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x144</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_WRDONE_RDDONE_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>VPN Input Buffer Write Done to input buffer Read Done Clock Count <br/>This could help to tune the vsync delay count.  </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_WR2RD_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>VPN Input Buffer Write to input buffer Read Clock Count. <br/>This could help to tune the vsync delay count.  </td>
</tr>
</tbody>
</table>

#### DSI_VPN_STATUS_2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x148</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_UNDERRUN_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>VPN input buffer underrun count </td>
</tr>
<tr>
<td>15:0<br/></td>
<td>CFG_VPN_RD_DATWR_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>VPN input buffer read to data write count </td>
</tr>
</tbody>
</table>

#### DSI_VPN_STATUS_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x14c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_VPN_REQ_ARB_DLY_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>VPN tx request delay count at arbiter interface </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_VPN_REQ_PHY_DLY_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>VPN tx request delay count at dphy interface </td>
</tr>
</tbody>
</table>

#### DSI_VPN_STATUS_4 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x150</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CFG_VPN_FRM_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>DSI VPN TX frame count </td>
</tr>
</tbody>
</table>

#### DSI_PHY_CTRL_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x180</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CFG_RX_TRG_REG_DIS</td>
<td>RW</td>
<td>0x0</td>
<td>Disable Register for low power rx trigger signals. <br/>Note: Internal use only</td>
</tr>
<tr>
<td>30</td>
<td>CFG_TX_LANE_0</td>
<td>RW</td>
<td>0x0</td>
<td>New packet tx start from lane <br/>0: If two packets are transferred continuously, all data is packed and distributed to all enabled lanes. The second packet could start from any lane.<br/>1: Transmission of every new packet starts from lane 0. If two packets are transferred continuously, and the first packet doesn't occupy all lanes, then extra byte of 0 will be inserted in at the end of first packet to ensure the second packet start from lane 0 <br/>This is an debug option and should be set to 0  </td>
</tr>
<tr>
<td>29:28</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27</td>
<td>CFG_FCLK_NOT</td>
<td>RW</td>
<td>0x0</td>
<td>Reverse Input Byte Clock from DPHY to DSI Control Logic<br/>The output data to DPHY should be valid at the falling edge of the byte clock. </td>
</tr>
<tr>
<td>26:24</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:16</td>
<td>CFG_STOP_ST_CNT</td>
<td>RW</td>
<td>0x10</td>
<td>DPHY stops state count<br/>Defines the stop state count for TXLP and PHY control</td>
</tr>
<tr>
<td>15:8</td>
<td>CFG_RX_DLY_CNT</td>
<td>RW</td>
<td>0x30</td>
<td>DPHY rx_delay count<br/>Defines the delay state count for RX control </td>
</tr>
<tr>
<td>7:0</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### DSI_PHY_CTRL_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x184</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:18</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17</td>
<td>CFG_VDD_ANA_VALID</td>
<td>RW</td>
<td>0x1</td>
<td>DPHY Analog VDD Valid </td>
</tr>
<tr>
<td>16</td>
<td>CFG_VDD_DVM_VALID</td>
<td>RW</td>
<td>0x1</td>
<td>DPHY Digital VDD Valid </td>
</tr>
<tr>
<td>15:3</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>CFG_ULPS_REQ_BYTE</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY All Lane Force to ULPS </td>
</tr>
<tr>
<td>1</td>
<td>CFG_TX_ULPS_CLK_ESC</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY clk Lane Force to ULPS </td>
</tr>
<tr>
<td>0</td>
<td>CFG_CONT_CLK_HS</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY Clock Lane Continuous Clocking in HS </td>
</tr>
</tbody>
</table>

#### DSI_PHY_CTRL_2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x188</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:15</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14</td>
<td>CFG_CSR_HSTX_RX_EN</td>
<td>RW</td>
<td>0x0</td>
<td>RX enable when DPHY HSTX  <br/>0x0: Disable  <br/>0x1: Enable </td>
</tr>
<tr>
<td>13:12</td>
<td>CFG_CSR_LANE_MAP</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY Data map to lane order  <br/>0x0: Lane0, Lane1, Lane2, Lane3   <br/>0x1: Lane0, Lane3, Lane1, lane2   <br/>0x2: Lane0, Lane2, Lane3, Lane1  <br/>0x3: Reserved</td>
</tr>
<tr>
<td>11:8</td>
<td>CFG_CSR_LANE_RESC_EN</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY LP Receiver Enable <br/>Enable the reverse escape LP receiver. <br/>Lane immediately transmits to receive mode. </td>
</tr>
<tr>
<td>7:4</td>
<td>CFG_CSR_LANE_EN</td>
<td>RW</td>
<td>0x0</td>
<td> DPHY Data Lane Enable </td>
</tr>
<tr>
<td>3:0</td>
<td>CFG_CSR_LANE_TURN</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY Bus Turn Around <br/>This field indicates that the protocol desires to turn the lane around, allowing the other side to begin transmitting. </td>
</tr>
</tbody>
</table>

#### DSI_PHY_CTRL_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x18c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:10</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>9</td>
<td>CFG_FORCECLK_HIZ_HS</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY clk Lane Force to High-Z in HS Mode </td>
</tr>
<tr>
<td>8</td>
<td>CFG_FORCECLK_HIZ_LP</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY clk Lane Force to High-Z in LP mode </td>
</tr>
<tr>
<td>7:4</td>
<td>CFG_FORCE_HIZ_HS</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY Force Data Lane to High-Z in HS Mode </td>
</tr>
<tr>
<td>3:0</td>
<td>CFG_FORCE_HIZ_LP</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY Data Lane Force to High-Z in LP Mode </td>
</tr>
</tbody>
</table>

#### DSI_PHY_STATUS_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x190</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>DPHY_RDY_HS_BYTE</td>
<td>RWC</td>
<td>0x0</td>
<td>DPHY HS TX ready signals </td>
</tr>
<tr>
<td>27:24</td>
<td>TX_REQ_HS_BYTE</td>
<td>RWC</td>
<td>0x0</td>
<td>DPHY HS TX request signals </td>
</tr>
<tr>
<td>23:20</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>19:16</td>
<td>DPHY_LANE_RX_LINE_ERR</td>
<td>RWC</td>
<td>0x0</td>
<td>PPI ErrControl Illegal line state detected </td>
</tr>
<tr>
<td>15:12</td>
<td>DPHY_ERR_SYNC_ESC</td>
<td>RWC</td>
<td>0x0</td>
<td>PPI ErrSyncEsc Partial byte detected </td>
</tr>
<tr>
<td>11:8</td>
<td>DPHY_ERR_ESC</td>
<td>RWC</td>
<td>0x0</td>
<td>PPI ErrEsc Invalid esc command detected </td>
</tr>
<tr>
<td>7:4</td>
<td>DPHY_ERR_CONT_LP0</td>
<td>RWC</td>
<td>0x0</td>
<td>PPI ErrContentionLP0 Contention detect </td>
</tr>
<tr>
<td>3:0</td>
<td>DPHY_ERR_CONT_LP1</td>
<td>RWC</td>
<td>0x0</td>
<td>PPI ErrContentionLP0 Contention detect </td>
</tr>
</tbody>
</table>

#### DSI_PHY_STATUS_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x194</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>DPHY_ULP_STATE_BYTE</td>
<td>RO</td>
<td>0x1</td>
<td>All lanes are in ULP state <br/></td>
</tr>
<tr>
<td>30</td>
<td>DPHY_STOP_STATE_BYTE</td>
<td>RO</td>
<td>0x1</td>
<td>PPI Stopstate - All lanes in stop state </td>
</tr>
<tr>
<td>29</td>
<td>DPHY_CLK_ULPS_ACTIVE_N</td>
<td>RO</td>
<td>0x1</td>
<td>PPI clock UlpsActiveNot </td>
</tr>
<tr>
<td>28</td>
<td>DPHY_RX_CLK_ULPS_N</td>
<td>RO</td>
<td>0x1</td>
<td>PPI RxUlpsClkNot </td>
</tr>
<tr>
<td>27:24</td>
<td>DPHY_LANE_DIR</td>
<td>RO</td>
<td>0x0</td>
<td>PPI Direction </td>
</tr>
<tr>
<td>23:20</td>
<td>DPHY_ULPS_ACTIVE_N</td>
<td>RO</td>
<td>0xf</td>
<td>PPI UlpsActiveNot </td>
</tr>
<tr>
<td>19:16</td>
<td>DPHY_LANE_RX_LINE_ERR</td>
<td>RO</td>
<td>0x0</td>
<td>PPI ErrControl - Illegal line state detected</td>
</tr>
<tr>
<td>15:12</td>
<td>DPHY_ERR_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>PPI ErrEsc - Invalid ESC command detected </td>
</tr>
<tr>
<td>11:8</td>
<td>DPHY_ERR_SYNC_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>PPI ErrSyncEsc - Partial byte detected </td>
</tr>
<tr>
<td>7:4</td>
<td>DPHY_ERR_CONT_LP0</td>
<td>RO</td>
<td>0x0</td>
<td>PPI ErrContentionLP0 - Contention detect </td>
</tr>
<tr>
<td>3:0</td>
<td>DPHY_ERR_CONT_LP1</td>
<td>RO</td>
<td>0x0</td>
<td>PPI ErrContentionLP0 - Contention detect </td>
</tr>
</tbody>
</table>

#### DSI_PHY_LPRX_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x198</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>DPHY_LANE_RX_TRG3</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_rx_trg3 </td>
</tr>
<tr>
<td>27:24</td>
<td>DPHY_LANE_RX_TRG2</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_rx_trg2 </td>
</tr>
<tr>
<td>23:20</td>
<td>DPHY_LANE_RX_TRG1</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_rx_trg1 </td>
</tr>
<tr>
<td>19:16</td>
<td>DPHY_LANE_RX_TRG0</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_rx_trg0 </td>
</tr>
<tr>
<td>15:12</td>
<td>DPHY_LANE_RX_ULPS</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_rx_ulps </td>
</tr>
<tr>
<td>11:8</td>
<td>DPHY_LANE_RX_LPDT</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_rx_lpdt </td>
</tr>
<tr>
<td>7:4</td>
<td>DPHY_LANE_RX_DVALID</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_rx_dvalid </td>
</tr>
<tr>
<td>3:0</td>
<td>DPHY_LANE_RX_CLK</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_rx_clk </td>
</tr>
</tbody>
</table>

#### DSI_PHY_LPRX_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x19c</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>DPHY_LANE_DOUT_RX</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_dout_rx </td>
</tr>
</tbody>
</table>

#### DSI_PHY_LPTX_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1a0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:20</td>
<td>DPHY_TX_TRIGGER_ESC_L</td>
<td>RO</td>
<td>0x0</td>
<td>tx_trigger_esc[11:0] </td>
</tr>
<tr>
<td>19:16</td>
<td>DPHY_TX_ULPS_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>tx_ulps_esc </td>
</tr>
<tr>
<td>15:12</td>
<td>DPHY_TX_LPDT_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>tx_lpdt_esc </td>
</tr>
<tr>
<td>11:8</td>
<td>DPHY_TX_VALID_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>tx_valid_esc </td>
</tr>
<tr>
<td>7:4</td>
<td>DPHY_TX_REQ_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>tx_req_esc </td>
</tr>
<tr>
<td>3:0</td>
<td>DPHY_LANE_RDY_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>dphy_lane_rdy_esc </td>
</tr>
</tbody>
</table>

#### DSI_PHY_LPTX_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1a4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:4</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3:0</td>
<td>DPHY_TX_TRIGGER_ESC_H</td>
<td>RO</td>
<td>0x0</td>
<td>tx_trigger_esc[15:12] </td>
</tr>
</tbody>
</table>

#### DSI_PHY_LPTX_2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1a8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>DPHY_TX_DATA_ESC</td>
<td>RO</td>
<td>0x0</td>
<td>tx_data_esc </td>
</tr>
</tbody>
</table>

#### DSI_PHY_STATUS_2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1ac</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>CFG_TX_REQ_CNT_R</td>
<td>RO</td>
<td>0x0</td>
<td>TX previous request to ready delay count </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_TX_REQ_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>TX request to ready delay count </td>
</tr>
</tbody>
</table>

#### DSI_PHY_TIME_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1c0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>CFG_CSR_TIME_HS_EXIT</td>
<td>RW</td>
<td>0x0</td>
<td>Length of HS Exit Period in tx_clk_esc Cycles <br/>This field is used for the time to drive LP-11 after a HS burst. The HS exit period is calculated as: <br/>HS Exit Period = (1 + CFG_CSR_HS_EXIT) / 66 MHz<br/>By default, the DPHY escape clock frequency is 66 MHz. According to the MIPI specification, the minimum value for this period is 100 ns.</td>
</tr>
<tr>
<td>23:16</td>
<td>CFG_CSR_TIME_HS_TRAIL</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY HS Trail Period Length  <br/>This field is used for the time to drive the flipped differential state after the last payload data bit of a HS transmission burst. The length of the HS trail period is in tx_clk_esc cycles.<br/>HS Trail Time = (1 + CFG_CSR_HS_TRAIL) / 66 MHz<br/>According to the MIPI specification, the minimum value is defined by:<br/>max(8 * UI, 60 ns + 4 * UI)</td>
</tr>
<tr>
<td>15:8</td>
<td>CDG_CSR_TIME_HS_ZERO</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY HS Zero State Length <br/>This field is used for the time to drive HS-0 before the sync sequence. The length of the HS zero state is in tx_clk_esc cycles.<br/>The HS zero state length should be:<br/>HS Zero State Length ≥ (CFG_CSR_TIME_ZERO/ 66 MHz + 3 * Tbyte_clk<br/>According to the MIPI specification, the minimum value for the sum of Time HS Prep and Time HS Zero is 145 ns + 10 * UI.</td>
</tr>
<tr>
<td>7:0</td>
<td>CFG_CSR_TIME_HS_PREP</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY HS Prepare State Length <br/>This field is used for the time to drive LP-00 to prepare for HS transmission.  <br/>It represents the length of the HS prepare state period in tx_clk_esc cycles.<br/>Time HS Prep = (1 + CFG_CSR_TIME_HS_PREP) / 66 MHz<br/>According to the MIPI specification for DPHY <br/>- the minimum value for this parameter is 40 ns + 4 * UI, and <br/>- the maximum value is 85 ns + 6 * UI.</td>
</tr>
</tbody>
</table>

#### DSI_PHY_TIME_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1c4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>CFG_CSR_TIME_TA_GET</td>
<td>RW</td>
<td>0x0</td>
<td>Time to Drive LP-00 by New Transmitter in tx_clk_esc cycles <br/>TA Get Time = (1 + CFG_CSR_TIME_TA_GET)/66 MHz <br/>According to the MIPI specification, the typical value is 5 * Tlpx, where Tlpx is the DPHY LP length:<br/>Tlpx = (1 + CFG_CSR_TIME_LPX) / 66 MHz.</td>
</tr>
<tr>
<td>23:16</td>
<td>CFG_CSR_TIME_TA_GO</td>
<td>RW</td>
<td>0x0</td>
<td>Time to Drive LP-00 after Turn Request in tx_clk_esc Cycles <br/>TA Go Time = (1 + TA_GO)/66 MHz <br/>According to the MIPI specification, the typical value is 4*Tlpx. </td>
</tr>
<tr>
<td>15:0</td>
<td>CFG_CSR_TIME_WAKEUP</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY HS Wakeup Period Length <br/>This field is the recovery time from Ultra-Low Power State (ULPS). <br/>Twakeup = (1 + CFG_CSR_TIME_WAKEUP)/66 MHz <br/>According to the MIPI specification, the minimum value is 1 ms. </td>
</tr>
</tbody>
</table>

#### DSI_PHY_TIME_2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1c8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>CFG_CSR_TIME_CK_EXIT</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY CLK Exit Period Length in tx_clk_esc cycles <br/>Tck_exit = (1 + CFG_CSR_TIME_CK_EXIT)/66 MHz <br/>This field should use the same value as CFG_CSR_TIME_HS_EXIT </td>
</tr>
<tr>
<td>23:16</td>
<td>CFG_CSR_TIME_CK_TRAIL</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY CLK Trail Period Length in tx_clk_esc cycles <br/>This field is the time to drive HS differential state after the last payload clock bit of an HS transmission burst. <br/>CLK Trail Time = (1 + CFG_CSR_TIME_CK_TRAIL)/66 MHz <br/>According to the MIPI specification, the minimum value is 60 ns. </td>
</tr>
<tr>
<td>15:8</td>
<td>CFG_CSR_TIME_CK_ZERO</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY CLK Zero State Length in tx_clk_esc cycles <br/>This field is the time for lead HS-0 drive period before starting the clock. <br/>Tck_zero = (1 + CFG_CSR_TIME_CK_ZERO)/66 MHz <br/>According to the MIPI specification, the minimum value for (Tck_prep+Tck_zero) is 300 ns, where in &lt;var Product Number&gt; Tck_prep is the same as Time HS Prep defined by CFG_CST_TIME_HS_PREP. </td>
</tr>
<tr>
<td>7:0</td>
<td>CFG_CSR_TIME_CK_LPX</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY CLK LP Length <br/>This field is the length of CLK Low Power state period in tx_clk_esc cycles. <br/>CLK Lpx Time = Tck_lpx = (1 + CFG_CSR_TIME_CK_LPX) / 66 MHz <br/>This field should be set to the same value as CFG_CST_TIME_LPX. </td>
</tr>
</tbody>
</table>

#### DSI_PHY_TIME_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1cc</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:8</td>
<td>CFG_CSR_TIME_LPX</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY LP Length <br/>This field is the length of any Low Power state period in tx_clk_esc cycles. <br/>Lpx Time = Tlpx = (1 + CFG_CSR_TIME_LPX) / 66 MHz <br/>According to the MIPI specification, the minimum value is 50 ns. </td>
</tr>
<tr>
<td>7:0</td>
<td>CFG_CSR_TIME_REQRDY</td>
<td>RW</td>
<td>0x0</td>
<td>DPHY HS Request to Ready Length <br/>This field is the minimum byte clock cycles of DSI HS TX request to DPHY ready. <br/>Sometimes it may be important for this length to be consistent to maintain precise Vertical and Horizontal timing. In most cases, this parameter should be kept at the default of 0x0. <br/>Total cycles between DSI HS TX request to DPHY ready are composed by DPHY: clock lane timing, gap, data lane timing, and some other items inside DPHY.<br/>- Clock lane timing = (2*(CFG_CSR_TIME_CK_LPX + 1) + (CFG_CSR_TIME_HS_PREP + 1) + (CFG_CSR_TIME_CK_ZERO + 1))/66 MHz  <br/>- Gap = (16UI +2)/66 MHz <br/>- Data lane timing = ((2*CFG_CSR_TIME_LPX + 1) + (CFG_CSR_TIME_HS_PREP + 1) + (CFG_CSR_TIME_HS_ZERO + 1))/66 MHz  <br/>The formula to calculate the total cycles is:<br/>(1 + CFG_CSR_TIME_REQRDY)/frequecy_byte_clk = (clock lane timing + gap + data lane timing + 10/66 MHz)  <br/>Alternative method to get the value: <br/>- After the DSI active panel data flow is running, read the value from Bits [7:0] of the DSI_PHY_STATUS_2 register. This gives the current clock cycle delay between the DSI TX request and DPHY ready.<br/>- Add 2 to the value obtained from the DSI_PHY_STATUS_2 register<br/>The formula is: <br/>CFG_CSR_TIME_REQRDY=(Value read from DSI_PHY_STATUS_2)+2</td>
</tr>
</tbody>
</table>

#### DSI_PHY_CODE_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1d0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>CFG_TRIG3_CODE</td>
<td>RW</td>
<td>0x05</td>
<td>DPHY Trigger 3 Code </td>
</tr>
<tr>
<td>23:16</td>
<td>CFG_TRIG2_CODE</td>
<td>RW</td>
<td>0x84</td>
<td>DPHY Trigger 2 Code </td>
</tr>
<tr>
<td>15:8</td>
<td>CFG_TRIG1_CODE</td>
<td>RW</td>
<td>0xBA</td>
<td>DPHY Trigger 1 Code </td>
</tr>
<tr>
<td>7:0</td>
<td>CFG_TRIG0_CODE</td>
<td>RW</td>
<td>0x46</td>
<td>DPHY Trigger 0 Code </td>
</tr>
</tbody>
</table>

#### DSI_PHY_CODE_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1d4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>CFG_CSR_ULPS_CODE</td>
<td>RW</td>
<td>0x78</td>
<td>DPHY Ultra Low Power Code </td>
</tr>
<tr>
<td>23:16</td>
<td>CFG_CSR_LPDT_CODE</td>
<td>RW</td>
<td>0x87</td>
<td>DPHY Low Power Data Transfer Code </td>
</tr>
<tr>
<td>15:0</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### DSI_PHY_ANA_PWR_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1e0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:9</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>8</td>
<td>CFG_DPHY_ANA_RESETB</td>
<td>RW</td>
<td>0x1</td>
<td>DPHY Analog reset <br/>0: Reset DPHY analog  <br/>1: De-reset DPHY analog </td>
</tr>
<tr>
<td>7:1</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>CFG_DPHY_ANA_PU</td>
<td>RW</td>
<td>0x1</td>
<td>DPHY Analog power up <br/>0: Power down DPHY analog <br/>1: Power up DPHY analog </td>
</tr>
</tbody>
</table>

#### DSI_PHY_ANA_CTRL0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1e4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:29</td>
<td>CFG_DPHY_LPRX_VTTH</td>
<td>RW</td>
<td>0x2</td>
<td>LPRX reference voltage high   (20mV per stage)<br/>000: 760mV  <br/>001: 780mV<br/>010: 800mV  <br/>111: 900 mV </td>
</tr>
<tr>
<td>28:26</td>
<td>CFG_DPHY_LPRX_VTHL</td>
<td>RW</td>
<td>0x3</td>
<td>LPRX reference voltage low  (20mV per stage)<br/>000: 540mV  <br/>001: 560mV  <br/>010: 580mV  <br/>011: 600mV  <br/>111: 680 mV </td>
</tr>
<tr>
<td>25:24</td>
<td>CFG_DPHY_LPTX_RES</td>
<td>RW</td>
<td>0x2</td>
<td>LPRX driver impedance control  <br/>10: 200 Ohm</td>
</tr>
<tr>
<td>23:21</td>
<td>CFG_DPHY_HSTX_RES</td>
<td>RW</td>
<td>0x4</td>
<td>HSTX driver impedance control.  <br/>000: 120 Ohm (differential @TT)  <br/>100: 100 Ohm  <br/>111:  89  ohm </td>
</tr>
<tr>
<td>20</td>
<td>CFG_DPHY_HSTX_LP</td>
<td>RW</td>
<td>0x0</td>
<td>Low power mode for hstx drivers.  <br/>1 = Lower power  <br/>0 = Normal </td>
</tr>
<tr>
<td>19:17</td>
<td>CFG_DPHY_ADJ_DLY_CK</td>
<td>RW</td>
<td>0x0</td>
<td>Adjust delay of CH_CK hstx driver output to manage skew between channels. The delay is 30ps per stage (@tt) . <br/>000: 0 stage   <br/>111: 7 stages </td>
</tr>
<tr>
<td>16</td>
<td>CFG_DPHY_EN_CH_CK</td>
<td>RW</td>
<td>0x1</td>
<td>Enable for CH_CK.   <br/>When disabled, CH_CK is power down mode, pad_ckp and pad_ckn are in high-z mode <br/>0: Disable <br/>1: Enable </td>
</tr>
<tr>
<td>15:13</td>
<td>CFG_DPHY_ADJ_DLY3</td>
<td>RW</td>
<td>0x0</td>
<td>Adjust delay of CH3 hstx driver output to manage skew between channels. The delay is 30ps per stage (@tt) .<br/>000: 0 stage     <br/>111: 7 stages </td>
</tr>
<tr>
<td>12</td>
<td>CFG_DPHY_EN_CH3</td>
<td>RW</td>
<td>0x1</td>
<td>Enable for CH3.   <br/>When disabled, CH3 is power down mode, pad_dn3 and pad_p3 are in high-z mode <br/>0: Disable <br/>1: Enable </td>
</tr>
<tr>
<td>11:9</td>
<td>CFG_DPHY_ADJ_DLY2</td>
<td>RW</td>
<td>0x0</td>
<td>Adjust delay of CH2 hstx driver output to manage skew between channels. The delay is 30ps per stage (@tt) .<br/>000: 0 stage      <br/>111: 7 stages </td>
</tr>
<tr>
<td>8</td>
<td>CFG_DPHY_EN_CH2</td>
<td>RW</td>
<td>0x1</td>
<td>Enable for CH2. <br/>When disabled, CH2 is power down mode, pad_dn2 and pad_p2 are in high-z mode<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>7:5</td>
<td>CFG_DPHY_ADJ_DLY1</td>
<td>RW</td>
<td>0x0</td>
<td>Adjust delay of CH1 hstx driver output to manage skew between channels. The delay is 30ps per stage (@tt) .<br/>000: 0 stage<br/>111: 7 stages</td>
</tr>
<tr>
<td>4<br/></td>
<td>CFG_DPHY_EN_CH1</td>
<td>RW</td>
<td>0x1</td>
<td>Enable for CH1. <br/>When disabled, CH1 is power down mode, pad_dn1 and pad_p1 are in high-z mode<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>3:1</td>
<td>CFG_DPHY_ADJ_DLY0</td>
<td>RW</td>
<td>0x0</td>
<td>Adjust delay of CH0 hstx driver output to manage skew between channels. The delay is 30ps per stage (@tt) .<br/>000: 0 stage<br/>111: 7 stages</td>
</tr>
<tr>
<td>0</td>
<td>CFG_DPHY_EN_CH0</td>
<td>RW</td>
<td>0x1</td>
<td>Enable for CH0. <br/>When disabled, CH0 is power down mode, pad_dn0 and pad_p0 are in high-z mode<br/>0: Disable<br/>1: Enable</td>
</tr>
</tbody>
</table>

#### DSI_PHY_ANA_CTRL1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1e8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23</td>
<td>CFG_CLK_SEL<br/></td>
<td>RW</td>
<td>0x0</td>
<td>DPHY bit clk select   <br/>0: PLL_DIV output   <br/>1: mipi_bit_clk mux output </td>
</tr>
<tr>
<td>22:21</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>20</td>
<td>CFG_SWAP_PN_CH3</td>
<td>RW</td>
<td>0x0</td>
<td>swap pn polarity for ch3 <br/></td>
</tr>
<tr>
<td>19</td>
<td>CFG_SWAP_PN_CH2</td>
<td>RW</td>
<td>0x0</td>
<td>swap pn polarity for ch2 </td>
</tr>
<tr>
<td>18</td>
<td>CFG_SWAP_PN_CHCK</td>
<td>RW</td>
<td>0x0</td>
<td>swap pn polarity for ch ck </td>
</tr>
<tr>
<td>17</td>
<td>CFG_SWAP_PN_CH1</td>
<td>RW</td>
<td>0x0</td>
<td>swap pn polarity for ch1 </td>
</tr>
<tr>
<td>16</td>
<td>CFG_SWAP_PN_CH0</td>
<td>RW</td>
<td>0x0</td>
<td>swap pn polarity for ch0 </td>
</tr>
<tr>
<td>15</td>
<td>CFG_SET_TEST</td>
<td>RW</td>
<td>0x0</td>
<td>Select analog phy self-test  <br/>1: enable phy self-test. At this mode, phybypass all control signal  0: disable phy self-test. </td>
</tr>
<tr>
<td>14</td>
<td>DFG_SET_TEST_LP</td>
<td>RW</td>
<td>0x0</td>
<td>Select LP or HS self-test mode. It is only valid when sel_test is high. <br/>1: LP mode self test  <br/>0: HS mode self test </td>
</tr>
<tr>
<td>13:12</td>
<td>DFG_TEST_PATTERN</td>
<td>RW</td>
<td>0x0</td>
<td> select self-test pattern generation  <br/>00: All 0  <br/>01: All 1  <br/>10: CK pattern (0101)  <br/>11: PRBS7 </td>
</tr>
<tr>
<td>11</td>
<td>CFG_EN_CLK_DIV2</td>
<td>RW</td>
<td>0x0</td>
<td>enable half rate HSTX mode. <br/>When enabled, PHY will work at half the data rate of PLL input clock.  <br/>1: enable  <br/>0: disable </td>
</tr>
<tr>
<td>10:8</td>
<td>CFG_DPHY_HSTX_VREF</td>
<td>RW</td>
<td>0x3</td>
<td>hstx vreg control  (20mV per stage)<br/>000: 340mV  <br/>001: 360mV  <br/>011: 400mV  <br/>111: 480 mV </td>
</tr>
<tr>
<td>7:5</td>
<td>CFG_DPHY_LPCD_VTHH</td>
<td>RW</td>
<td>0x5</td>
<td>lpcd reference voltage high  (20mV per stage)<br/>000: 300mV  <br/>001: 320mV<br/>101: 400mV  <br/>111: 440 mV </td>
</tr>
<tr>
<td>4:2</td>
<td>CFG_DPHY_LPCD_VTHL</td>
<td>RW</td>
<td>0x2</td>
<td>lpcd reference voltage low  (20mV per stage)<br/>000: 200mV  <br/>001: 220mV <br/>010: 240mV  <br/>111: 340 mV </td>
</tr>
<tr>
<td>1</td>
<td>CFG_DPHY_PULL_DN</td>
<td>RW</td>
<td>0x1</td>
<td>Pull down enable:  <br/>1: Enable pull down PAD IO for ch1,ch2,ch3, check when both HSTX and LPTX are not enabled.  <br/>0: Disable pull down PAD IO for ch1,ch2,ch3, check when both HSTX and LPTX are not enabled. It's high z in this state. </td>
</tr>
<tr>
<td>0</td>
<td>CFG_DPHY_PULL_DN_CH0</td>
<td>RW</td>
<td>0x1</td>
<td>Pull down enable for ch0  <br/>1: Enable pull down PAD IO when all HSTX, LPTX and LPRX are not enabled.  <br/>0: Disable pull down  PAD IO when both HSTX and LPTX are not enabled. It's high z in this state. </td>
</tr>
</tbody>
</table>

#### DSI_PHY_DEBUG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1ec</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>CFG_DDR_CLK_SEL</td>
<td>RW</td>
<td>0x1</td>
<td>DDR Clock Select   <br/>0: First bit is sent on DDR clock falling edge  <br/>1: First bit is sent on DDR clock rising edge </td>
</tr>
</tbody>
</table>

## 13.4 SPI-LCD Display Interface

### Introduction

The SPI LCD Display Interface is used to

- Send image data commands
- Read image data
- Transmit image data

It supports the operational modes

- Single data line mode
- Dual data line mode

where each of which support the work modes

- 3-line/9bit mode
- 4-line/8bit mode

By software, it is possible to configure which line will be the first for transmitting data. Further, it is possible to configure the transfer mode choosing between

- Packet transfer mode
- Unpacked transfer mode

As example, below are depicted the transfers modes for some color formats, highlighting how data are organized and transmitted.

**[Packet transfer mode for RGB565]**

![](static/Packet_transfer_mode_RGB565.png)

**[Packet transfer mode for RGB666]**

![](static/Packet_transfer_mode_RGB666.png)

**[Packet transfer mode for RGB888]**

![](static/Packet_transfer_mode_RGB888.png)

**[Unpacked transfer mode for RGB666]**

![](static/Unpacked_transfer_mode_RGB666.png)

**[Unpacked transfer mode for RGB888]**

![](static/Unpacked_transfer_mode_RGB888.png)

### Features

- Support for SPI LCD module with resolution up to 320x240
- Support for 3-/4-line Serial Peripheral Interface (SPI) and 2-line SPI data transmission
- Support for up to 3 simultaneous overlays (2 for RGB, 1 for YUV & RGB)
- Support for dithering
- Support for gamma curve
- Alpha blending with configurable alpha values or per-pixel alpha blending
- Support for YUV to RGB color space conversion
- Support for image scaling
- Support for color keying
- Support for memory write-back
- Support for the following **input formats** for **image layer**:

  - YUV422 planar
  - YUV422 packet
  - YUV420 planar
  - RGB888
  - RGB565
  - RGB666
  - BGR888
  - BGR565
  - BGR666

  > **Note.** As can be seen, it is supported **R-B swap option** for the sake of flexibility
  >
- Support for the following **input formats** for **OSD layer**:

  - RGB888
  - RGB565
  - RGB666
  - BGR888
  - BGR565
  - BGR666

  > **Note.** As can be seen, it is supported **R-B swap option** for the sake of flexibility
  >

### Block Diagram

The architecture of the SPI LCD Display Interface is depicted below.

![](static/SPI_LCD_Display.png)

It is clearly understandable how the display data are efficiently processed, then converted into SPI-compatible signals, then transmitted to the connected LCD display.

### Functions

#### Blending Function

The blending function of the DSI controller is used to combine multiple layers of images or overlays with different levels of transparency (alpha values).

An example of layers and their respective alpha values is depicted below, where

- **L0**: Bottom layer, base image
- **L1**: Middle layer, alpha value **a1**
- **L2**: Top layer, alpha value **a2**

![](static/layers.png)

The following blending modes are supported:

- Normal Alpha Blending Mode
- Pre-Multiple Alpha Blending Mode
- Special Alpha Blending Mode

In the code, a different formula is implemented for each blending mode that uses the alpha value **a1** as per the following conditions:

```c
if (L1 == color_key)
a1 = 8’h0;
else if (layer_alpha_sel == 1)
a1 = layer_alpha;
else
a1 = pixel_alpha;
```

Details for each blending mode are explained in the following subsections.

##### Normal Alpha Blending Mode

With reference to the example figure shown above,

- For **2 layers**, the formula implemented is

  - $$
    L'=L1×a1+L0×(1-a1)
    $$
- For **3 layers** (<u>not recommended</u>), the formula implemented is

  - $$
    L'=L2×a2+L1×a1×(1-a2)+L0×(1-a1)×(1-a2)
    $$

  > **Note.** Alpha value is not supported for write-back in this case
  >

In the code, the pixel value **L'** depends on the alpha value **a1** as per the following conditions:

```c
if (a1 == 8’hFF)
L' = L1;
else if (a1 == 8’h00)
L' = L0;
else
L' = (L1-L0) × a1/256 + L0
```

##### Pre-Multiple Alpha Blending Mode

With reference to the example figure shown above,

- For **2 layers**, the formula implemented is

  - $$
    L'=L1+L0×(1−a1)
    $$
- For **3 layers** (<u>not recommended</u>), the formula implemented is

  - $$
    L'=L2+L1×(1−a2)+L0×(1−a1)×(1−a2)
    $$

  > **Note.** Alpha value is supported for write-back and its value is given by the formula $a'=a1+a2−a1×a2$
  >

In the code, the pixel value **L'** depends on the alpha value **a1** as per the following conditions:

```c
if (a1 == 8’hFF)
L' = L1;
else if (a1 == 8’h00)
L' = L0;
else
L' = L1-L0 × (1-a1)/256;
```

##### Special Alpha Blending Mode

With reference to the example figure shown above,

- For **2 layers**, the formula implemented is

  - $$
    L'=L1+L0×a1
    $$
- For **3 layers** (<u>not recommended</u>), the formula implemented is

  - $$
    L'=L2+L1×a2+L0×a1×a2
    $$

  > **Note. **Alpha value is not supported for write-back in this case
  >

In the code, the pixel value **L'** depends on the alpha value **a1** as per the following conditions:

```c
if (a1 == 8’hFF)
L' = L0;
else
L' = L1 + L0 × a1/256;
```

#### Dither Function

The process of the Dither function is depicted below.

![](static/UZW5bj8SiobYZwxVFGcc9T92nke.png)

The Dither function can be enabled/disabled by software.

#### Fmark Function

The Fmark function controls the start of displaying output. In particular,

- If Fmark function is **enabled**, displaying output will wait until the Fmark signal is received
- If Fmark function is **disabled**, displaying output will start immediately after initiated by software

By software is possible to enable/disable Fmark function as well as control the polarity of the Fmark signal.

It is recommended to have a register to set how long displaying output is delayed after LCDC received the Fmark signal.

#### Background Color Display Function

When no layer is enabled, a background color can be displayed without fetching data from DDR. The background color can be configured by software.

#### Image Capture Function

To apply the image capture function, the following parameters should be configured by software firstly:

- **startx **= X coordinate of the start point of the capture
- **starty** = Y coordinate of the start point of the capture
- **width** = Width (in pixels) of the capture from (X,Y) start point
- **height** = Height (in pixels) of the capture from (X, Y) start point
- **base_addr** = Memory start address for storing the capture
- **pitch** = Distance (in bytes) between the start of two consecutive rows of pixels stored in the memory, including any padding for alignment or hardware requirements

The process of the image capture function is depicted below.

![](static/capture.png)

### Register Description

> **Note.** Base address = **0xD420A000**

#### SHADOW_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x00C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>SHADOW_FLAG</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: No change<br/>0x1: Update parameters </td>
</tr>
<tr>
<td>30:1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>DIS_SHADOW</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: Shadow swap mode<br/>0x1: Direct swap mode </td>
</tr>
</tbody>
</table>

#### LCD_TVG_START_ADDR0_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x034</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>TV Path Graphic Frame 0 Starting Address</td>
<td>RW</td>
<td>0x0</td>
<td>TV Path Graphic Frame 0 Starting Address in bytes</td>
</tr>
</tbody>
</table>

#### LCD_TVG_PITCH_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x3C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>TV Backlight Duty Cycle Control</td>
<td>RW</td>
<td>0x0</td>
<td>Controls the duty cycle percentage of the TV path backlight clock.<br/>- When the &lt;TV Path Backlight Clock Divider&gt; field (i.e., Bit[27:16]) is not 0x0, the backlight is controlled by the clock. <br/>- This field determines the duty cycle: <br/>	1. This Field/16 of the cycle is high<br/>	2. the rest is low</td>
</tr>
<tr>
<td>27:16</td>
<td>TV Path Backlight Clock Divider</td>
<td>RW</td>
<td>0x0</td>
<td>Configures the clock divider to generate the TV path backlight control clock.<br/>0xFFF: Generates 32 kHz divided by 4096.<br/>0x1: Generates 32 kHz divided by 2.<br/>If both this field and the &lt;TV Backlight Duty Cycle Control&gt; field (i.e., Bit[31:28]) are 0x0000<br/>- The backlight clock function is disabled;<br/>- The backlight is controlled by the &lt;Dumb LCD TV GPIO Control Pin&gt; field in the Dumb LCD TV Control Register.</td>
</tr>
<tr>
<td>15:0</td>
<td>TV Path Graphic Memory Pitch</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the TV Path Graphic Memory Pitch in bytes </td>
</tr>
</tbody>
</table>

#### LCD_TVG_OVSA_HPXL_VLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x040</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>TV Path Graphic DMA Frame Selection Enable</td>
<td>RW</td>
<td>0x0</td>
<td>This field enables selection of a start frame.  </td>
</tr>
<tr>
<td>30:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>TV Path Graphic Destination Starting Vertical Line on Screen</td>
<td>RW</td>
<td>0x0</td>
<td>Field Sum Constraint Formula:<br/>This Field Value+"Graphic Vertical Line Number after Zooming" ≤ "Screen Active Vertical Lines"<br/>Where:<br/>- "Graphic Vertical Line Number after Zooming" is from the Graphic Destination Size (after Zooming) Register.<br/>- "Screen Active Vertical Lines" is the value defined in the Total Screen Active Size Register</td>
</tr>
<tr>
<td>15:13</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>12</td>
<td>TV Path Graphic DMA Frame</td>
<td>RW</td>
<td>0x0</td>
<td>This field is only valid if the &lt;TV Path Graphic DMA Frame Selection Enable&gt;  field (i.e. Bit[31])is enabled. <br/>0x0: Select frame 0<br/>0x1: Select frame 1 </td>
</tr>
<tr>
<td>11:0</td>
<td>TV Path Graphic Destination Starting Horizontal Pixel on Screen</td>
<td>RW</td>
<td>0x0</td>
<td>Field Sum Constraint Formula:<br/>This Field Value+"Graphic Horizontal Pixel Number after Zooming" ≤ "Screen Horizontal Active Pixels"<br/>Where:<br/>- "Graphic Horizontal Pixel Number after Zooming" is from the Graphic Destination Size (after Zooming) Register..<br/>- "Screen Horizontal Active Pixels" is the value defined in the Total Screen Active Size Register.</td>
</tr>
</tbody>
</table>

#### LCD_TVG_HPXL_VLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x044</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>TV Path Graphic Source Vertical Line Number</td>
<td>RW</td>
<td>0x0</td>
<td>This field sets the source vertical size of the graphic object in memory before zooming. </td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:0</td>
<td>TV Path Graphic Source Horizontal Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>This field sets the source horizontal size of the graphic object in memory before zooming. </td>
</tr>
</tbody>
</table>

#### LCD_TVGZM_HPXL_VLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x048</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>TV Path Graphic Destination Vertical Line Number after Zooming</td>
<td>RW</td>
<td>0x0</td>
<td>This field sets the vertical display size. <br/>- Zooming Down: <br/>	If the &lt;Graphic Vertical Line Number&gt; field in the Graphic Source Size Register is greater than this field, the image is scaled down (made smaller).<br/>- Zooming Up: <br/>	If the &lt;Graphic Vertical Line Number&gt; field in the Graphic Source Size Register is less than this field, the image is scaled up (made larger).<br/>- No Zooming: <br/>	If the &lt;Graphic Vertical Line Number&gt; field in the Graphic Source Size Register is equal to this field, no zooming is performed.</td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:0</td>
<td>TV Path Graphic Destination Horizontal Pixel Number after Zooming</td>
<td>RW</td>
<td>0x0</td>
<td>This field sets the horizontal display size. <br/>- Zooming Down: <br/>	If the &lt;Graphic Horizontal Pixel Number&gt; in the Graphic Source Size Register is greater than this field, the image is scaled down (made smaller).<br/>- Zooming Up: <br/>	If the &lt;Graphic Horizontal Pixel Number&gt; in the Graphic Source Size Register is less than this field, the image is scaled up (made larger).<br/>- No Zooming: <br/>	If the &lt;Graphic Horizontal Pixel Number&gt; in the Graphic Source Size Register is equal to this field, no zooming is performed.</td>
</tr>
</tbody>
</table>

#### LCD_TV_COLORKEY_Y_REG REGISTER

> **Note.** Definition of symbols used:
>
> - Y: Luminance value of a pixel in the YUV color model
> - Y1 (\<CFG_TV_CKEY_Y1\>): Lower threshold for color keying
> - Y2 (\<CFG_TV_CKEY_Y2\>): Upper threshold for color keying
> - R: Red component in the RGB color model, used as a replacement if graphic color keying is enabled

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x070</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>TV Path Color Key Y2</td>
<td>RW</td>
<td>0x0<br/></td>
<td>Defines the maximum Y value (Y2) for color keying. If a pixel’s Y component falls within Y1 to Y2, the system: <br/>- Applies an alpha value &lt;CFG_TV_ALPHA_Y&gt; <br/>- Replaces Y with &lt;CFG_TV_CKEY_Y&gt; <br/>- If graphic color keying is enabled, Y is replaced with R</td>
</tr>
<tr>
<td>23:16</td>
<td>TV Path Color Key Y1</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the minimum Y value (Y1) for color keying. If a pixel’s Y component falls within Y1 to Y2, the system: <br/>- Applies an alpha value &lt;CFG_TV_ALPHA_Y&gt; <br/>- Replaces Y with &lt;CFG_TV_CKEY_Y&gt; <br/>- If graphic color keying is enabled, Y is replaced with R</td>
</tr>
<tr>
<td>15:8</td>
<td>TV Path Color Key Y</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the replacement Y value (&lt;CFG_TV_CKEY_Y&gt;) used when the pixel’s Y component is within Y1 to Y2. <br/>If graphic color keying is enabled, Y is replaced with R.</td>
</tr>
<tr>
<td>7:0</td>
<td>TV Path Color Alpha Y</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the alpha transparency level (&lt;CFG_TV_ALPHA_Y&gt;) applied when a pixel’s Y component is within Y1 to Y2. <br/>If graphic color keying is enabled, Y is replaced with R.</td>
</tr>
</tbody>
</table>

#### LCD_TV_COLORKEY_U_REG REGISTER

> **Note.** Definition of symbols used:
>
> - U: Chrominance blue component in the YUV color model
> - U1 (\<TV Path Color Key U1\>): Lower threshold for color keying
> - U2 (\<TV Path Color Key U2\>): Upper threshold for color keying
> - G: Green component in the RGB color model, used as a replacement if graphic color keying is enabled

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x074</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>TV Path Color Key U2</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the maximum U value (U2) for color keying. If a pixel’s U component falls within U1 to U2, the system:<br/>- Applies an alpha value &lt;Color Alpha U&gt; <br/>- Replaces U with &lt;TV Path Color Key U&gt; <br/>- If graphic color keying is enabled, U is replaced with G</td>
</tr>
<tr>
<td>23:16</td>
<td>TV Path Color Key U1</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the minimum U value (U1) for color keying. If a pixel’s U component falls within U1 to U2, the system:<br/>- Applies an alpha value &lt;Color Alpha U&gt; <br/>- Replaces U with &lt;TV Path Color Key U&gt; <br/>- If graphic color keying is enabled, U is replaced with G</td>
</tr>
<tr>
<td>15:8</td>
<td>TV Path Color Key U</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the replacement U value (&lt;TV Path Color Key U&gt;) applied when the pixel’s U component is within U1 to U2. <br/>If graphic color keying is enabled, U is replaced with G.</td>
</tr>
<tr>
<td>7:0</td>
<td>TV Path Color Alpha U</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the alpha transparency level (&lt;Color Alpha U&gt;) used when a pixel’s U component is within U1 to U2. <br/>If graphic color keying is enabled, U is replaced with G.</td>
</tr>
</tbody>
</table>

#### LCD_TV_COLORKEY_V_REG REGISTER

> **Note. **Definition of symbols used:
>
> - V: Chrominance red component in the YUV color model
> - V1 (\<TV Path Color Key V1\>): Lower threshold for color keying
> - V2 (\<TV Path Color Key V2\>): Upper threshold for color keying
> - B: Blue component in the RGB color model, used as a replacement if graphic color keying is enabled

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x078</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>TV Path Color Key V2</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the maximum V value (V2) for color keying. If a pixel’s V component falls within V1 to V2, the system:<br/>- Applies an alpha value &lt;Color Alpha V&gt; <br/>- Replaces V with &lt;TV Path Color Key V&gt; <br/>- If graphic color keying is enabled, V is replaced with B<br/></td>
</tr>
<tr>
<td>23:16</td>
<td>TV Path Color Key V1</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the minimum V value (V1) for color keying. If a pixel’s V component falls within V1 to V2, the system:<br/>- Applies an alpha value &lt;Color Alpha V&gt; <br/>- Replaces V with &lt;TV Path Color Key V&gt; <br/>- If graphic color keying is enabled, V is replaced with B.</td>
</tr>
<tr>
<td>15:8</td>
<td>TV Path Color Key V</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the replacement V value (&lt;TV Path Color Key V&gt;) applied when the pixel’s V component is within V1 to V2. <br/>If graphic color keying is enabled, V is replaced with B.</td>
</tr>
<tr>
<td>7:0</td>
<td>TV Path Color Alpha V</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the alpha transparency level (&lt;Color Alpha V&gt;) used when a pixel’s V component is within V1 to V2. <br/>If graphic color keying is enabled, V is replaced with B.</td>
</tr>
</tbody>
</table>

#### LCD_TV_CTRL0_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x80</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>29</td>
<td>TV Path Video Contrast/Saturation/Brightness/Hue Adjust Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>28</td>
<td>TV Path Palette Color Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled <br/>This field enables the palette color SRAM table when the selected Memory Color Format is palette4bit or palette8bit. <br/>Palette mode can be selected via video or graphic DMA.<br/>> <strong>Note</strong><strong>.</strong> Only one palette table in the TV path. </td>
</tr>
<tr>
<td>27:20</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>19:16</td>
<td>TV Path Graphic DMA Memory Color Format</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the graphic DMA memory color format. Options: <br/>0x0: RGB565; <br/>0x1: RGB1555; <br/>0x2: RGB888; <br/>0x3: RGB888 unpacked; <br/>0x4: RGBA888; <br/>0x5: YUV422packed; <br/>0x9: Palette color 4-bit; <br/>0xA: Palette color 8-bit; <br/>0xB: RGB888A; <br/>Others: Reserved.</td>
</tr>
<tr>
<td>15</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14</td>
<td>TV Path Graphic Horizontal Smooth Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>13</td>
<td>TV Path Graphic DMA Test Mode Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled </td>
</tr>
<tr>
<td>12</td>
<td>TV Path Graphic DMA Swap R and B</td>
<td>RW</td>
<td>0x0</td>
<td>1: Swap enabled<br/>0: Swap disabled<br/>Swaps the red (R) and blue (B) channels in the RGB color model (e.g., RGB → BGR).</td>
</tr>
<tr>
<td>11</td>
<td>TV Path Graphic DMA Swap U and V</td>
<td>RW</td>
<td>0x0</td>
<td>1: Swap enabled<br/>0: Disabled<br/>Swaps the U and V components in YUV color space (e.g., YUYV → YVYU).</td>
</tr>
<tr>
<td>10</td>
<td>TV Path Graphic DMA Swap Y and U/V</td>
<td>RW</td>
<td>0x0</td>
<td>1: Swap enabled<br/>0: Disabled<br/>Swaps the Y component with U/V in YUV color space (e.g., UYVY → YUYV).</td>
</tr>
<tr>
<td>9</td>
<td>TV Path Graphic DMA YUV to RGB Color Space Conversion</td>
<td>RW</td>
<td>0x0</td>
<td>TV Path Graphic DMA YUV to RGB Color Space Conversion, 1 = Enabled; 0 = Disabled. There is only one CSC in the TV path, so either this field or the &lt;TV Path Video DMA YUV to RGB Color Space Conversion&gt; field can be enabled. Both cannot be enabled simultaneously. <br/>1: Enabled <br/>0: Disabled<br/>Converts YUV to RGB color space. <br/>> <strong>Note</strong><strong>.</strong> Either this field or the &lt;TV Path Video DMA YUV to RGB Color Space Conversion&gt; field can be enabled at a time.</td>
</tr>
<tr>
<td>8</td>
<td>TV Path Graphic DMA Transfer Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enable<br/>0: Disabled</td>
</tr>
<tr>
<td>7:0</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use.</td>
</tr>
</tbody>
</table>

#### LCD_TV_CTRL1_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x084</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:27</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26:24</td>
<td>TV Path Color Key Mode</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: Disabled color key function<br/>0x1: Video Y (or Graphic R) color key is enabled<br/>0x2: Video U color key is enabled<br/>0x3: Graphic RGB color key is enabled<br/>0x4: Video V color key is enabled<br/>0x5: Video YUV color key is enabled<br/>0x6: Video Luma key is enabled <br/>0x7: Graphic B color key is enabled</td>
</tr>
<tr>
<td>23</td>
<td>TV Path Configure Low Bits</td>
<td>RW</td>
<td>0x0</td>
<td>1: Low bits are the extension of the maximum bit when converting RGB565/1555/4-bit color into 24-bit RGB color.<br/>0: Fill zeros into low bits when converting RGB565/1555/4-bit color into 24-bit RGB color. </td>
</tr>
<tr>
<td>22</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21</td>
<td>TV Path Graphic DMA Color Key Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled </td>
</tr>
<tr>
<td>20</td>
<td>TV Path Video DMA Color Key Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled </td>
</tr>
<tr>
<td>19</td>
<td>Panel Path Graphic DMA Color Key Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled </td>
</tr>
<tr>
<td>18</td>
<td>Panel Path Video DMA Color Key Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled </td>
</tr>
<tr>
<td>17</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>16</td>
<td>TV Path Configure Video/Graphic Path</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the panel path graphic alpha for overlay.<br/>0x0: Software configuration,<br/>0x1: Pixel-based configuration.</td>
</tr>
<tr>
<td>15:8</td>
<td>TV Path Configure Alpha</td>
<td>RW</td>
<td>0x0</td>
<td>This field specifies the alpha value for blending graphics and video in the TV path when no color key alpha or alpha combined with pixel.<br/>- 0xFF: Selects all video, no graphics.<br/>- Other Values: Proportionally blends video and graphics. </td>
</tr>
<tr>
<td>7</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6</td>
<td>Re-synchronize Panel Path and TV Path Timing</td>
<td>RW</td>
<td>0x0</td>
<td>This field resynchronizes both timing generation modules when Panel path and TV path are using the same clock. <br/>1: Disable both together, no display<br/>0: Enable both at the same time after setting to 1 and back to 0</td>
</tr>
<tr>
<td>5</td>
<td>LCD I/O Pads Panel Signals to TV</td>
<td>RW</td>
<td>0x0</td>
<td>Output on LCD I/O Signals [39:0]:<br/>Panel pad signals connect to TV output.<br/>- Bits [3:2]:<br/>The entire path is swapped, including MIPI DSI1, DSI2, and HDMI.<br/>- Bits [5:4]:<br/>The swap only occurs on 40 digital I/O signals.</td>
</tr>
<tr>
<td>4<br/></td>
<td>LCD I/O Pads TV Signals to Panel</td>
<td>RW</td>
<td>0x0</td>
<td>On the LCD I/O signals [39:0], TV output signals connect to the Panel path. <br/>- Bits [3:2]:<br/>Swaps the entire signal path, including MIPI DSI1, DSI2, and HDMI.<br/>- Bits [5:4]:<br/>Swaps only 40 digital I/O signals.</td>
</tr>
<tr>
<td>3</td>
<td>Panel Path Occupies TV Interface</td>
<td>RW</td>
<td>0x0</td>
<td>By default, the TV interface is reserved for TV path data. However, this field allows Panel path data to use the TV interface when enabled. <br/>1: Enable Panel path pass-through via TV interface.<br/>0: Disabled (default).<br/>> <strong>Note</strong><strong>.</strong> This feature is only used for testing.</td>
</tr>
<tr>
<td>2</td>
<td>TV Path Occupies Digital Panel Interface</td>
<td>RW</td>
<td>0x0</td>
<td>By default, the digital panel interface is reserved for Panel path data. However, enabling this field allows TV path data to occupy the digital panel interface instead.<br/>1: Enable TV path pass-through via the Panel interface.<br/>0: Disabled (default).<br/>> <strong>Note</strong><strong>.</strong> This feature is only used for testing.</td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>0</td>
<td>Enable Interlaced Mode on TV Interface</td>
<td>RW</td>
<td>0x0</td>
<td>Enables interlaced mode on the TV interface.<br/>1: Interlaced mode enabled,<br/>0: Disabled.</td>
</tr>
</tbody>
</table>

#### LCD_TV_CONTRAST_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x088</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>TV Path Video Brightness Control</td>
<td>RW</td>
<td>0x0</td>
<td>Bits [15:8] are used for sign extension. Bits [7:0] are used for integer brightness control. All adjustments are performed before CSC, brightness change range is +/- 0 to 255. These bits are 2's complement code.<br/>- Bits [15:8]: Used for sign extension.<br/>- Bits [7:0]: Define the integer brightness level.<br/>Adjustments are applied before color space conversion (CSC).<br/>Brightness control range: ±0 to 255 (represented in two’s complement format).</td>
</tr>
<tr>
<td>15:0</td>
<td>TV Path Video Contrast Control</td>
<td>RW</td>
<td>0x0</td>
<td>- Bit [15]: Sign bit.<br/>- Bit [14]: Integer part.<br/>- Bits [13:0]: Fractional contrast value.<br/>Contrast control is represented in two’s complement format.<br/>Example contrast settings:<br/>- 0x4000 → Ratio 1.0 (no change)<br/>- 0x6000 → Ratio 1.5 (increase)<br/>- 0x2000 → Ratio 0.5 (decrease)</td>
</tr>
</tbody>
</table>

#### LCD_TV_SATURATION_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x08C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>TV Path Configure Multiplier</td>
<td>RW</td>
<td>0x0</td>
<td>- Bit [15]: Sign bit.<br/>- Bits [14:13]: Integer part.<br/>- Bits [12:0]: Fractional multiplier value.<br/>Values are represented in two’s complement format.</td>
</tr>
<tr>
<td>15:0</td>
<td>TV Path Configure Saturation</td>
<td>RW</td>
<td>0x0</td>
<td>- Bit [15]: Sign bit.<br/>- Bit [14]: Integer part.<br/>- Bits [13:0]: Fractional saturation value.<br/>Values are represented in two’s complement format.</td>
</tr>
</tbody>
</table>

#### LCD_TV_CBSH_HUE_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x090</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>TV Path Video HUE Sine Correction</td>
<td>RW</td>
<td>0x0</td>
<td>Adjusts the HUE of the TV path video using Sine correction.<br/>- Bit [15]: Sign bit.<br/>- Bit [14]: Integer part.<br/>- Bits [13:0]: Fractional sine (delta phase).<br/>Values are represented in two’s complement format.<br/>Formula for Hue Correction:<br/>- Corrected U = U × cos + V × sin<br/>- Corrected V = V × cos - U × sin<br/>Example:<br/>- If CFG_SIN = 0 and CFG_COS = 0x4000, no correction is applied.</td>
</tr>
<tr>
<td>15:0</td>
<td>TV Path Video HUE Cosine Correction</td>
<td>RW</td>
<td>0x0</td>
<td>Adjusts the HUE of the TV path video using Cosine correction.<br/>- Bit [15]: Sign bit.<br/>- Bit [14]: Integer part.<br/>- Bits [13:0]: Fractional cosine (delta phase).<br/>Values are represented in two’s complement format.<br/>Formula for Hue Correction:<br/>- Corrected U = U × cos + V × sin<br/>- Corrected V = V × cos - U × sin<br/>Example:<br/>- If CFG_SIN = 0x2000 and CFG_COS = 0x376D, a 30-degree HUE correction is applied.</td>
</tr>
</tbody>
</table>

#### LCD_DMA_START_ADDR_Y0_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0C0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Panel Path Video Frame 0 Y Starting Address</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Video Frame 0 Y Starting Address in bytes </td>
</tr>
</tbody>
</table>

#### LCD_DMA_START_ADDR_U0_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0C4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Panel Path Video Frame 0 U Starting Address in bytes</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Video Frame 0 U Starting Address in bytes <br/></td>
</tr>
</tbody>
</table>

#### LCD_DMA_START_ADDR_V0_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0C8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Panel Path Video Frame 0 V Starting Address</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Video Frame 0 V Starting Address in bytes </td>
</tr>
</tbody>
</table>

#### LCD_DMA_PITCH_YC_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0E0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:0</td>
<td>Panel Path Video Y Pitch</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Video Y Pitch in bytes </td>
</tr>
</tbody>
</table>

#### LCD_DMA_PITCH_UV_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0E4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Panel Path Video V Pitch</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Video V Pitch in bytes </td>
</tr>
<tr>
<td>15:0</td>
<td>Panel Path Video U Pitch</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Video U Pitch in bytes </td>
</tr>
</tbody>
</table>

#### LCD_DMA_OVSA_HPXL_VLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0E8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Panel Path Video DMA Frame Selection Enable</td>
<td>RW</td>
<td>0x0</td>
<td>This field is used to enable Panel Path video DMA to select either frame0 or frame1. <br/>The frame number is controlled by bits [15:13]. <br/>1: Enable to select; <br/>0: Disable the function </td>
</tr>
<tr>
<td>30:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Path Video Starting Vertical Line on Screen</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the starting vertical line for Panel Path Video on the screen.<br/>Valid Range: 0 to 0xFFF.<br/>The sum of this field and &lt;Video Vertical Line Number after Zooming&gt; (from the <em>Video Destination Size (After Zooming) Register</em>) must not exceed the active display lines set in &lt;Screen Active Vertical Lines&gt; (from the <em>Total Screen Active Size Register</em>).</td>
</tr>
<tr>
<td>15</td>
<td>Panel Path Video Y DMA Frame</td>
<td>RW</td>
<td>0x0</td>
<td>0: frame0 <br/>1: frame1 <br/>> <strong>Note</strong><strong>.</strong> This field is only used if the &lt;Panel Path Video DMA Frame Selection Enable&gt; field is disabled. </td>
</tr>
<tr>
<td>14</td>
<td>Panel Path video U frame</td>
<td>RW</td>
<td>0x0</td>
<td>0: frame0<br/>1: frame1<br/>> <strong>Note</strong><strong>.</strong> This field is only used if the &lt;Panel Path Video DMA Frame Selection Enable&gt; field is enabled. </td>
</tr>
<tr>
<td>13</td>
<td>Panel Path Video V DMA Frame</td>
<td>RW</td>
<td>0x0</td>
<td>0: frame0<br/>1: frame1<br/>> <strong>Note</strong>. This field is only used if the &lt;Panel Path Video DMA Frame Selection Enable&gt; field is enabled. </td>
</tr>
<tr>
<td>12</td>
<td>Panel Path Smart Panel Command DMA Frame</td>
<td>RW</td>
<td>0x0</td>
<td>0: frame0<br/>1: frame1<br/>> <strong>Note</strong><strong>.</strong> This field is only used if the &lt;Panel Path Video DMA Frame Selection Enable&gt; field is enabled. </td>
</tr>
<tr>
<td>11:0</td>
<td>Panel Path Video Starting Horizontal Pixel on Screen</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the starting horizontal pixel position for Panel Path Video on the screen.<br/>Valid Range: 0x0 to 0xFFF <br/>The sum of this field and the &lt;Video Horizontal Pixel Number after Zooming&gt; field (from the Video Destination Size [After Zooming] Register) must not exceed the active display horizontal width defined in the &lt;Screen Horizontal Active Pixels&gt; field (from the Total Screen Active Size Register).</td>
</tr>
</tbody>
</table>

#### LCD_DMA_HPXL_VLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0EC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Path Video Vertical Line Number</td>
<td>RW</td>
<td>0x0</td>
<td>This field is used for the source vertical size of the video object in memory before zooming. </td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:0</td>
<td>Panel Path Video Horizontal Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>This field is used for the source horizontal size of the video object in memory before zooming. </td>
</tr>
</tbody>
</table>

#### LCD_DMAZM_HPXL_VLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0F0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Path Video Vertical Line Destination Number after Zooming</td>
<td>RW</td>
<td>0x0</td>
<td>Sets the vertical display size after zooming.<br/>- Zoom Down (shrink image): <br/>	If the source vertical lines &gt; this field<br/>- Zoom Up (enlarge image): <br/>	If the source vertical lines &lt; this field<br/>- No Zoom: <br/>	If the source vertical lines = this field<br/>Where the source vertical lines are from the &lt;Video Vertical Line Number&gt; field in the Video Source Size Register</td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:0</td>
<td>Panel Path Video Horizontal Pixel Destination Number after Zooming</td>
<td>RW</td>
<td>0x0</td>
<td>Sets the horizontal display size after zooming.<br/>- Zoom Down (shrink image): <br/>	If the source horizontal pixels &gt; this field<br/>- Zoom Up (enlarge image): <br/>	If the source horizontal pixels &lt; this field<br/>- No Zoom: <br/>	If the source horizontal pixels = this field<br/>Where the source horizontal pixels are from the &lt;Video Horizontal Pixel Number&gt; field in Video Source Size Register</td>
</tr>
</tbody>
</table>

#### LCD_GRA_START_ADDR0_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0F4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Panel Path Graphic Frame 0 Starting Address</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Graphic Frame 0 Starting Address in bytes.</td>
</tr>
</tbody>
</table>

#### LCD_GRA_PITCH_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0FC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Panel Backlight Duty Cycle Control</td>
<td>RW</td>
<td>0x0</td>
<td>When the &lt;Dumb Panel Backlight Clock Divider&gt; field is not 0x0, the Dumb Panel backlight is controlled by clock, and this field controls the clock duty cycle percentage. This field/16 of the cycle is high, others is low. <br/>Controls the duty cycle percentage for the Dumb Panel backlight when the &lt;Dumb Panel Backlight Clock Divider&gt; field is not 0x0.<br/>- The duty cycle is Field/16 of the cycle (high), with the rest low.</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Backlight Clock Divider</td>
<td>RW</td>
<td>0x0</td>
<td>Configures the clock divider to generate the Dumb Panel backlight control clock.<br/>- 0xFFF: Generates 32 kHz divided by 4096.<br/>- 0x1: Generates 32 kHz divided by 2.<br/>If both this field and the &lt;Duty Cycle Control&gt; field&gt; are 0x0000, the backlight clock function is disabled, and the backlight is controlled by the &lt;Dumb LCD Panel GPIO Control Pin&gt; field in the Dumb LCD Panel Control Register.</td>
</tr>
<tr>
<td>15:0</td>
<td>Panel Path Graphic Memory Pitch</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Graphic Memory Pitch in bytes </td>
</tr>
</tbody>
</table>

#### LCD_GRA_OVSA_HPXL_VLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x100</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Panel Path Graphic DMA Select Frame 0 or 1</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>30:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Path Graphic Destination Starting Vertical Line on Screen</td>
<td>RW</td>
<td>0x0</td>
<td>The sum of this field and the &lt;Graphic Vertical Line Number after Zooming&gt; field (from the Graphic Destination Size (after Zooming) Register) must not exceed the Screen Active Vertical Lines field (from the Total Screen Active Size Register).</td>
</tr>
<tr>
<td>15:13</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>12</td>
<td>Panel Path Graphic DMA Frame</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the frame used for DMA transfer. <br/>1: Frame1 <br/>0: Frame0 <br/>Note: This field is only valid if the &lt;Panel Path Graphic DMA Select Frame 0 or 1&gt; field is enabled</td>
</tr>
<tr>
<td>11:0</td>
<td>Panel Path Graphic Destination Starting Horizontal Pixel on Screen</td>
<td>RW</td>
<td>0x0</td>
<td>The sum of this field and the &lt;Graphic Horizontal Pixel Number after Zooming&gt; field (from the Graphic Destination Size (after Zooming) Register) must not exceed the &lt;Screen Horizontal Active Pixels&gt; field (from the Total Screen Active Size Register).</td>
</tr>
</tbody>
</table>

#### LCD_GRA_HPXL_VLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x104</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Path Graphic Source Vertical Line Number</td>
<td>RW</td>
<td>0x0</td>
<td>This field sets the source vertical size of the graphic object in memory before zooming. <br/></td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:0</td>
<td>Panel Path Graphic Source Horizontal Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>This field sets the source horizontal size of the graphic object in memory before zooming. </td>
</tr>
</tbody>
</table>

#### LCD_GRAZM_HPXL_VLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x108</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Path Graphic Destination Vertical Line Number after Zooming</td>
<td>RW</td>
<td>0x0</td>
<td>Sets the vertical display size after zooming.<br/>- Zoom Out (smaller image): <br/>	If "the graphic vertical lines" &gt; this field<br/>- Zoom In (larger image): <br/>	If "the graphic vertical lines" &lt; this field<br/>- No Zoom: <br/>	If "the graphic vertical lines" = this field<br/>Where "the graphic vertical lines" is the &lt;Graphic Vertical Line Number&gt; field from the Graphic Source Size Register</td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:0</td>
<td>Panel Path Graphic Destination Horizontal Pixel Number after Zooming</td>
<td>RW</td>
<td>0x0</td>
<td>Sets the horizontal display size after zooming.<br/>- Zoom Out (smaller image): <br/>	If "the pixel number" &gt; this field<br/>- Zoom In (larger image): <br/>	If "the pixel number" &lt; this field<br/>- No Zoom: <br/>	If "the pixel number" = this field<br/>Where "the pixel number" is the &lt;Graphic Horizontal Pixel Number&gt; field from the Graphic Source Size Register.</td>
</tr>
</tbody>
</table>

#### LCD_PN_V_H_ACTIVE_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x118</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Path Screen Active Vertical Lines</td>
<td>RW</td>
<td>0x0</td>
<td>This field sets the active vertical screen display size for both Dumb Panel and Smart Panel. </td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:0</td>
<td>Panel Path Screen Horizontal Active Pixels</td>
<td>RW</td>
<td>0x0</td>
<td>This field sets the active horizontal screen display width for both Dumb Panel and Smart Panel. </td>
</tr>
</tbody>
</table>

#### LCD_PN_BLANKCOLOR_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x124</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:0</td>
<td>Panel Path Background Color</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the background color displayed when no objects overlay it or when no valid pixels exist within the active area. <br/>- Bits [7:0]: Red component. <br/>- Bits [15:8]: Green component. <br/>- Bits [23:16]: Blue component.</td>
</tr>
</tbody>
</table>

#### LCD_PN_ALPHA_COLOR1_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x128</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:0</td>
<td>Panel Path Hardware Cursor Color 1</td>
<td>RW</td>
<td>0x0</td>
<td>- Bits [7:0]: Red component. <br/>- Bits [15:8]: Green component. <br/>- Bits [23:16]: Blue component.</td>
</tr>
</tbody>
</table>

#### LCD_PN_ALPHA_COLOR2_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x12C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:0</td>
<td>Panel Path Hardware Cursor Color 2</td>
<td>RW</td>
<td>0x0</td>
<td>- Bits [7:0]: Red component. <br/>- Bits [15:8]: Green component. <br/>- Bits [23:16]: Blue component.</td>
</tr>
</tbody>
</table>

#### LCD_PN_COLORKEY_Y_REG REGISTER

> **Note**. Definition of symbols used:
>
> - Y: Luminance value of a pixel in the YUV color model
> - Y1 (\<CFG_PN_CKEY_Y1\>): Lower threshold for color keying
> - Y2 (\<CFG_PN_CKEY_Y2\>): Upper threshold for color keying
> - R: Red component in the RGB color model, used as a replacement if graphic color keying is enabled

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x130</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Panel Path Color Key Y2</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the maximum Y value (Y2) for color keying. If a pixel’s Y component falls within Y1 to Y2, the system:<br/>- Applies an alpha value &lt;CFG_PN_ALPHA_Y&gt; <br/>- Replaces Y with &lt;CFG_PN_CKEY_Y&gt; <br/>- If graphic color keying is enabled, Y is replaced with R</td>
</tr>
<tr>
<td>23:16</td>
<td>Panel Path Color Key Y1</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the minimum Y value (Y1) for color keying. If a pixel’s Y component falls within Y1 to Y2, the system:<br/>- Applies an alpha value &lt;CFG_PN_ALPHA_Y&gt; <br/>- Replaces Y with &lt;CFG_PN_CKEY_Y&gt; <br/>- If graphic color keying is enabled, Y is replaced with R</td>
</tr>
<tr>
<td>15:8</td>
<td>Panel Path Color Key Y</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the replacement Y value (&lt;CFG_PN_CKEY_Y&gt;) used when the pixel’s Y component is within Y1 to Y2.<br/>If graphic color keying is enabled, Y is replaced with R.</td>
</tr>
<tr>
<td>7:0</td>
<td>Panel Path Color Alpha Y</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the alpha transparency level (&lt;CFG_PN_ALPHA_Y&gt;) applied when a pixel’s Y component is within Y1 to Y2.<br/>If graphic color keying is enabled, Y is replaced with R.</td>
</tr>
</tbody>
</table>

#### LCD_PN_COLORKEY_U_REG REGISTER

> **Note.** Definition of symbols used:
>
> - U: Chrominance blue component in the YUV color model
> - U1 (\<Panel Path Color Key U1\>): Lower threshold for color keying
> - U2 (\<Panel Path Color Key U2\>): Upper threshold for color keying
> - G: Green component in the RGB color model, used as a replacement if graphic color keying is enabled

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x134</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Panel Path Color Key U2</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the maximum U value (U2) for color keying. If a pixel’s U component falls within U1 to U2, the system:<br/>- Applies an alpha value &lt;Color Alpha U&gt;<br/>- Replaces U with &lt;Panel Path Color Key U&gt;<br/>- If graphic color keying is enabled, U is replaced with G</td>
</tr>
<tr>
<td>23:16</td>
<td>Panel Path Color Key U1</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the minimum U value (U1) for color keying. If a pixel’s U component falls within U1 to U2, the system:<br/>- Applies an alpha value &lt;Color Alpha U&gt;<br/>- Replaces U with &lt;Panel Path Color Key U&gt;<br/>- If graphic color keying is enabled, U is replaced with G</td>
</tr>
<tr>
<td>15:8</td>
<td>Panel Path Color Key U</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the replacement U value (&lt;Panel Path Color Key U&gt;) applied when the pixel’s U component is within U1 to U2.<br/>If graphic color keying is enabled, U is replaced with G.</td>
</tr>
<tr>
<td>7:0</td>
<td>Panel Path Color Alpha U</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the alpha transparency level (&lt;Color Alpha U&gt;) used when a pixel’s U component is within U1 to U2.<br/>If graphic color keying is enabled, U is replaced with G.</td>
</tr>
</tbody>
</table>

#### LCD_PN_COLORKEY_V_REG REGISTER

> **Note.** Definition of symbols used:
>
> - V: Chrominance red component in the YUV color model
> - V1 (\<Panel Path Color Key V1\>): Lower threshold for color keying
> - V2 (\<Panel Path Color Key V2\>): Upper threshold for color keying
> - B: Blue component in the RGB color model, used as a replacement if graphic color keying is enabled

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x138</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Panel Path Color Key V2</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the maximum V value (V2) for color keying. If a pixel’s V component falls within V1 to V2, the system:<br/>- Applies an alpha value &lt;Color Alpha V&gt;<br/>- Replaces V with &lt;Panel Path Color Key V&gt;<br/>- If graphic color keying is enabled, V is replaced with B</td>
</tr>
<tr>
<td>23:16</td>
<td>Panel Path Color Key V1</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the minimum V value (V1) for color keying. If a pixel’s V component falls within V1 to V2, the system:<br/>- Applies an alpha value &lt;Color Alpha V&gt;<br/>- Replaces V with &lt;Panel Path Color Key V&gt;<br/>- If graphic color keying is enabled, V is replaced with B.</td>
</tr>
<tr>
<td>15:8</td>
<td>Panel Path Color Key V</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the replacement V value (&lt;Panel Path Color Key V&gt;) applied when the pixel’s V component is within V1 to V2.<br/>If graphic color keying is enabled, V is replaced with B.</td>
</tr>
<tr>
<td>7:0</td>
<td>Panel Path Color Alpha V</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the alpha transparency level (&lt;Color Alpha V&gt;) used when a pixel’s V component is within V1 to V2.<br/>If graphic color keying is enabled, V is replaced with B.</td>
</tr>
</tbody>
</table>

#### LCD_PN_SEPXLCNT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x13C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Debug Read Index</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the read port index for the Panel Slave Path Status and Debug Register.<br/>0: Normal function</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Path VSYNC Falling Edge Pixel Position of the Line</td>
<td>RW</td>
<td>0x0</td>
<td>This field is used for the Panel Path horizontal pixel count from the first valid pixel to the VSYNC pulse falling edge point. VSYNC pulse is configured by both line number and pixel number. </td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:0</td>
<td>Panel Path VSYNC Rising Edge Pixel Position of the Line</td>
<td>RW</td>
<td>0x0</td>
<td>This field is used for the Panel Path horizontal pixel count from the first valid pixel to the VSYNC pulse rising edge point. VSYNC pulse is configured by both line number and pixel number. <br/></td>
</tr>
</tbody>
</table>

#### LCD_SPI_RXDATA_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x140</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>SPI Read Data</td>
<td>RO</td>
<td>0x0</td>
<td>SPI Read Data </td>
</tr>
</tbody>
</table>

#### LCD_ISA_RXDATA_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x144</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>16-bit or 8-bit Smart Panel Read Data</td>
<td>RO</td>
<td>0x0</td>
<td>If the &lt;Configure Command Format&gt; field in the Smart Panel 8-bit Bus Control Register is set to 16-bit format: <br/>- Bits [7:0] contain the last read data<br/>- Bits [15:8] contain the second last read data</td>
</tr>
</tbody>
</table>

#### LCD_READ_IOPAD_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x148</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:0</td>
<td>I/O Pad Read Value</td>
<td>RO</td>
<td>0x0</td>
<td>This field contains the read value of the Digital Panel interface I/O pad [27:0]. <br/>This is useful for I/O pad checking and GPIO read data. </td>
</tr>
</tbody>
</table>

#### LCD_DMAVLD_YC_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x14C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Panel Video Path Y Starting Address Update Flag</td>
<td>RO</td>
<td>0x0</td>
<td>0: Update enabled <br/>1: Update disabled</td>
</tr>
<tr>
<td>30</td>
<td>Panel Video Path U Starting Address Update Flag</td>
<td>RO</td>
<td>0x0</td>
<td>0: Update enabled <br/>1: Update disabled</td>
</tr>
<tr>
<td>29</td>
<td>Panel Video Path V Starting Address Update Flag</td>
<td>RO</td>
<td>0x0</td>
<td>0: Update enabled <br/>1: Update disabled</td>
</tr>
<tr>
<td>28</td>
<td>Panel Graphic Path Starting Address Update Flag</td>
<td>RO</td>
<td>0x0</td>
<td>0: Update enabled <br/>1: Update disabled</td>
</tr>
<tr>
<td>27</td>
<td>TV Video Path Y Starting Address Update Flag</td>
<td>RO</td>
<td>0x0</td>
<td>0: Update enabled <br/>1: Update disabled</td>
</tr>
<tr>
<td>26</td>
<td>TV Video Path U Starting Address Update Flag</td>
<td>RO</td>
<td>0x0</td>
<td>0: Update enabled <br/>1: Update disabled</td>
</tr>
<tr>
<td>25</td>
<td>TV Video Path V Starting Address Update Flag</td>
<td>RO</td>
<td>0x0</td>
<td>0: Update enabled <br/>1: Update disabled</td>
</tr>
<tr>
<td>24</td>
<td>TV Graphic Path Starting Address Update Flag</td>
<td>RO</td>
<td>0x0</td>
<td>0: Update enabled <br/>1: Update disabled</td>
</tr>
<tr>
<td>23</td>
<td>Panel Path Smart Panel Command Starting Address Update Flag</td>
<td>RO</td>
<td>0x0</td>
<td>0: Update enabled <br/>1: Update disabled</td>
</tr>
<tr>
<td>22</td>
<td>tvd_sa_cflag</td>
<td>RW</td>
<td>0x0</td>
<td>  </td>
</tr>
<tr>
<td>21:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:0</td>
<td>Panel Path Video Actual Y Line Length in Memory</td>
<td>RO</td>
<td>0x0</td>
<td>Panel video Path Y valid length in bytes, generated from color format and pixel number of each line </td>
</tr>
</tbody>
</table>

#### LCD_DMAVLD_UV_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x150</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:20</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>19:10</td>
<td>Panel Path Video Actual V Line Length in Memory</td>
<td>RO</td>
<td>0x0</td>
<td>Panel video Path U valid length in bytes, generated from color format and pixel number of each line. </td>
</tr>
<tr>
<td>9:0</td>
<td>Panel Path Video Actual U Line Length in Memory</td>
<td>RO</td>
<td>0x0</td>
<td>Panel video Path V valid length in bytes, generated from color format and pixel number of each line. </td>
</tr>
</tbody>
</table>

#### LCD_TVGGRAVLD_HLEN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x154</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>TV Path Graphic Actual Line Length in Memory</td>
<td>RO</td>
<td>0x0</td>
<td>TV graphic Path Y valid length in bytes, generated from color format and pixel number of each line. </td>
</tr>
<tr>
<td>15:0</td>
<td>Panel Path Graphic Actual Line Length in Memory</td>
<td>RO</td>
<td>0x0</td>
<td>Panel graphic Path Y valid length in bytes, generated from color format and pixel number of each line. </td>
</tr>
</tbody>
</table>

#### LCD_PN_GAMMA_RDDAT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x15C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:8</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7:0</td>
<td>Panel Path Gamma Table SRAM Read Data</td>
<td>RO</td>
<td>0x0</td>
<td>Panel Path Gamma Table SRAM Read Data </td>
</tr>
</tbody>
</table>

#### LCD_PN_PALETTE_RDDAT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x160</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:0</td>
<td>Panel Path Palette Table SRAM Read Data</td>
<td>RO</td>
<td>0x0</td>
<td>Panel Path Palette Table SRAM Read Data </td>
</tr>
</tbody>
</table>

#### LCD_SLV_DBG_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x164</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:20</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>19:12</td>
<td>AHB Slave Path FIFO Space Count</td>
<td>RO</td>
<td>0x20</td>
<td>Indicates the available space count (in bytes) in the AHB Slave Path FIFO for the Smart Panel.<br/>This value shows the total bytes of data can be written to the AHB Slave Path Data Port Register. <br/>It’s recommended to check this value before writing to ensure space availability.<br/>The maximum value is 128 bytes.</td>
</tr>
<tr>
<td>11:4</td>
<td>AHB Slave Path FIFO Data Count</td>
<td>RO</td>
<td>0x0</td>
<td>Indicates the data count (in bytes) in the AHB Slave Path FIFO for the Smart Panel. <br/>The sum of this field and the &lt;AHB Slave Path FIFO Space Count&gt; should equal 0x80, which is the FIFO size.</td>
</tr>
<tr>
<td>3:0</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### LCD_TV_GAMMA_RDDAT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x174</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:8</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7:0</td>
<td>TV Path Gamma Table SRAM Read Data</td>
<td>RO</td>
<td>0x0</td>
<td>TV Path Gamma Table SRAM Read Data </td>
</tr>
</tbody>
</table>

#### LCD_TV_PALETTE_RDDAT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x178</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:0</td>
<td>TV Path Palette Table SRAM Read Data</td>
<td>RO</td>
<td>0x0</td>
<td>TV Path Palette Table SRAM Read Data </td>
</tr>
</tbody>
</table>

#### LCD_FRAME_CNT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x17C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:14</td>
<td>Current IRE Frame Number for TV Path</td>
<td>RO</td>
<td>0x0</td>
<td>Current IRE Frame Number for TV Path</td>
</tr>
<tr>
<td>13:12</td>
<td>Current CCIC Frame Number for TV Path</td>
<td>RO</td>
<td>0x0</td>
<td>Current CCIC Frame Number for TV Path </td>
</tr>
<tr>
<td>11:10</td>
<td>Current IRE Frame Number for Panel Path</td>
<td>RO</td>
<td>0x0</td>
<td>Current IRE Frame Number for Panel Path </td>
</tr>
<tr>
<td>9:8</td>
<td>Current CCIC Frame Number for Panel Path</td>
<td>RO</td>
<td>0x0</td>
<td>Current CCIC Frame Number for Panel Path </td>
</tr>
<tr>
<td>7:6</td>
<td>TV Current Graphic Frame Number</td>
<td>RO</td>
<td>0x0</td>
<td>TV Path Current Graphic Frame Number </td>
</tr>
<tr>
<td>5:4</td>
<td>TV Current Video Frame Number</td>
<td>RO</td>
<td>0x0</td>
<td>TV Path Current Video Frame Number </td>
</tr>
<tr>
<td>3:2</td>
<td>Panel Current Graphic Frame Number</td>
<td>RO</td>
<td>0x0</td>
<td>Panel Path Current Graphic Frame Number </td>
</tr>
<tr>
<td>1:0</td>
<td>Panel Current Video Frame Number</td>
<td>RO</td>
<td>0x0</td>
<td>Panel Path Current Video Frame Number </td>
</tr>
</tbody>
</table>

#### LCD_SPI_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x180</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Configure SPI dcx</td>
<td>RW</td>
<td>0x0</td>
<td>Configures the dcx bit for SPI 4-wire mode, either in command or data mode.</td>
</tr>
<tr>
<td>30:24</td>
<td>Configure SPI Clock Divider</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the SPI clock divider with the valid values ranging from 0xFF to 0x02, used to generate the SPI clock from the panel path pixel clock.</td>
</tr>
<tr>
<td>23:16</td>
<td>Configure SPI Receive</td>
<td>RW</td>
<td>0x0</td>
<td>0x1F: Read/receive 32 bits<br/>0x01: Read/receive 2 bits<br/>0x00: Receive disabled<br/>- If the &lt;Configure SPI Transmit&gt; field is set to 0x00, only receive operations are allowed. The maximum length per trigger (write 0x01 to the &lt;Start SPI Transfer&gt; field) is 32 bits, but unlimited read length can be achieved by triggering repeatedly when the &lt;Configure Continuous Transfer&gt; field is set to 0x1.<br/>- If the &lt;Configure SPI Transmit&gt; field is not 0x00, it will first transmit serial bits, then receive serial bits. </td>
</tr>
<tr>
<td>15:8</td>
<td>Configure SPI Transmit</td>
<td>RW</td>
<td>0x0</td>
<td>0x1F = Write/transmit 32 bits<br/>0x01 = Write/transmit 2 bits<br/>0x00 = Do not transfer<br/>- If the &lt;Configure SPI Receive&gt; field is set to 0x00, only transmission occurs. The maximum write length is 32 bits per trigger, but unlimited write length is possible when triggering repeatedly when the &lt;Configure Continuous Transfer&gt; field is set to 0x1. <br/>- If the &lt;Configure SPI Receive&gt; field is not 0x00, it will first transmit serial bits, and then receive incoming bits.    </td>
</tr>
<tr>
<td>7</td>
<td>Configure Clock Inverse</td>
<td>RW</td>
<td>0x0</td>
<td>0: SPI clock rising edge samples the data, falling edge sends out data. <br/>1: SPI clock falling edge samples the data, rising edge sends out data. </td>
</tr>
<tr>
<td>6</td>
<td>Configure continuous Transfer</td>
<td>RW</td>
<td>0x0</td>
<td>When set to 1, the SPI chip select is kept low until this bit is cleared, allowing continuous shifting of bits (in or out).</td>
</tr>
<tr>
<td>5</td>
<td>Configure Receive order</td>
<td>RW</td>
<td>0x0</td>
<td>0: Receive from higher bit to bit 0. <br/>1: Receive from bit 0 to higher bit. </td>
</tr>
<tr>
<td>4</td>
<td>Configure Transmit order</td>
<td>RW</td>
<td>0x0</td>
<td>0: Transfer from higher bit to bit 0. <br/>1: Transfer from bit 0 to higher bit.</td>
</tr>
<tr>
<td>3</td>
<td>Enable SPI</td>
<td>RW</td>
<td>0x0</td>
<td>0: Disabled<br/>1: Enabled</td>
</tr>
<tr>
<td>2</td>
<td>Configure SPI Port</td>
<td>RW</td>
<td>0x0</td>
<td>0: SPI port 0<br/>1: SPI port 1</td>
</tr>
<tr>
<td>1</td>
<td>Configure 3-/4-Wire SPI</td>
<td>RW</td>
<td>0x0</td>
<td>1: 3-wire SPI (SPI_DIN used for both transmit and receive). <br/>0: 4-wire SPI (SPI_DIN for data from the product to the SPI panel, SPI_DOUT for data from the SPI panel to the product).</td>
</tr>
<tr>
<td>0</td>
<td>Start SPI Transfer</td>
<td>RW</td>
<td>0x0</td>
<td>1: Start the transfer (requires the &lt;Enable SPI&gt; field is set to be 1). <br/>0: Transfer not started.</td>
</tr>
</tbody>
</table>

#### LCD_SPI_TXDATA_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x184</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>SPI Transfer Data</td>
<td>RW</td>
<td>0x0</td>
<td>SPI Transfer Data Up to 32 bits are shifted out by each trigger. It is configurable from high to low or low to high and to shift any length. 0 = MSb to LSb; 1 = LSb to MSb. <br/>Defines the data to be shifted out during SPI transfer. <br/>The transfer length is configurable up to 32 bits per trigger. <br/>The shifting direction can be set to either high to low (MSb to LSb) or low to high (LSb to MSb). <br/>0: Shifts from MSb to LSb. <br/>1: Shifts from LSb to MSb.</td>
</tr>
</tbody>
</table>

#### LCD_SMPN_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x188</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Configure ISA Receive Low</td>
<td>RW</td>
<td>0x0</td>
<td>This field programs the bus read active low time. <br/>0xF: 6 clock cycles<br/>0x0: 1 clock cycle.</td>
</tr>
<tr>
<td>27:24</td>
<td>Configure ISA Receive High</td>
<td>RW</td>
<td>0x0</td>
<td>This field programs the bus read hold time. <br/>0xF: 16 clock cycles<br/>0x0: 1 clock cycle</td>
</tr>
<tr>
<td>23:20</td>
<td>Configure ISA Transmit Low</td>
<td>RW</td>
<td>0x0</td>
<td>This field programs the bus write active low time.<br/>0xF: 16 clock cycles<br/>0x0: 1 clock cycle</td>
</tr>
<tr>
<td>19:16</td>
<td>Configure ISA Transmit High</td>
<td>RW</td>
<td>0x0</td>
<td>This field programs the bus read hold time. <br/>0xF: 16 clock cycles<br/>0x0: 1 clock cycle</td>
</tr>
<tr>
<td>15:14</td>
<td>Select Smart Panel VSYNC Trigger</td>
<td>RW</td>
<td>0x0</td>
<td>This field is used when the &lt;Panel Path VSYNC Input Trigger Modes&gt; field (in the Panel Path DMA Control 1 Register) is set to 0x0 or 0x1. <br/>0x0: Parallel bus I/O pad input as Smart panel DMA VSYNC trigger signal. <br/>0x1: MIPI DSI1 as Smart panel DMA VSYNC trigger signal. <br/>0x2: MIPI DSI2 as Smart panel DMA VSYNC trigger signal. <br/>All other values: Reserved</td>
</tr>
<tr>
<td>13</td>
<td>Configure ISA iordy Mask</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: The I/O ready signal is always active high on the Smart Panel parallel bus.<br/>0x1: The Smart Panel parallel bus is held when the I/O ready signal is low. The I/O ready signal goes high when the bus is ready.<br/>- Note: Set this bit to 1 when using the SPI interface to connect to a display device.</td>
</tr>
<tr>
<td>12</td>
<td>Configure Slave Only Mode</td>
<td>RW</td>
<td>0x0</td>
<td>- This field allows the Smart Panel to operate without DMA mode.<br/>- When both the Panel Path (HDMI) and TV Path (MIPI DSI) are enabled, no extra FIFO is available for Smart Panel DMA mode.<br/>- In slave-only mode, up to three panels can be supported simultaneously.<br/>- When set high, the Smart Panel operates in slave mode only.</td>
</tr>
<tr>
<td>11:8</td>
<td>Configure Pixel Format</td>
<td>RW</td>
<td>0x0</td>
<td>When in DMA transfer, this field defines the pixel format. <br/>0x0: RGB888, 3 cycles per pixel; <br/>0x1: RGB666, 3 cycles per pixel; <br/>0x2: RGB565, 2 cycles per pixel; <br/>0x3: RGB888, 1 cycle per pixel; <br/>0x4: RGB666, 1 cycle per pixel; <br/>0x5: RGB565 1 cycle per pixel; <br/>0x6: RGB666_GC, 3 cycles per pixel.</td>
</tr>
<tr>
<td>7</td>
<td>Configure Command Format</td>
<td>RW</td>
<td>0x0</td>
<td>1: 32-bit command format, used for up to 24-bit bus width (I/O pins limited to 18-bit). <br/>0: 16-bit command format, used for 8-bit bus width.</td>
</tr>
<tr>
<td>6</td>
<td>Write Byte Order</td>
<td>RW</td>
<td>0x0</td>
<td>Configures the byte order for writing.<br/>0: Write 8-bit bus from low byte to high byte. <br/>1: Write 8-bit bus from high byte to low byte. <br/>This field is used when writing one pixel across 2 or 3 byte writes.</td>
</tr>
<tr>
<td>5</td>
<td>Smart Panel Parallel Bus Chip Select</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the chip select line for the Smart Panel parallel bus.<br/>0: CSB[0]<br/>1: CSB[1]</td>
</tr>
<tr>
<td>4</td>
<td>AHB Slave Path Enable</td>
<td>RW</td>
<td>0x0</td>
<td>0: Disabled<br/>1: Enabled</td>
</tr>
<tr>
<td>3</td>
<td>Smart Panel Reset</td>
<td>RW</td>
<td>0x0</td>
<td>0: Reset pin is high<br/>1: Reset pin is low</td>
</tr>
<tr>
<td>2</td>
<td>Configure 8086/6800</td>
<td>RW</td>
<td>0x0</td>
<td>0: 8-bit bus read/write conforming to 8086 series<br/>1: 8-bit bus read/write conforming to 6800 series</td>
</tr>
<tr>
<td>1</td>
<td>Configure Transfer</td>
<td>RW</td>
<td>0x0</td>
<td>1: Force chip select to low until this bit is set to 0. <br/>This field is useful when a Smart Panel requires the chip select to remain low during read and write.</td>
</tr>
<tr>
<td>0</td>
<td>Smart Panel Enable<br/></td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/>When both this field and the &lt;AHB Slave Path Enable&gt; field are high, writing a command word to the AHB Slave Path Data Port Register initiates Smart Panel parallel bus cycles. <br/>- If the &lt;Configure Command Format&gt; field = 1 (High):  <br/>	1. Commands are in 16-bit format.  <br/>	2. Two 16-bit commands are packed into a single 32-bit word (e.g., Command 0 in bits 0–15, Command 1 in bits 16–31).<br/>- If the &lt;Configure Command Format&gt; field = 0 (Low):  <br/>	1. Commands are in 32-bit format.  <br/>	2. Only one 32-bit command fits per 32-bit word.</td>
</tr>
</tbody>
</table>

#### LCD_SLV_PORT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x18C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Command 1 A0</td>
<td>WO</td>
<td>0x0</td>
<td>Command 1 A0</td>
</tr>
<tr>
<td>30:26</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>25</td>
<td>Command 1 Read</td>
<td>WO</td>
<td>0x0</td>
<td>Command 1 Read</td>
</tr>
<tr>
<td>24</td>
<td>Command 1 Write</td>
<td>WO</td>
<td>0x0</td>
<td>Command 1 Write</td>
</tr>
<tr>
<td>23:16</td>
<td>Command 1 Data</td>
<td>WO</td>
<td>0x0</td>
<td>- If the &lt;Configure Command Format&gt; field is set to 16-bit format, this field holds the 8-bit command 1 data. <br/>- If the &lt;Configure Command Format&gt; field is set to 32-bit format, bits [23:0] represent Smart Panel data[23:0].</td>
</tr>
<tr>
<td>15</td>
<td>Command 0 A0</td>
<td>WO</td>
<td>0x0</td>
<td>- If the &lt;Configure Command Format&gt; field is set to 16-bit format, this field holds the command 0 A0. <br/>- If the &lt;Configure Command Format&gt; field is set to 32-bit format, bits [23:0] represent Smart Panel data[23:0].</td>
</tr>
<tr>
<td>14:10</td>
<td>32-bit Command Format Data</td>
<td>WO</td>
<td>0x0</td>
<td>- If the &lt;Configure Command Format&gt; field is set to 16-bit format, this field is reserved. <br/>- If the &lt;Configure Command Format&gt; field is set to 32-bit format, bits [23:0] represent Smart Panel data[23:0].</td>
</tr>
<tr>
<td>9</td>
<td>Command 0 Read</td>
<td>WO</td>
<td>0x0</td>
<td>- If the &lt;Configure Command Format&gt; field is set to 16-bit format, this field holds the command 0 read. <br/>- If the &lt;Configure Command Format&gt; field is set to 32-bit format, bits [23:0] represent Smart Panel data[23:0].</td>
</tr>
<tr>
<td>8</td>
<td>Command 0 Write</td>
<td>WO</td>
<td>0x0</td>
<td>- If the &lt;Configure Command Format&gt; field is set to 16-bit format, this field holds the command 0 write. <br/>- If the &lt;Configure Command Format&gt; field is set to 32-bit format, bits [23:0] represent Smart Panel data[23:0].</td>
</tr>
<tr>
<td>7:0</td>
<td>Command 0 Data</td>
<td>WO</td>
<td>0x0</td>
<td>- If the &lt;Configure Command Format&gt; field is set to 16-bit format, this field holds the command 0 data. <br/>- If the &lt;Configure Command Format&gt; field is set to 32-bit format, bits [23:0] represent Smart Panel data[23:0].</td>
</tr>
</tbody>
</table>

#### LCD_PN_CTRL0_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x190</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>30</td>
<td>Panel Path Gamma Correction Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
<tr>
<td>29</td>
<td>Panel Path Video Contrast/Saturation/Brightness/Hue Adjust Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
<tr>
<td>28</td>
<td>Panel Path Palette Color Enable</td>
<td>RW</td>
<td>0x0</td>
<td>This field enables the palette color SRAM table. <br/>1: Enabled<br/>0: Disabled<br/>When the color format selected in the &lt;Video Memory Color Format&gt; field is palette4bit or palette8bit, this field should be 1. Either video or graphic DMA can select palette mode. There is only one palette table in the Panel Path.<br/>- This field must be set to 1 when the color format selected in the &lt;Video Memory Color Format&gt; field is palette4bit or palette8bit.<br/>- Either video or graphic DMA can use palette mode.<br/>- There is only one palette table in the Panel Path, shared between video and graphic DMA.</td>
</tr>
<tr>
<td>27</td>
<td>AXI Bus Arbiter Fast Mode Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: DMA AXI bus arbiter allows multiple burst requests. <br/>0: Arbiter switches after one request is done.<br/>For faster read, enable this bit in normal case.</td>
</tr>
<tr>
<td>26</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>25</td>
<td>Panel Path CS Low Delay Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
<tr>
<td>24</td>
<td>Panel Path Force Blank-Color Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
<tr>
<td>23:20</td>
<td>Panel Path Video Memory Color Format</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: RGB565<br/>0x1: RGB1555<br/>0x2: RGB888 packed<br/>0x3: RGB888 unpacked<br/>0x4: RGBA888<br/>0x5: YUV422 packed<br/>0x6: YUV422 planar<br/>0x7: YUV420 planar<br/>0x8: Smart Panel command<br/>0x9:  Palette color 4-bit per pixel<br/>0xA: Palette color 8-bit per pixel<br/>0xB: RGB888A<br/>All other values: Reserved</td>
</tr>
<tr>
<td>19:16</td>
<td>Panel Path Graphic Memory Color Format</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: RGB565<br/>0x1: RGB1555<br/>0x2: RGB888 packed<br/>0x3: RGB888 unpacked<br/>0x4: RGBA888 <br/>0x5: YUV422 packed<br/>0x6 to 0x8 = Reserved<br/>0x9: Palette color 4-bit per pixel<br/>0xA: Palette color 8-bit per pixel<br/>0xb: RGB888A<br/>All other values: Reserved</td>
</tr>
<tr>
<td>15</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14</td>
<td>Panel Path Graphic Horizontal Smooth Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
<tr>
<td>13</td>
<td>Panel Path Graphic DMA Test Mode Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
<tr>
<td>12</td>
<td>Panel Path graphic DMA Swap R and B</td>
<td>RW</td>
<td>0x0</td>
<td>Swap R and B (e.g., RGB to BGR).<br/>1: Swap enabled<br/>0: Swap disabled</td>
</tr>
<tr>
<td>11</td>
<td>Panel Path Graphic DMA Swap U and V</td>
<td>RW</td>
<td>0x0</td>
<td>Swap U and V (e.g., YUYV to YVYU).<br/>1: Swap enabled<br/>0: Swap disabled</td>
</tr>
<tr>
<td>10</td>
<td>Panel Path Graphic DMA Swap Y and U/V</td>
<td>RW</td>
<td>0x0</td>
<td>Swap Y and U/V (e.g., UYVY to YUYV).<br/>1: Swap enabled<br/>0: Swap disabled</td>
</tr>
<tr>
<td>9</td>
<td>Panel Path Graphic YUV to RGB Color Space Conversion</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled <br/>0: Disabled <br/>Either this or the &lt;Panel Path Video YUV to RGB Color Space Conversion&gt; field can be enabled, but both cannot be enabled simultaneously.</td>
</tr>
<tr>
<td>8</td>
<td>Panel Path Graphic Transfer Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
<tr>
<td>7</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6</td>
<td>Panel Path Video Horizontal Smooth Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
<tr>
<td>5</td>
<td>Panel Path Video Path Test Mode Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
<tr>
<td>4</td>
<td>Panel Path Video DMA Swap R and B</td>
<td>RW</td>
<td>0x0</td>
<td>Swap R and B (e.g., RGB to BGR).<br/>1: Swap enabled<br/>0: Swap disabled</td>
</tr>
<tr>
<td>3</td>
<td>Panel Path Video DMA Swap U and V</td>
<td>RW</td>
<td>0x0</td>
<td>Swap U and V (e.g., YUYV to YVYU).<br/>1: Swap enabled<br/>0: Swap disabled</td>
</tr>
<tr>
<td>2</td>
<td>Panel Path Video DMA Swap Y and U/V</td>
<td>RW</td>
<td>0x0</td>
<td>Swap Y and U/V (e.g., UYVY to YUYV).<br/>1: Swap enabled<br/>0: Swap disabled</td>
</tr>
<tr>
<td>1</td>
<td>Panel Path Video YUV to RGB Color Space Conversion</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled <br/>Either this or the &lt;Panel Path Graphic YUV to RGB Color Space Conversion&gt; field can be enabled, but both cannot be enabled simultaneously.</td>
</tr>
<tr>
<td>0</td>
<td>Panel Path Video and Command Transfer Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled<br/></td>
</tr>
</tbody>
</table>

#### LCD_PN_CTRL1_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x194</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Panel Path DMA Transfer Trigger</td>
<td>RW</td>
<td>0x0</td>
<td>1: DMA transfer is triggered, this is equivalent to VSYNC pulse.<br/>This field is useful when Smart Panel VSYNC input is not available.</td>
</tr>
<tr>
<td>30:28</td>
<td>Panel Path VSYNC Input Trigger Modes</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: Smart Panel VSYNC input triggers DMA start transfer. <br/>0x1: Smart Panel VSYNC input triggers DMA transfer, and generates asynchronous interrupt to processor. <br/>0x7: Write 1 to the &lt;Panel Path DMA Transfer Trigger&gt; field triggers DMA transfer <br/>All other values: Reserved</td>
</tr>
<tr>
<td>27</td>
<td>Panel Path Rising/Falling Edge Triggers DMA Transfer</td>
<td>RW</td>
<td>0x0</td>
<td>0: Rising edge triggers<br/>1: Falling edge</td>
</tr>
<tr>
<td>26:24</td>
<td>Panel Path Color Key Mode</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: Disable color key function<br/>0x1: Video Y (or Graphic R) color key is enabled<br/>0x2: Video U color key is enabled<br/>0x3: Graphic RGB color key is enabled<br/>0x4: Video V color key is enabled<br/>0x5: Video YUV color key  is enabled<br/>0x6: Video Luma key is enabled<br/>0x7: Graphic B color key is enabled</td>
</tr>
<tr>
<td>23</td>
<td>Panel Path Configure Low Bits</td>
<td>RW</td>
<td>0x0</td>
<td>1: Low bits are the extension of the maximum bit when converting RGB565/1555/4-bit color into 24-bit RGB color. <br/>0: Fill zeros into low bits when converting RGB565/1555/4-bit color into 24-bit RGB color.</td>
</tr>
<tr>
<td>22:20</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>19:18</td>
<td>Configure Scaling</td>
<td>RW</td>
<td>0x0</td>
<td>This field controls scaling down when Smart Panel DMA mode is enabled.<br/>- 0x0 – No scaling down<br/>- 0x1 – Scale down by 1/2 (in addition to any zooming applied)<br/>- 0x2 – Scale down by 1/4 (in addition to any zooming applied)<br/>Example:<br/>If the original image is 160 × 120 and the target size is 80 × 60, setting this field to 0x1 will further reduce the final output to 40 × 30.</td>
</tr>
<tr>
<td>17</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>16</td>
<td>Panel Path Alpha Selection</td>
<td>RW</td>
<td>0x0</td>
<td>This field determines how the graphic alpha is selected for the overlaid area in the Panel Path.<br/>- 0x0: Software-configured alpha<br/>- 0x1: Alpha is taken from the pixel data</td>
</tr>
<tr>
<td>15:8</td>
<td>Panel Path Configure Alpha</td>
<td>RW</td>
<td>0x0</td>
<td>This field configures the alpha blending in the Panel Path when neither color key alpha nor pixel-based alpha is used.<br/>- 0xFF – Full video display, no graphics<br/>- Other values – Blends video and graphics proportionally based on the set value</td>
</tr>
<tr>
<td>7:0</td>
<td>Pixel Command</td>
<td>RW</td>
<td>0x0</td>
<td>This field should be set to 0x81. <br/>All other values are reserved.</td>
</tr>
</tbody>
</table>

#### LCD_SRAM_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x198</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:14</td>
<td>SRAM Init Write/Read</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: Read SRAM<br/>0x2: Write SRAM<br/>0x3: Initialize SRAM to default value</td>
</tr>
<tr>
<td>13:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:8</td>
<td>SRAM Address LCD ID</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: Panel ID_gamma_yr<br/>0x1: Panel ID_gamma_ug <br/>0x2: Panel ID_gamma_vb</td>
</tr>
<tr>
<td>7:0</td>
<td>SRAM Address[7:0]</td>
<td>RW</td>
<td>0x0</td>
<td>SRAM Address[7:0]</td>
</tr>
</tbody>
</table>

#### LCD_SRAM_WRDAT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x19C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>SRAM Write Data</td>
<td>RW</td>
<td>0x0</td>
<td>SRAM Write Data. When generating an SRAM write command, this write data will be moved into SRAM.</td>
</tr>
</tbody>
</table>

#### LCD_SCLK_DIV_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1A8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>Panel Path Clock Source Select</td>
<td>RW</td>
<td>0x0</td>
<td>This field selects the pixel clock source<br/>0x0: Select AXI bus clock<br/>0x1: Select LCD Display clock 1<br/>0x2: Select LCD Display clock 2<br/>0x3: Select DSI PLL clock.</td>
</tr>
<tr>
<td>29</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>28</td>
<td>Panel Path Pixel Clock Disable</td>
<td>RW</td>
<td>0x0</td>
<td>0: Clock enabled<br/>1: Clock disabled.</td>
</tr>
<tr>
<td>27:16</td>
<td>Panel Path Pixel Clock Fraction Divider</td>
<td>RW</td>
<td>0x0</td>
<td>This field fine-tunes the pixel clock when the desired clock rate cannot be achieved using only an integer divider.<br/>- Example:<br/>To obtain 80 MHz from 83 MHz, this register should be set to (83-80)/83*4096 = &lt;0x094&gt;<br/>	Three clocks are suppressed and 80 clocks are used, and the duty cycle is not 50%.<br/>> <strong>Notes</strong><strong>.</strong><br/>> - This feature is useful for Smart Panels.<br/>> - It is not recommended for Dumb Panels.<br/>> - For basic clock adjustments, refer to the the &lt;Clock Integer Divider&gt; field.</td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:8</td>
<td>Panel Path MIPI bit Clock Divider</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: Clock disabled<br/>0x1: Clock bypass (no division)<br/>0x2 to 0x15: Panel path MIPI PLL clock is divided by 2 up to 15.</td>
</tr>
<tr>
<td>7:0</td>
<td>Panel Path Pixel Clock Integer Divider</td>
<td>RW</td>
<td>0x0</td>
<td>This field sets the integer divider to generate the required pixel clock for Smart Panel and Dumb Panel after selecting the pixel clock source. <br/>0x0: Clock disabled<br/>0x1: Clock bypass (no division)<br/>0x2 to 0xFF: Divides the pixel clock source by 2 to 255<br/>> <strong>Note</strong><strong>.</strong> For the TV path, 0x2 to 0x15 divides the MIPI PLL clock by 2 to 15.<br/>For example, when the source AXI bus clock is 166 MHz, setting this register to 0x2 generates an 83 MHz (166 ÷ 2) clock.</td>
</tr>
</tbody>
</table>

#### LCD_PN_CONTRAST_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1AC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Panel Path Video Brightness Control</td>
<td>RW</td>
<td>0x0</td>
<td>Bits [15:8]: Used for sign extension (for positive or negative values).<br/>Bits [7:0]: Used for the integer value of brightness control.<br/>- Brightness adjustments are applied before the Color Space Conversion (CSC).<br/>- The brightness change range is +/- 0 to 255.<br/>- The value is represented in 2's complement:<br/>	Example:<br/>	1. Set this field to 0x10 to make the video brighter.<br/>	2. Set this field to 0xFFF0 to make the video darker.</td>
</tr>
<tr>
<td>15:0</td>
<td>Panel Path Video Contrast Control</td>
<td>RW</td>
<td>0x0</td>
<td>Bit [15]: Used for the sign (for positive or negative values).<br/>Bit [14]: Used for the integer part.<br/>Bits [13:0]: Used for the fractional part of contrast control.<br/>- The value is represented in 2's complement:<br/>	Example:<br/>	1. Set this field to 0x4000 for a ratio of 1.0 (No change)<br/>	2. Set this field to 0x6000 for a ratio of 1.5 (Increase contrast)<br/>	3. Set this field to 0x2000 for a ratio of 0.5 (Decrease contrast)</td>
</tr>
</tbody>
</table>

#### LCD_PN_SATURATION_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1B0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Panel Path Configure Multiplier</td>
<td>RW</td>
<td>0x0</td>
<td>Bit [15]: Used for the sign (for positive or negative values). <br/>Bits [14:13]: Used for integer. <br/>Bits [12:0] Used for fraction of multiplier of contrast and saturation. <br/>These bits are 2's complement code.</td>
</tr>
<tr>
<td>15:0</td>
<td>Panel Path Configure Saturation</td>
<td>RW</td>
<td>0x0</td>
<td>Bit [15]: Used for the sign (for positive or negative values). <br/>Bit [14]: Used for integer. <br/>Bits [13:0]: Used for fraction of saturation control. <br/>These bits are 2's complement code.</td>
</tr>
</tbody>
</table>

#### LCD_PN_CBSH_HUE_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1B4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Panel Path Video HUE Sine Correction</td>
<td>RW</td>
<td>0x0</td>
<td>Bit [15]: Used for the sign (positive or negative correction). <br/>Bit [14]: Used for integer. <br/>Bits [13:0]: Used for fraction of sine (delta phase). <br/>These bits are 2's complement code. <br/>Formula:<br/>Corrected U = U * cos + V * sin<br/>Corrected V = V * cos - U * sin<br/>- For example, <br/>	CFG_SIN=0x0, CFG_COS=0x4000 makes no correction. </td>
</tr>
<tr>
<td>15:0</td>
<td>Panel Path Video HUE Cosine Correction</td>
<td>RW</td>
<td>0x0</td>
<td>Bit [15]: Used for the sign (positive or negative correction). <br/>Bit [14]: Used for integer. <br/>Bits [13:0]: Used for fraction of sine (delta phase). <br/>These bits are 2's complement code. <br/>Formula:<br/>Corrected U = U * cos + V * sin<br/>Corrected V = V * cos - U * sin<br/>- For example, <br/>	CFG_SIN=0x2000, CFG_COS=0x376D makes  a 30 degree correction. </td>
</tr>
</tbody>
</table>

#### LCD_DUMB_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1B8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Panel Path Configure Dumb Panel Color Mode</td>
<td>RW</td>
<td>0x0</td>
<td>This field is used for the Panel Path to convert internal RGB888 pixels into the destination color format. <br/>0x0: LDD[15:0] is 16-bit RGB565; <br/>0x1: LDD[23:8] is 16-bit RGB565; <br/>0x2: LDD[17:0] is 18-bit RGB666; <br/>0x3: LDD[23:6] is 18-bit RGB666; <br/>0x4: LDD[11:0] is 12-bit RGB444; <br/>0x5: LDD[23:12] is 12-bit RGB444; <br/>0x6: LDD[23:0] is RGB888; <br/>Other values: Output blank color (as set by the Panel Screen Blank Color Register) to the I/O.</td>
</tr>
<tr>
<td>27:20</td>
<td>LCD GPIO Output Data</td>
<td>RW</td>
<td>0x0</td>
<td>LCD GPIO Output Data</td>
</tr>
<tr>
<td>19:12</td>
<td>LCD GPIO Output Data Enable</td>
<td>RW</td>
<td>0x0</td>
<td>LCD GPIO Output Data Enable</td>
</tr>
<tr>
<td>11</td>
<td>Panel Path Delay Graphic DMA</td>
<td>RW</td>
<td>0x0</td>
<td>- This field is used to reduce AXI bus activity by delaying graphic DMA until sufficient FIFO space is available for multiple bursts. <br/>- It is only applicable when:<br/>	1. The graphic path is enabled.<br/>	2. The AXI bus traffic is low.<br/>- If not used properly, FIFO underflow could occur, which would disrupt the data flow.</td>
</tr>
<tr>
<td>10</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>9</td>
<td>Panel Path I/O Pads Output Disable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Disabled after next VSYNC<br/>0x0: Enabled after next VSYNC</td>
</tr>
<tr>
<td>8</td>
<td>Panel Path Dumb LCD Panel GPIO Control Pin</td>
<td>RW</td>
<td>0x0</td>
<td>This field controls the backlight of a Dumb LCD Panel.<br/>Active only when both the &lt;Dumb Panel Backlight Clock Divider&gt; and &lt;Duty Cycle Control&gt; fields in the Graphic Line Length (Pitch) Register are 0x0000. </td>
</tr>
<tr>
<td>7</td>
<td>Panel Path Configure Reverse RGB Bit Order</td>
<td>RW</td>
<td>0x0</td>
<td>1: Reverse the RGB bit order<br/>1. For example, R[7:0] G[7:0] B[7:0] are reversed to R[0:7] G[0:7] B[0:7]. <br/>0: Do not reverse.</td>
</tr>
<tr>
<td>6</td>
<td>Panel Path Invert Composite Blank Signal</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert <br/>0: Do not invert.</td>
</tr>
<tr>
<td>5</td>
<td>Panel Path Invert Composite Sync Signal</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert <br/>0: Do not invert.</td>
</tr>
<tr>
<td>4</td>
<td>Panel Path Invert Pixel Valid Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert <br/>0: Do not invert.</td>
</tr>
<tr>
<td>3</td>
<td>Panel Path Invert VSYNC</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert <br/>0: Do not invert.</td>
</tr>
<tr>
<td>2</td>
<td>Panel Path Invert HSYNC</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert <br/>0: Do not invert.</td>
</tr>
<tr>
<td>1</td>
<td>Panel Path Invert Pixel Clock</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert <br/>0: Do not invert.</td>
</tr>
<tr>
<td>0</td>
<td>Panel Path Enable Dumb LCD Panel</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled <br/>> <strong>Note</strong><strong>.</strong><strong> </strong>Smart Panel should be disabled when this bit is 1<br/>0: Disabled.</td>
</tr>
</tbody>
</table>

#### PN_IOPAD_CONTROL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1BC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Mask Panel Path Video Y SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>30</td>
<td>Mask Panel Path Video U SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>29</td>
<td>Mask Panel Path Video V SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>28</td>
<td>Mask Panel Path Graphic Y SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>27</td>
<td>Mask TV Path Video Y SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>26</td>
<td>Mask TV Path Video U SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>25</td>
<td>Mask TV Path Video V SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>24</td>
<td>Mask TV Path Graphic Y SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>23</td>
<td>Mask Panel Path Command SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>22</td>
<td>Mask TV Path Command SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>1: Masks Y Starting Address (SA) update for Panel Path Video.<br/>Updates can occur once after writing both this bit and the &lt;Enable SA Update&gt; field to 1. <br/>0 = Updates SA on each frame.</td>
</tr>
<tr>
<td>21</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>20<br/></td>
<td>Enable SA Update</td>
<td>RW</td>
<td>0x0</td>
<td>- When set to 1, and the mask function is enabled, the Starting Address will be updated only once after VSYNC.<br/>- If the mask function is disabled, this field is not used.</td>
</tr>
<tr>
<td>19</td>
<td>TV Path Graphic Vertical Mirror Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enables vertical mirroring. <br/>DMA fetches from the last line to the first line.<br/>Note: The starting address for DMA must be set to the last line's starting address.<br/>0: Disable</td>
</tr>
<tr>
<td>18</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17</td>
<td>TV Path Video Image Vertical Mirror Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enables vertical mirroring. <br/>DMA fetches from the last line to the first line.<br/>Note: The starting address for DMA must be set to the last line's starting address.<br/>0: Disable</td>
</tr>
<tr>
<td>16</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15</td>
<td>Panel Path Graphic Vertical Mirror Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enables vertical mirroring. <br/>DMA fetches from the last line to the first line.<br/>Note: The starting address for DMA must be set to the last line's starting address.<br/>0: Disable</td>
</tr>
<tr>
<td>14</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>13</td>
<td>Panel Path Video Image Vertical Mirror Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enables vertical mirroring. <br/>DMA fetches from the last line to the first line.<br/>Note: The starting address for DMA must be set to the last line's starting address.<br/>0: Disable</td>
</tr>
<tr>
<td>12</td>
<td>Panel Path Command Vertical Mirror Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enables vertical mirroring. <br/>DMA fetches from the last line to the first line.<br/>Note: The starting address for DMA must be set to the last line's starting address.<br/>0: Disable</td>
</tr>
<tr>
<td>11:10</td>
<td>TV Path Configure Color Space Conversion</td>
<td>RW</td>
<td>0x0</td>
<td>Configures color space conversion for TV Path: <br/>0x0: CCIR601 YUV → Computer RGB <br/>0x1: CCIR601 YUV → Studio RGB <br/>0x2: CCIR709 YUV → Computer RGB <br/>0x3: CCIR709 YUV → Studio RGB</td>
</tr>
<tr>
<td>9:8</td>
<td>Panel Path Configure Color Space Conversion</td>
<td>RW</td>
<td>0x0</td>
<td>Configures color space conversion for Panel Path: <br/>0x0: CCIR601 YUV → Computer RGB <br/>0x1: CCIR601 YUV → Studio RGB <br/>0x2: CCIR709 YUV → Computer RGB <br/>0x3: CCIR709 YUV → Studio RGB</td>
</tr>
<tr>
<td>7:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5</td>
<td>Indicates Boundary</td>
<td>RW</td>
<td>0x0</td>
<td>0: No crossing 4 KB boundary <br/>1: No crossing 1 KB boundary (usually for DDR memory).</td>
</tr>
<tr>
<td>4</td>
<td>Indicates Cycle Burst Length</td>
<td>RW</td>
<td>0x0</td>
<td>0: 8-cycle burst <br/>1: 16-cycle burst (recommended for better performance).</td>
</tr>
<tr>
<td>3:0</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use.</td>
</tr>
</tbody>
</table>

#### SPU_IRQ_ENA_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1C0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Panel Path DMA Frame 0 Done IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>30</td>
<td>smt tx done IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>29</td>
<td>Panel Path DMA FIFO Underflow IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>28</td>
<td>AXI Bus Error IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>27</td>
<td>Panel Path Graphic Frame 0 IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>26</td>
<td>Panel Path Graphic Frame 1 IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>25</td>
<td>Panel Path Graphic FIFO Underflow IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>24</td>
<td>TV Path Hardware Cursor/OSD Frame Done IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>23</td>
<td>Panel Path VSYNC Input Rising Edge IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>22</td>
<td>Panel Path Dumb LCD Panel Frame Done IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>21</td>
<td>Panel Path Smart Panel Frame Done IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>20</td>
<td>SPI Transfer Frame Done IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>19</td>
<td>AHB Slave Path All Command Empty IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>18</td>
<td>SPI Bus Transfer Complete IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>17</td>
<td>Power Down Request IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>16</td>
<td>AXI Bus Latency Too Long IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>15</td>
<td>Write Back fifo overrun Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>14</td>
<td>Write Back Dma Done IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>13</td>
<td>Write Back fifo underrun IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>12</td>
<td>TV Path VSYNC Input Rising Edge IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>11</td>
<td>TV Path Graphic Frame 0 IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>10</td>
<td>TV Path Graphic Frame 1 IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>9</td>
<td>TV Path Graphic FIFO Underflow IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>8</td>
<td>TV Path Display Frame Done IRQ Enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enabled<br/>0: Disabled</td>
</tr>
<tr>
<td>7:0</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### SPU_IRQ_ISR_RAW_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1C4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Panel Path Video Frame 0 Done Rising Edge IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Video Frame 0 Done Rising Edge IRQ (before masking). 0: Clear interrupt<br/>1: No effect<br/></td>
</tr>
<tr>
<td>30</td>
<td>smt tx done IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>SMT TX Done IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>29</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>28</td>
<td>AXI Bus Error IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>AXI Bus Error IRQ (before masking)<br/>0: Clear interrupt <br/>1: No effect</td>
</tr>
<tr>
<td>27</td>
<td>Panel Path Graphic Frame 0 Done Rising Edge IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Graphic Frame 0 Done Rising Edge IRQ (before masking) <br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>26</td>
<td>Panel Path Graphic Frame 1 Done Rising Edge IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Graphic Frame 1 Done Rising Edge IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>25</td>
<td>Panel Path Graphic FIFO Underflow IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Graphic FIFO Underflow IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>24</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23</td>
<td>Panel Path VSYNC Input Rising Edge IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path VSYNC Input Rising Edge IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>22</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21</td>
<td>Panel Path Smart Panel Display Area DMA Done IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>Panel Path Smart Panel Display Area DMA Done IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>20</td>
<td>SPI Transfer Frame Done IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>SPI Frame data Transfer Done IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>19</td>
<td>AHB Slave Path All Commands Output Done IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>AHB Slave Path All Commands Output Done IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>18</td>
<td>SPI Bus Transfer Done IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>SPI Bus Transfer Done IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>17</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>16</td>
<td>AXI Bus Latency Too Long IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>AXI Bus Latency Too Long IRQ <br/>This interrupt occurs when the response time exceeds 512 bus clocks (before masking). <br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>15</td>
<td>Write Back fifo overrun</td>
<td>RW</td>
<td>0x0</td>
<td>Write Back FIFO underrun</td>
</tr>
<tr>
<td>14</td>
<td>Write Back Dma Done</td>
<td>RW</td>
<td>0x0</td>
<td>Write Back DMA Done</td>
</tr>
<tr>
<td>13</td>
<td>Write Back fifo underrun</td>
<td>RW</td>
<td>0x0</td>
<td>Write Back FIFO underrun</td>
</tr>
<tr>
<td>12</td>
<td>TV Path VSYNC Input Rising Edge IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>TV Path VSYNC Input Rising Edge IRQ (before masking). <br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>11</td>
<td>TV Path Graphic Frame 0 Done Rising Edge IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>TV Path Graphic Frame 0 Done Rising Edge IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect<br/></td>
</tr>
<tr>
<td>10</td>
<td>TV Path Graphic Frame 1 Done Rising Edge IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>TV Path Graphic Frame 1 Done Rising Edge IRQ (before masking)<br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>9</td>
<td>TV Path Graphic FIFO Underflow IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>TV Path Graphic FIFO Underflow IRQ (before masking) <br/>0: Clear interrupt <br/>1: No effect</td>
</tr>
<tr>
<td>8</td>
<td>TV Path Display Screen Done IRQ</td>
<td>RW</td>
<td>0x0</td>
<td>TV Path Display Screen Done IRQ. <br/>0: Clear interrupt<br/>1: No effect</td>
</tr>
<tr>
<td>7:4</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>Level of DMA_FF_EMPY</td>
<td>RW</td>
<td>0x0</td>
<td>Level of DMA_FF_EMPY (before masking)</td>
</tr>
<tr>
<td>2</td>
<td>Level of GRA_FF_EMPTY</td>
<td>RW</td>
<td>0x0</td>
<td>Level of GRA_FF_EMPTY (before masking)</td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>Level of TVG_FF_EMPTY</td>
<td>RW</td>
<td>0x0</td>
<td>Level of TVG_FF_EMPTY (before masking)</td>
</tr>
</tbody>
</table>

#### SPU_IRQ_RSR_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1C8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:8</td>
<td>Read to Reset Status Register (Clean ISR[31:8])</td>
<td>RW</td>
<td>0x0</td>
<td>- When SPU_IRQ_RSR[i] = 1: <br/>	1. Reading SPU_IRQ_ISR[i] clears the status and masks the interrupt. <br/>	2. If a new event occurs, the status is updated, but no new interrupt is triggered unless 0 is written to SPU_IRQ_ISR[i]. <br/>- When SPU_IRQ_RSR[i] = 0:<br/>	1. Reading SPU_IRQ_ISR[i] does not clear the status; <br/>	2. To clear both the status and the interrupt mask, write 0 to SPU_IRQ_ISR[i]. <br/>This mechanism is useful for systems that use status polling. </td>
</tr>
<tr>
<td>7:0</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### LCD_GRA_CUTHPXL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1CC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Graphic Color [7:4]</td>
<td>RW</td>
<td>0x0</td>
<td>- Defines the upper 4 bits of the Graphic Color used in the Partial Display Disable area.<br/>- In the disabled area, the graphic is covered by video, so there is no need to read graphic memory.<br/>- The disabled rectangle hollow area is defined by horizontal starting pixel, ending pixel and vertical starting line, ending line.<br/>- Within the Partial Display Disable area, the pseudo 64-bit read data is formed as: {2{2{GRA_CUTCOLOR[15:0]}}}. <br/>- This field is part of a spare area that defines the pseudo 64-bit read data color.<br/>- By default: All bits are 0.</td>
</tr>
<tr>
<td>27:16</td>
<td>Partial Display Disable Horizontal Ending Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>- Specifies the horizontal ending pixel number of the Partial Display Disable area.<br/>- This value must be less than the source graphic horizontal pixel number defined in the the &lt;Panel Path Graphic Source Horizontal Pixel Number&gt; field (in the Panel Graphic Source Size Register).<br/>- The area between the starting pixel number and ending pixel number is the horizontal gap where graphic memory reads are disabled to reduce bandwidth.</td>
</tr>
<tr>
<td>15:12</td>
<td>Graphic Color [3:0]</td>
<td>RW</td>
<td>0x0</td>
<td>- Defines the lower 4 bits of the Graphic Color used in the Partial Display Disable area.<br/>- Similar to Bits [31:28], this field is part of the pseudo 64-bit read data color definition.</td>
</tr>
<tr>
<td>11:0</td>
<td>Partial Display Disable Horizontal Starting Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>- Specifies the horizontal starting pixel number of the Partial Display Disable area.<br/>- This value must be less than the source graphic horizontal pixel number defined in the the &lt;Panel Path Graphic Source Horizontal Pixel Number&gt; field (in the Panel Graphic Source Size Register).<br/>- The area between the starting pixel number and ending pixel number is the horizontal gap where graphic memory reads are disabled to reduce bandwidth.</td>
</tr>
</tbody>
</table>

#### LCD_GRA_CUTVLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1D0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Graphic Color [15:12]</td>
<td>RW</td>
<td>0x0</td>
<td>- Defines bits [15:12] of the Graphic Color (GRA_CUTCOLOR[15:0]) used in the Partial Display Disable area.<br/>- In the disabled area, the graphic is covered by video, so there is no need to read graphic memory.<br/>- The disabled rectangle hollow area is defined by horizontal starting pixel, ending pixel and vertical starting line, ending line.<br/>- The pseudo 64-bit read data in this area is composed of {2{2{GRA_CUTCOLOR[15:0]}}}.<br/>- This field is part of a spare area that defines the pseudo 64-bit read data color.<br/>- By default: All bits are 0.</td>
</tr>
<tr>
<td>27:16</td>
<td>Partial Display Disable Vertical Ending Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>- Specifies the vertical ending line number of the Partial Display Disable area.<br/>- This value must be less than the source graphic vertical line number defined in the &lt;Panel Path Graphic Source Vertical Line Number&gt; field (in the Panel Graphic Source Size Register).<br/>- The area between the starting line number and ending line number is the vertical gap where graphic memory reads are disabled to reduce bandwidth.</td>
</tr>
<tr>
<td>15:12</td>
<td>Graphic Color [11:8]</td>
<td>RW</td>
<td>0x0</td>
<td>- Defines bits [11:8] of the Graphic Color (GRA_CUTCOLOR[15:0]) used in the Partial Display Disable area.<br/>- Similar to Bits 31:28, this field is part of the pseudo 64-bit read data color definition.</td>
</tr>
<tr>
<td>11:0</td>
<td>Partial Display Disable Vertical Starting Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>- Specifies the vertical starting line number of the Partial Display Disable area.<br/>- This value must be less than the source graphic vertical line number defined in the &lt;Panel Path Graphic Source Vertical Line Number&gt; field (in the Panel Graphic Source Size Register).<br/>- The area between the starting line number and ending line number is the vertical gap where graphic memory reads are disabled to reduce bandwidth.</td>
</tr>
</tbody>
</table>

#### LCD_TVG_CUTHPXL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1D4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Graphic Color [7:4]</td>
<td>RW</td>
<td>0x0</td>
<td>- Defines bits [7:4] of the Graphic Color (TVG_CUTCOLOR[15:0]) used in the Partial Display Disable area.<br/>- In the disabled area, the graphic is covered by video, so there is no need to read graphic memory.<br/>- The disabled rectangle hollow area is defined by horizontal starting pixel, ending pixel and vertical starting line, ending line. <br/>- The pseudo 64-bit read data in this area is composed of {2{2{TVG_CUTCOLOR[15:0]}}}.<br/>- This field is part of a spare area that defines the pseudo 64-bit read data color.<br/>- By default: All bits are 0.</td>
</tr>
<tr>
<td>27:16</td>
<td>Partial Display Disable Horizontal Ending Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>- Specifies the horizontal ending pixel number of the Partial Display Disable area.<br/>- This value must be less than the source graphic horizontal pixel number defined in the &lt;TV Path Graphic Source Horizontal Pixel Number&gt; field (in the TV Graphic Source Size Register). <br/>- The area between the starting pixel number and ending pixel number is the horizontal gap where graphic memory reads are disabled to reduce bandwidth.</td>
</tr>
<tr>
<td>15:12</td>
<td>Graphic Color [3:0]</td>
<td>RW</td>
<td>0x0</td>
<td>- Defines bits [3:0] of the Graphic Color (TVG_CUTCOLOR[15:0]) used in the Partial Display Disable area.<br/>- Similar to Bits 31:28, this field is part of the pseudo 64-bit read data color definition.</td>
</tr>
<tr>
<td>11:0</td>
<td>Partial Display Disable Horizontal Starting Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>- Specifies the horizontal starting pixel number of the Partial Display Disable area.<br/>- This value must be less than the source graphic horizontal pixel number defined in the &lt;TV Path Graphic Source Horizontal Pixel Number&gt; field (in the TV Graphic Source Size Register). <br/>- The area between the starting pixel number and ending pixel number is the horizontal gap where graphic memory reads are disabled to reduce bandwidth.</td>
</tr>
</tbody>
</table>

#### LCD_TVG_CUTVLN_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1D8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Graphic Color [15:12]</td>
<td>RW</td>
<td>0x0</td>
<td>- Defines bits [15:12] of the Graphic Color (GRA_CUTCOLOR[15:0]) used in the Partial Display Disable area.<br/>- In the disabled area, the graphic is covered by video, so there is no need to read graphic memory.<br/>- The disabled rectangle hollow area is defined by horizontal starting pixel, ending pixel and vertical starting line, ending line.<br/>- The pseudo 64-bit read data in this area is composed of {2{2{GRA_CUTCOLOR[15:0]}}}.<br/>- This field is part of a spare area that defines the pseudo 64-bit read data color.</td>
</tr>
<tr>
<td>27:16</td>
<td>Partial Display Disable Vertical Ending Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>- Specifies the vertical ending line number of the Partial Display Disable area.<br/>- This value must be less than the source graphic vertical line number defined in the &lt;Panel Path Graphic Source Vertical Line Number&gt; field (in the Panel Graphic Source Size Register).<br/>- The area between the starting line number and ending line number is the vertical gap where graphic memory reads are disabled to reduce bandwidth.</td>
</tr>
<tr>
<td>15:12</td>
<td>Graphic Color [11:8]</td>
<td>RW</td>
<td>0x0</td>
<td>- Defines bits [11:8] of the Graphic Color (GRA_CUTCOLOR[15:0]) used in the Partial Display Disable area.<br/>- Similar to Bits 31:28, this field is part of the pseudo 64-bit read data color definition.</td>
</tr>
<tr>
<td>11:0</td>
<td>Partial Display Disable Vertical Starting Pixel Number</td>
<td>RW</td>
<td>0x0</td>
<td>- Specifies the vertical starting line number of the Partial Display Disable area.<br/>- This value must be less than the source graphic vertical line number defined in the in the &lt;Source Vertical Line Number&gt; field (in the Panel Graphic Source Size Register).<br/>- The area between the starting line number and ending line number is the vertical gap where graphic memory reads are disabled to reduce bandwidth.</td>
</tr>
</tbody>
</table>

#### LCD_TOP_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1DC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Invert I/O Pad VSYNC</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert dumb panel I/O pad VSYNC signal<br/>0: No change</td>
</tr>
<tr>
<td>30</td>
<td>Invert I/O Pad HSYNC</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert Dumb panel IO pad HSYNC signal<br/>0: No change</td>
</tr>
<tr>
<td>29</td>
<td>Invert I/O Pad PCLK</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert Dumb panel IO pad PCLK signal<br/>0: No change</td>
</tr>
<tr>
<td>28</td>
<td>Invert I/O Pad DENA</td>
<td>RW</td>
<td>0x0</td>
<td>1: Invert Dumb panel IO pad DENA signal<br/>0: No change</td>
</tr>
<tr>
<td>27:24</td>
<td>Panel Path Configure MIPI DSI1 or CMU Input Color Mode</td>
<td>RW</td>
<td>0x0</td>
<td>This field is used for the Panel Path to convert internal RGB888 pixels into the MIPI DSI1 color format. <br/>0x0: 24-bit RGB88<br/>0x1: 24-bit RGB88, but swap R and B<br/>Others: Reserved</td>
</tr>
<tr>
<td>23:22</td>
<td>Select All Objects for Panel or TV Interface</td>
<td>RW</td>
<td>0x0</td>
<td>This field selects all four DMA objects to go to Panel or HDMI TV. <br/>0x0: Auto-detect<br/>0x1: All DMA objects go to Panel<br/>0x2: All DMA objects go to HDMI TV<br/>0x3: Panel path DMA to Panel, TV path DMA to TV</td>
</tr>
<tr>
<td>21</td>
<td>Select Clock when One Clock Domain is Enabled</td>
<td>RW</td>
<td>0x0</td>
<td>0: Select panel clock for TV when one clock domain is enabled. <br/>1: Select TV clock for Panel when one clock domain is enabled.<br/></td>
</tr>
<tr>
<td>20</td>
<td>Clock Domain Selection</td>
<td>RW</td>
<td>0x0</td>
<td>This field enables one clock domain for both TV and Panel. <br/>1: One clock domain is selected<br/>0: TV path and Panel path use different clock domains.</td>
</tr>
<tr>
<td>19</td>
<td>Swap TV Path Processing</td>
<td>RW</td>
<td>0x0</td>
<td>0: TV path video processing is for video DMA, palette table is for graphic DMA. <br/>1: TV path video processing is for graphic DMA, palette table is for video DMA.</td>
</tr>
<tr>
<td>18</td>
<td>Swap TV Path Enable</td>
<td>RW</td>
<td>0x0</td>
<td>0: Auto detect TV path video processing path (&lt;Swap TV Path Processing&gt; field is ignored)<br/>1: TV path video processing is selected by the &lt;Swap TV Path Processing&gt; field.</td>
</tr>
<tr>
<td>17</td>
<td>Swap Panel Path Processing</td>
<td>RW</td>
<td>0x0</td>
<td>0: Panel path video processing is for video DMA, palette table is for graphic DMA. <br/>1: Panel path video processing is for graphic DMA, palette table is for video DMA.</td>
</tr>
<tr>
<td>16</td>
<td>Swap Panel Path Enable</td>
<td>RW</td>
<td>0x0</td>
<td>0: Auto detect Panel path video processing path (&lt;Swap Panel Path Processing&gt; field is ignored). <br/>1: Panel path video processing is selected by the &lt;Swap Panel Path Processing&gt; field.</td>
</tr>
<tr>
<td>15:14</td>
<td>Select TV Path Graphic DMA Burst Length</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: One burst (64 bytes)<br/>0x1: Two bursts (128 bytes)<br/>0x2: Three bursts (192 bytes)<br/>0x3: Four bursts (256 bytes)</td>
</tr>
<tr>
<td>13:12</td>
<td>Select TV Path Video DMA Burst Length</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: One burst (64 bytes)<br/>0x1: Two bursts(128 bytes)<br/>0x2: Three bursts (192 bytes)<br/>0x3: Four bursts (256 bytes)</td>
</tr>
<tr>
<td>11:10</td>
<td>Select Panel Path Graphic DMA Burst Length</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: One burst (64 bytes)<br/>0x1: Two bursts (128 bytes)<br/>0x2: Three bursts(192 bytes)<br/>0x3: Four bursts (256 bytes)</td>
</tr>
<tr>
<td>9:8</td>
<td>Select Panel Path Video DMA Burst Length</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: One burst (64 bytes)<br/>0x1: Two bursts (128 bytes)<br/>0x2: Three bursts(192 bytes)<br/>0x3: Four bursts (256 bytes)</td>
</tr>
<tr>
<td>7:6</td>
<td>AHB Slave Read Wait Cycles</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: One AHB read wait cycle<br/>0x1: Two AHB read wait cycles<br/>0x2: Three AHB read wait cycles<br/>0x3: Four AHB read wait cycles</td>
</tr>
<tr>
<td>5:4</td>
<td>AHB Slave Write Wait Cycles</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: One AHB read wait cycle<br/>0x1: Two AHB read wait cycles<br/>0x2: Three AHB read wait cycles<br/>0x3: Four AHB read wait cycles</td>
</tr>
<tr>
<td>3:0</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use.</td>
</tr>
</tbody>
</table>

#### LCD_AFA_ALL2ONE_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1E8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23</td>
<td>Enable Two-Level Zoom Down in TV Path Graphic DMA</td>
<td>RW</td>
<td>0x0</td>
<td>Enables two-level zoom down for the TV Path Graphic DMA.<br/>The source horizontal pixel (defined in the &lt;TV Path Graphic Source Horizontal Pixel Number&gt; field (in the TV Graphic Source Size Register)) must be an even number.<br/>The zoom down is performed in two stages:<br/>- First, the image is divided by 2.<br/>- Then, it is further shrunk to the exact destination pixel number.<br/>0x0: Disabled (direct zoom down, limited by 64-bit/pixel clock).<br/>0x1: Enabled (allows higher zoom down ratios, e.g., for RGB565 mode, zoom down is limited by 4x, while two-level zoom down can make it to 8x).</td>
</tr>
<tr>
<td>22</td>
<td>Enable Two-Level Zoom Down in TV Path Video DMA</td>
<td>RW</td>
<td>0x0</td>
<td>Enables two-level zoom down for the TV Path Video DMA.<br/>Similar to Bit [23], but applies to the Video DMA.<br/>0x0: Disabled (direct zoom down, limited by 64-bit/pixel clock).<br/>0x1: Enabled (allows higher zoom down ratios, e.g., for RGB565 mode, zoom down is limited by 4x, while two-level zoom down can make it to 8x).</td>
</tr>
<tr>
<td>21</td>
<td>Enable Two-Level Zoom Down in Panel Path Graphic DMA</td>
<td>RW</td>
<td>0x0</td>
<td>Enables two-level zoom down for the Panel Path Graphic DMA.<br/>The source horizontal pixel (defined in the &lt;TV Path Graphic Source Horizontal Pixel Number&gt; field (in the TV Graphic Source Size Register)) must be an even number.<br/>The zoom down is performed in two stages:<br/>- First, the image is divided by 2.<br/>- Then, it is further shrunk to the exact destination pixel number.<br/>0x0: Disabled (direct zoom down, limited by 64-bit/pixel clock).<br/>0x1: Enabled (allows higher zoom down ratios, e.g., for RGB565 mode, zoom down is limited by 4x, while two-level zoom down can make it to 8x).</td>
</tr>
<tr>
<td>20</td>
<td>Enable Two-Level Zoom Down in Panel Path Video DMA</td>
<td>RW</td>
<td>0x0</td>
<td>Enables two-level zoom down for the Panel Path Video DMA.<br/>Similar to Bit [21], but applies to the Video DMA.<br/>0x0: Disabled (direct zoom down, limited by 64-bit/pixel clock).<br/>0x1: Enabled (allows higher zoom down ratios, e.g., for RGB565 mode, zoom down is limited by 4x, while two-level zoom down can make it to 8x).</td>
</tr>
<tr>
<td>19:18</td>
<td>Enable Graphic DMA Vertical Smooth</td>
<td>RW</td>
<td>0x0</td>
<td>Enables vertical smoothing for graphic DMA.<br/>Two graphic DMA channels are used to read two lines near the resampling line and apply smooth filtering.<br/>0x0: Disabled (Graphic vertical smooth is not done).<br/>0x1: Reserved.<br/>0x2: Panel graphic vertical smooth (TV graphic DMA filters Panel graphic).<br/>0x3: TV graphic vertical smooth (Panel graphic DMA filters TV graphic).</td>
</tr>
<tr>
<td>17:16</td>
<td>Enable Video DMA Vertical Smooth</td>
<td>RW</td>
<td>0x0</td>
<td>Enables vertical smoothing for video DMA.<br/>Two video DMA channels are used to read two lines near the resampling line and apply smooth filtering.<br/>0x0: Disabled (Video vertical smooth is not done).<br/>0x1: Reserved.<br/>0x2: Panel video vertical smooth (TV video DMA filters Panel video).<br/>0x3: TV video vertical smooth (Panel video DMA filters TV video).</td>
</tr>
<tr>
<td>15:14</td>
<td>Select Alpha when Panel and TV Path Graphics Overlaid</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the alpha blending source when Panel and TV Path graphics are overlaid.<br/>0x0: TV path graphic DMA alpha.<br/>0x1: Panel path graphic DMA alpha.<br/>0x2: Panel path configured alpha.<br/>0x3: TV path configured alpha.</td>
</tr>
<tr>
<td>13:12</td>
<td>Select Alpha when Panel Path Graphic and TV Path Video Overlaid</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the alpha blending source when Panel Path graphic and TV Path video are overlaid.<br/>0x0: TV path video DMA alpha.<br/>0x1: Panel path graphic DMA alpha.<br/>0x2: Panel path configured alpha.<br/>0x3: TV path configured alpha.</td>
</tr>
<tr>
<td>11:10</td>
<td>Select Alpha when Panel and TV Path Graphics Overlaid</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the alpha blending source when Panel and TV Path graphics are overlaid.<br/>0x0: Panel path video DMA alpha.<br/>0x1: TV path graphic DMA alpha.<br/>0x2: Panel path configured alpha.<br/>0x3: TV path configured alpha.</td>
</tr>
<tr>
<td>9:8</td>
<td>Select Alpha when Panel and TV Path Videos Overlaid</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the alpha blending source when Panel and TV Path videos are overlaid.<br/>0x0: Panel path video DMA alpha.<br/>0x1: TV path video DMA alpha.<br/>0x2: Panel path configured alpha.<br/>0x3: TV path configured alpha.</td>
</tr>
<tr>
<td>7:5</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>Select Hardware Cursor when Cursor Overlaid</td>
<td>RW</td>
<td>0x0</td>
<td>When one path is disabled, all four objects and two cursor objects can be overlaid together. <br/>Selects the hardware cursor when two cursors are overlaid.<br/>0x0: Use Panel path cursor<br/>0x1: Use TV path cursor</td>
</tr>
<tr>
<td>3:2</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1:0</td>
<td>Alpha Blending Mode</td>
<td>RW</td>
<td>0x0</td>
<td>Alpha Blending Mode Selection. 0x0 = L0*(1-A1)+L1*A1, 0x1 = L0*(1-A1)+L1, 0x2 =L0*A1+L1, 0x3 = reserved.<br/>Selects the alpha blending mode.<br/>0x0: L0*(1-A1) + L1*A1<br/>0x1: L0*(1-A1) + L1<br/>0x2: L0*A1 + L1<br/>0x3: Reserved</td>
</tr>
</tbody>
</table>

#### LCD_DITHER_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1EC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:18</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17:16</td>
<td>Dither Table Index Selection</td>
<td>RW</td>
<td>0x0</td>
<td>Dither Table Index Selection. This field is used when software needs to read from or write to the dither table. <br/>Selects the dither table index for software access.<br/>0x0: Access dither table index 0.<br/>0x1: Access dither table index 1.<br/>0x2: Access dither table index 2.<br/>0x3: Access dither table index 3.</td>
</tr>
<tr>
<td>15</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14:12</td>
<td>Dither Mode Selection For TV Path</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the dither mode for the TV Path.<br/>0x0: RGB 444 mode.<br/>0x1: RGB 565 mode.<br/>0x2: RGB 666 mode.</td>
</tr>
<tr>
<td>11:10</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>9</td>
<td>Dither Table 4x4 or 4x8 for TV Path</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the dither table size for the TV Path.<br/>0x0: 4x4 dither table.<br/>0x1: 4x8 dither table.</td>
</tr>
<tr>
<td>8</td>
<td>Dither Enable for TV Path</td>
<td>RW</td>
<td>0x0</td>
<td>Enables or disables dithering for the TV Path.<br/>0x0: Disable dithering.<br/>0x1: Enable dithering.</td>
</tr>
<tr>
<td>7</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6:4</td>
<td>Dither Mode Selection for Panel Path</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the dither mode for the Panel Path.<br/>0x0: RGB 444 mode.<br/>0x1: RGB 565 mode.<br/>0x2: RGB 666 mode.</td>
</tr>
<tr>
<td>3:2</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1</td>
<td>Dither Table 4x4 or 4x8 for Panel Path</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the dither table size for the Panel Path.<br/>0x0: 4x4 dither table.<br/>0x1: 4x8 dither table.</td>
</tr>
<tr>
<td>0</td>
<td>Dither Enable for Panel Path</td>
<td>RW</td>
<td>0x0</td>
<td>Enables or disables dithering for the Panel Path.<br/>0x0: Disable dithering.<br/>0x1: Enable dithering.</td>
</tr>
</tbody>
</table>

#### LCD_DITHER_TBL_DATA_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1F0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>LCD Dither Table Data Port</td>
<td>RW</td>
<td>0x0</td>
<td>There is a total of 128 bits for the dither table. <br/>To access the dither table, use the &lt;Dither Table Select Index&gt; in the Dither Control Register.</td>
</tr>
</tbody>
</table>

####LCD_MISC_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1F8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Configure SPI Transmit  HW</td>
<td>RW</td>
<td>0x0</td>
<td>hw control tx ibits, only for spi fast mode image. Configure SPI Transmit. 0x1F = Write/transmit 32 bits, 0x01 = Write/transmit 2 bits, 0x00 = Do not transfer. If the &lt;Configure SPI Receive&gt; field is set to 0x00, there is no receiving, only transmit. The maximum write length is 32 bits per trigger , and unlimited write length can be reached if triggering one after another and if the &lt;Configure Continuous Transfer&gt; field is set to 0x01. If the &lt;Configure SPI Receive&gt; field is not 0x00, it will first transmit serial bits, and then receive incoming bits.<br/>Hardware-Controlled SPI Transmit (Fast Mode Only):<br/>This field configures SPI data transmission in fast mode.<br/>0x1F: Write/transmit 32 bits.<br/>0x01: Write/transmit 2 bits.<br/>0x00: Do not transfer.<br/>- If the &lt;Configure SPI Receive&gt; field is set to `0x00`, only data transmission occurs without receiving. <br/>	1. The maximum write length is 32 bits per trigger. <br/>	2. Continuous transmission is possible if triggers are sent consecutively and the &lt;Configure Continuous Transfer&gt; field is set to 0x01.<br/>- If the Configure SPI Receive field is not 0x00, the system will first transmit the serial bits and then receive incoming data.</td>
</tr>
<tr>
<td>23:21</td>
<td>cfg_ch_time</td>
<td>RW</td>
<td>0x0</td>
<td>cs hold time = (cfg_ch_time+1)*period_sclk</td>
</tr>
<tr>
<td>20:19</td>
<td>cfg_csu_time</td>
<td>RW</td>
<td>0x0</td>
<td>cs setup time = (cfg_csu_time+2)*period_sclk</td>
</tr>
<tr>
<td>18</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17</td>
<td>slv_fast_mode</td>
<td>RW</td>
<td>0x0</td>
<td>indicate cmd in burst mode</td>
</tr>
<tr>
<td>16</td>
<td>slv_burst_trigger</td>
<td>RW</td>
<td>0x0</td>
<td>Set to 1 to trigger burst mode after command is settled (for slv_fast_mode).</td>
</tr>
<tr>
<td>15:12</td>
<td>burst_length_hw</td>
<td>RW</td>
<td>0x0</td>
<td>Hardware-controlled burst length (actual length is burst_length_hw + 1) for fast mode.</td>
</tr>
<tr>
<td>11:8</td>
<td>burst_length_sw</td>
<td>RW</td>
<td>0x0</td>
<td>Software-controlled burst length (actual length is burst_length_sw + 1).</td>
</tr>
<tr>
<td>7</td>
<td>spi cmd trigger</td>
<td>RW</td>
<td>0x0</td>
<td>Write 1 before setting cmd only for fast mode</td>
</tr>
<tr>
<td>6</td>
<td>spi_fast_mode</td>
<td>RW</td>
<td>0x0</td>
<td>SPI fast mode control: <br/> 0x1: Software does not wait for SPI command completion IRQ. <br/> 0x0: Software waits.</td>
</tr>
<tr>
<td>5:4</td>
<td>smpn2spi_mode</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: 1 data lane mode <br/>0x1: 2 data lane RGB888-3cycle mode<br/>0x2: 2 data lane RGB666-3cycle mode</td>
</tr>
<tr>
<td>3</td>
<td>Configure 3-/4-line SPI</td>
<td>RW</td>
<td>0x0</td>
<td>1: 3-line SPI, 9bit serial data<br/>0: 4-line SPI, 8bit serial data+D/CX pin.</td>
</tr>
<tr>
<td>2</td>
<td>spi_2ln_mode</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: 1 data lane mode<br/>0x1: 2 data lane mode.</td>
</tr>
<tr>
<td>1</td>
<td>Smart Panel RB swap</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: No swap<br/>0x1: Swap RB (Set 1 for GC9305).</td>
</tr>
<tr>
<td>0</td>
<td>SPI data path swap to hw</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: CPU control <br/>0x1: Hareware control</td>
</tr>
</tbody>
</table>

#### LCD_WDMA_CTRL1_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x200</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>wdma_img_pitch</td>
<td>RW</td>
<td>0x0</td>
<td>wdma pitch by bytes</td>
</tr>
<tr>
<td>15:13</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>12:8</td>
<td>wdma_burst_len</td>
<td>RW</td>
<td>0x0</td>
<td>wdma burst length by bytes</td>
</tr>
<tr>
<td>7:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:4</td>
<td>wdma_pix_fmt</td>
<td>RW</td>
<td>0x0</td>
<td>0: 16bit RGB565<br/>1: 24bit RGB888<br/>2: 32bit ARGB8888<br/>3: 32bit RGBA8888</td>
</tr>
<tr>
<td>3:1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>wdma_ena</td>
<td>RW</td>
<td>0x0</td>
<td>1: Valid</td>
</tr>
</tbody>
</table>

#### LCD_WDMA_CTRL2_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x204</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>wdma_img_height</td>
<td>RW</td>
<td>0x0</td>
<td>wdma_img_height</td>
</tr>
<tr>
<td>15:13</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>12:0</td>
<td>wdma_img_width</td>
<td>RW</td>
<td>0x0</td>
<td>wdma_img_width</td>
</tr>
</tbody>
</table>

#### LCD_WDMA_CTRL3_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x208</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>wdma_base_addr</td>
<td>RW</td>
<td>0x0</td>
<td>wdma_base_addr</td>
</tr>
</tbody>
</table>

#### LCD_WDMA_CTRL4_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x20C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:21</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>20</td>
<td>dmac_wr_err</td>
<td>RO</td>
<td>0x0</td>
<td>dmac_wr_err</td>
</tr>
<tr>
<td>19</td>
<td>dmac_rst_n_pwr</td>
<td>RW</td>
<td>0x0</td>
<td>dmac_rst_n_pwr</td>
</tr>
<tr>
<td>18</td>
<td>dmac_rst_req</td>
<td>RW</td>
<td>0x0</td>
<td>dmac_rst_req</td>
</tr>
<tr>
<td>17</td>
<td>dmac_wr_int_clr</td>
<td>RW</td>
<td>0x0</td>
<td>dmac_wr_int_clr</td>
</tr>
<tr>
<td>16</td>
<td>dmac_axi_sec</td>
<td>RW</td>
<td>0x0</td>
<td>dmac_axi_sec</td>
</tr>
<tr>
<td>15</td>
<td>dmac_wr_post_en</td>
<td>RW</td>
<td>0x0</td>
<td>dmac_wr_post_en</td>
</tr>
<tr>
<td>14:12</td>
<td>dmac_max_req_num</td>
<td>RW</td>
<td>0x0</td>
<td>dmac_max_req_num</td>
</tr>
<tr>
<td>11:8</td>
<td>dmac_arqos</td>
<td>RW</td>
<td>0x0</td>
<td>dmac_awqos</td>
</tr>
<tr>
<td>7:4</td>
<td>dmac_awqos</td>
<td>RW</td>
<td>0x0</td>
<td>dmac_awqos</td>
</tr>
<tr>
<td>3:0</td>
<td>dmac_user_id</td>
<td>RW</td>
<td>0x0</td>
<td>dmac_user_id</td>
</tr>
</tbody>
</table>
