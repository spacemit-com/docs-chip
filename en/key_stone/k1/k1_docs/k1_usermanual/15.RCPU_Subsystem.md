# 15. RCPU Subsystem

```
Last Version: 2025/11/18
```

## 15.1 Overview

The RCPU subsystem includes

- 256kB SRAM
- DMA
- Various APB peripherals (such as I2C, SSP, PWM, etc.) for the Sensor-Hub Subsystem

The power domain of the RCPU subsystem is independent from other modules, allowing the audio subsystem to function even when it enters low-power modes.

## 15.2 Features

### General

The applications of the RCPU subsystem can access its memory and peripherals.

### Main Peripherals

- **1 x I2C Controller**: **Support for 100kHz (standard mode), 400kHz (fast mode), 3.4MHz (high-speed mode)
- **One Timer Group**: **Inclusion of three counters, each with three match values
- **1x SPI Controller**: **Support for data rate up to 24Mbps
- **2 x UART Controllers:** One UART supports auto-flow control
- **10x PWM Controller**

### Power & Clock Management

- Advanced clock gating, including software-controlled gating for peripherals and automatic clock gating for buses, fabrics and bridges
- Audio subsystem can operates in D0 (normal power on) mode and D1, D2 (low power) modes
- Four power mode for audio subsystem:

  - **ACTIVE**
  - **CLK_GATING**
  - **PLL_OFF**
  - **PWR_OFF**

## 15.3 Register Description

### AUD_PMU Registers

> **Note.** Base address = **0xC0A10000**

#### AUDIO_PMU_VOTE REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: </strong><strong>0x18</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:4</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>Vote for audio PMU to enter PWR OFF mode</td>
<td>RW</td>
<td>0x1<br/></td>
<td>1: Allow audio PMU to enter power-off mode.<br/>0: Deny audio PMU from entering power-off mode.</td>
</tr>
<tr>
<td>2</td>
<td>Vote for audio PMU to enter PLL OFF mode</td>
<td>RW</td>
<td>0x1</td>
<td>1: Allow audio PMU to enter PLL-off mode.<br/>0: Deny audio PMU from entering PLL-off mode.</td>
</tr>
<tr>
<td>1</td>
<td>Vote for audio PMU to enter low-power mode</td>
<td>RW</td>
<td>0x1</td>
<td>1: Allow audio PMU to enter low-power mode.<br/>0: Deny audio PMU from entering low-power mode.</td>
</tr>
<tr>
<td>0</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### AUDIO_VOTE_FOR_MAIN_PMU REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x20</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:7</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6</td>
<td>Audio vote for AP AXI clock off</td>
<td>RW</td>
<td>0x1</td>
<td>1: Allow AP AXI clock off<br/>0: Deny AP AXI clock off   </td>
</tr>
<tr>
<td>5</td>
<td>Audio vote for DDR shutdown</td>
<td>RW</td>
<td>0x1</td>
<td>1: Allow DDR shutdown<br/>0: Deny DDR shutdown   </td>
</tr>
<tr>
<td>4</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>Audio vote for VCTCXO off</td>
<td>RW</td>
<td>0x1</td>
<td>1: Allow VCTCXO off.<br/>0: Deny VCTCXO off.</td>
</tr>
<tr>
<td>2</td>
<td>Audio vote for main PMU sleep state</td>
<td>RW</td>
<td>0x1</td>
<td>1: Allow main PMU to enter sleep state.<br/>0: Deny main PMU sleep state.</td>
</tr>
<tr>
<td>1</td>
<td>Audio vote for AP standby state</td>
<td>RW</td>
<td>0x1</td>
<td>1: Allow AP to go to standby state.<br/>0: Deny AP standby state.</td>
</tr>
<tr>
<td>0</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### AUDIO_WAKEUP_EN REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x28</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:8</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>timer_wkup_en</td>
<td>RW</td>
<td>0x0</td>
<td>Audio timer wake up enable  <br/>1: Enable  <br/>0: Disable     </td>
</tr>
<tr>
<td>3</td>
<td>ap_wkup_en</td>
<td>RW</td>
<td>0x0</td>
<td>AP wake up enable  <br/>1: Enable  <br/>0: Disable    </td>
</tr>
<tr>
<td>2</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1</td>
<td>ipc_ap_wkup_en</td>
<td>RW</td>
<td>0x0</td>
<td>Audio to AP IPC wake up enable  <br/>1: Enable  <br/>0: Disable     </td>
</tr>
<tr>
<td>0</td>
<td>shub_int_wkup_en</td>
<td>RW</td>
<td>0x0</td>
<td>Audio sensor hub wake up enable  <br/>1: Enable  <br/>0: Disable    </td>
</tr>
</tbody>
</table>

#### AON_PER_CLK_RST_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x2C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:2</td>
<td>Reserved<br/></td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1</td>
<td>ipc2ap clk enable</td>
<td>RW</td>
<td>0x0</td>
<td>1: Enable  <br/>0: Disable </td>
</tr>
<tr>
<td>0</td>
<td>aipc_ap_rstn</td>
<td>RW</td>
<td>0x0</td>
<td>1: Release reset   <br/>0: Reset     </td>
</tr>
</tbody>
</table>

#### MCU_EXECUTION_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x30</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>mcu_execution_ctrl</td>
<td>RW</td>
<td>0x0</td>
<td>1: Let MCU run   <br/>0: Halt MCU      </td>
</tr>
</tbody>
</table>

#### AUDIO_BUS_CLK_DIV REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x38</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:7</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6:4</td>
<td>apb_clk_div</td>
<td>RW</td>
<td>0x3</td>
<td>0: rsvd   <br/>1: div2   <br/>2: div4     <br/>3: div8   <br/>4: div16   <br/>5: rsvd     <br/>6: rsvd     <br/>7: rsvd </td>
</tr>
<tr>
<td>3:2</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1:0</td>
<td>axi_clk_div</td>
<td>RW</td>
<td>0x1</td>
<td>0: div1   <br/>1: div2   <br/>2: div4     <br/>3: div8    </td>
</tr>
</tbody>
</table>

#### SHUB_GPO REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x3C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:8</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7:0</td>
<td>shub_gpo</td>
<td>RW</td>
<td>0x0</td>
<td>Sensor hub GPIO output value    </td>
</tr>
</tbody>
</table>

#### AUDIO_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xE0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>audio ADC test interrupt status</td>
<td>RW</td>
<td>0x0</td>
<td>Audio ADC test mode interrupt status<br/>1: Test Done </td>
</tr>
<tr>
<td>30</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>29</td>
<td>hook key interrupt clear</td>
<td>RW</td>
<td>0x0</td>
<td>Clear the latched interrupt for hook key event<br/>1: Clear<br/>Hook key interrupt status is stored in AUDIO_STATUS[21:14] </td>
</tr>
<tr>
<td>28:24</td>
<td>Hook key detection debuonce clock divider</td>
<td>RW</td>
<td>0xF</td>
<td>Specify the hook-key-detection debounce clock. <br/>The debounce clock is divided from 32KHz clock.  </td>
</tr>
<tr>
<td>23</td>
<td>Class G right channel  OCP interrupt clear</td>
<td>RW</td>
<td>0x0</td>
<td>Clear the latched interrupt for Class G right channel OCP. <br/>1: Clear <br/>Interrupt status is stored in AUDIO_STATUS[13] </td>
</tr>
<tr>
<td>22</td>
<td>Class G left channel  OCP interrupt clear</td>
<td>RW</td>
<td>0x0</td>
<td>Clear the latched interrupt for Class G left channel OCP. <br/>1: Clear<br/>Interrupt status is stored in AUDIO_STATUS[12] </td>
</tr>
<tr>
<td>21</td>
<td>Class AB OCP interrupt clear</td>
<td>RW</td>
<td>0x0</td>
<td>Clear the latched interrupt for Class AB OCP. <br/>1: Clear<br/>Interrupt status is stored in AUDIO_STATUS[11] </td>
</tr>
<tr>
<td>20:15</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14</td>
<td>classge_shortpwr int enable</td>
<td>RW</td>
<td>0x0</td>
<td>0: Disable Class G short power interrupt.<br/>1: Enable Class G short power interrupt.</td>
</tr>
<tr>
<td>13</td>
<td>classge_r_shortpwr_clr</td>
<td>RW</td>
<td>0x0</td>
<td>Clear the classg_r_short pwr interrupt. <br/>1: Clear interrupt  </td>
</tr>
<tr>
<td>12</td>
<td>classge_l_shortpwr_clr</td>
<td>RW</td>
<td>0x0</td>
<td>Clear the classg_l_short pwr interrupt. <br/>1: Clear interrupt  </td>
</tr>
<tr>
<td>11:4</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>plug wakeup interrupt clear</td>
<td>RW</td>
<td>0x0</td>
<td>Clear the latched plug in or plug out wakeup interrupt. <br/>1: Clear interrupt<br/>Plug interrupt status is stored in AUDIO_STATUS[10:9] </td>
</tr>
<tr>
<td>2</td>
<td>auto OCP reset assertion</td>
<td>RW</td>
<td>0x1</td>
<td>Enable automatic generation of ocp_rst for class G and class AB. <br/>1: Enable<br/>0: Disable </td>
</tr>
<tr>
<td>1</td>
<td>analog test mode interrupt mask</td>
<td>RW</td>
<td>0x0</td>
<td>Enable interrupt when audio ADC test is done. <br/>1: Enable interrupt </td>
</tr>
<tr>
<td>0</td>
<td>analog plugin  polarity</td>
<td>RW</td>
<td>0x0</td>
<td>0: Plugin status high indicates a plugin event.<br/>1: Plugin status low indicates a plugin event.</td>
</tr>
</tbody>
</table>

#### AUDIO_CTRL2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xE4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:19</td>
<td>OCP length for Class G</td>
<td>RW</td>
<td>0xff</td>
<td>Specifies the number of 32KHz cycles of Class G OCP assertion before ocp_rst is automatically generated.</td>
</tr>
<tr>
<td>18:14</td>
<td>OCP  occurance times before interrupt for classg</td>
<td>RW</td>
<td>0x1f</td>
<td>Specifies the number of OCP assertions before an interrupt is generated for Class G. </td>
</tr>
<tr>
<td>13:5</td>
<td>OCP length for rcv</td>
<td>RW</td>
<td>0x7</td>
<td>Specifies the number of 32KHz cycles of RCV OCP assertion before ocp_rst is automatically generated.</td>
</tr>
<tr>
<td>4:0</td>
<td>OCP  occurance times before interrupt for rcv</td>
<td>RW</td>
<td>0x2</td>
<td>Specifies the number of OCP assertions before an interrupt is generated for RCV.</td>
</tr>
</tbody>
</table>

#### AUD_DET_CLK_DIV REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xE8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:16</td>
<td>hok_deb_div</td>
<td>RW</td>
<td>0xFF</td>
<td>hok_deb_div  </td>
</tr>
<tr>
<td>15:12</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:0</td>
<td>plg_deb_div</td>
<td>RW</td>
<td>0xFF</td>
<td>plg_deb_div  </td>
</tr>
</tbody>
</table>

#### AUD_INT_MSK REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xF0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>Interrupt mask for aud_ocpgr_int, aud_ocpgl_int, aud_ocpab_int</td>
<td>RW</td>
<td>0x0</td>
<td>0: Enable interrupt<br/>1: Disable interrupt</td>
</tr>
<tr>
<td>1</td>
<td>Interrupt mask for plugin/plugout</td>
<td>RW</td>
<td>0x0</td>
<td>0: Enable interrupt<br/>1: Disable interrupt</td>
</tr>
<tr>
<td>0</td>
<td>hook_key_int_msk</td>
<td>RW</td>
<td>0x0</td>
<td>0: Enable interrupt<br/>1: Disable interrupt</td>
</tr>
</tbody>
</table>

### AUD_MCUSYSCTRL Registers

> **Note.** Base address = **0xC0880000**

#### SHUBSSP0_CLK_RES_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x28</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:19</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>18:8</td>
<td>shubssp0 clk div</td>
<td>RW</td>
<td>0x0</td>
<td>Clock divider for SHub SSP0: <br/>fclk = source_clk / (shubssp0_fclk_div + 1)</td>
</tr>
<tr>
<td>7:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:4</td>
<td>shubssp0 fclk sel</td>
<td>RW</td>
<td>0x0</td>
<td>Select the SHub SSP0 frequency clock:<br/>00: clk_62m<br/>01: clk_24p576m<br/>10: clk_13m<br/>11: clk_3p25m</td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>shubssp0 pclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for SHub SSP0 peripheral clock (pclk)<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>1</td>
<td>shubssp0 fclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for SHub SSP0 frequency clock (fclk)<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>0</td>
<td>shubssp0 reset Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for SHub SSP0 reset<br/>0: Disable<br/>1: Enable </td>
</tr>
</tbody>
</table>

#### SHUBI2C0_CLK_RES_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x30</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:19</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>18:8</td>
<td>shubi2c0 clk div</td>
<td>RW</td>
<td>0x0</td>
<td>Clock divider for SHub I²C0: <br/>fclk= source_clk/(shubi2c0_fclk_div + 1)  </td>
</tr>
<tr>
<td>7:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:4</td>
<td>shubi2c0 fclk sel</td>
<td>RW</td>
<td>0x0</td>
<td>Select the SHub I²C0 frequency clock:<br/>00: clk_62m<br/>01: clk_26m<br/>10: clk_13m<br/>11: clk_3p25m</td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>shubi2c0 pclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for SHub I²C0 peripheral clock (pclk)<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>1</td>
<td>shubi2c0 fclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for SHub I²C0 frequency clock (fclk)<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>0</td>
<td>shubi2c0 reset Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for SHub I²C0 reset<br/>0: Disable<br/>1: Enable</td>
</tr>
</tbody>
</table>

#### UART1_CLK_RES_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x3C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:19</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>18:8</td>
<td>uart clk div</td>
<td>RW</td>
<td>0x0</td>
<td>UART clock divider: <br/>fclk = source_clk / (uart_fclk_div + 1)</td>
</tr>
<tr>
<td>7:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:4</td>
<td>uart fclk sel</td>
<td>RW</td>
<td>0x0</td>
<td>Select the UART frequency clock:<br/>00: clk_62m<br/>01: clk_26m<br/>10: clk_13m<br/>11: clk_3p25m</td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>uart pclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for UART peripheral clock (pclk)<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>1</td>
<td>uart fclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for UART frequency clock (fclk)<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>0</td>
<td>uart reset Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for UART reset<br/>0: Disable<br/>1: Enable</td>
</tr>
</tbody>
</table>

#### R_CAN_CLK_RES_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x48</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:19</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>18:8</td>
<td>CAN clk div</td>
<td>RW</td>
<td>0x0</td>
<td>CAN clock divider:   <br/>fclk= source_clk/(shubi2c1_fclk_div + 1)  </td>
</tr>
<tr>
<td>7:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:4</td>
<td>CAN fclk sel</td>
<td>RW</td>
<td>0x0</td>
<td>Select the CAN frequency clock <br/>00: clk_62m  <br/>01: clk_26m  <br/>10: clk_13m  <br/>11: clk_3p25m </td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>CAN pclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for CAN peripheral clock (pclk)   <br/>0 = disable 1 = enable  </td>
</tr>
<tr>
<td>1</td>
<td>CAN fclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for CAN frequency clock (fclk)   <br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>0</td>
<td>CAN reset Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for CAN reset  <br/>0: Disable<br/>1: Enable</td>
</tr>
</tbody>
</table>

#### R_R_IR_CLK_RES_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:19</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>18:8</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:4</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>R_IR pclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for R_IR peripheral clock (pclk)<br/>0: Disable<br/>1: Enable  </td>
</tr>
<tr>
<td>1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>R_IR reset Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for R_IR reset   <br/>0: Disable<br/>1: Enable</td>
</tr>
</tbody>
</table>

#### DDR_REMAP_BASE REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>ddr_remap_base</td>
<td>RW</td>
<td>0x0</td>
<td>Base address for STAR core to access DDR. <br/>- Memory space: 0x30000000 - 0x3FFFFFFF <br/>- Remaps to DDR address range: ddr_remap_base + 0x0 to ddr_remap_base + 0x0FFFFFFF.</td>
</tr>
</tbody>
</table>

#### UART0_CLK_RES_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:19</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>18:8</td>
<td>uart clk div</td>
<td>RW</td>
<td>0x0</td>
<td>UART Clock Divider:<br/>fclk= source_clk/(shubi2c1_fclk_div + 1)  </td>
</tr>
<tr>
<td>7:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:4</td>
<td>uart fclk sel</td>
<td>RW</td>
<td>0x0</td>
<td>Select UART frequency clock (fclk)<br/>00: clk_62m  <br/>01: clk_26m  <br/>10: clk_13m  <br/>11: clk_3p25m </td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>uart pclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for UART peripheral clock (pclk) <br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>1</td>
<td>uart fclk Enable/Disable</td>
<td>RW</td>
<td>0x0</td>
<td>Enable bit for UART frequency clock (fclk)<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>0</td>
<td>uart reset Enable/Disable</td>
<td>RW</td>
<td>0x0<br/></td>
<td>Enable bit for UART reset<br/>0: Disable<br/>1: Enable</td>
</tr>
</tbody>
</table>

### AUD_AUDCLOCK Registers

> **Note.** Base address = **0xC0882000**

#### AUDIO_CODEC_TX_RX_CLK_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x14</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:18</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17:16</td>
<td>sspa_func_clk_source_sel</td>
<td>RW</td>
<td>0x0</td>
<td>Select SSPA function clock source  <br/>0: SSPA_FCLK_SRC = 245.76M  <br/>1: SSPA_FCLK_SRC = 24.576M </td>
</tr>
<tr>
<td>15</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14:4</td>
<td>sspa_func_clk_div</td>
<td>RW</td>
<td>0x9f</td>
<td>SSPA function clock divider  <br/>SSPA_FCLK = SSPA_FCLK_SRC/(SSPA_FCLK_DIV+1) </td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>sspa_func_clk_en</td>
<td>RW</td>
<td>0x0</td>
<td>0: SSPA function clock gated  <br/>1: SSPA function clock open </td>
</tr>
<tr>
<td>1</td>
<td>tx_rx_bus_clk_en</td>
<td>RW</td>
<td>0x0</td>
<td>0: bus clock gated  <br/>1: bus clock open </td>
</tr>
<tr>
<td>0</td>
<td>tx_rx_sw_rstn</td>
<td>RW</td>
<td>0x0</td>
<td>Reset control for audio SSPA and ADMA  <br/>0: Reset  <br/>1: Release reset </td>
</tr>
</tbody>
</table>

#### AUDIO_DFE_CLK_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5</td>
<td>dfe_sw_reset</td>
<td>RW</td>
<td>0x0</td>
<td>0: Reset  <br/>1: Release reset </td>
</tr>
<tr>
<td>4</td>
<td>dfe_func_clk_enable</td>
<td>RW</td>
<td>0x0</td>
<td>0: Disble  <br/>1: Enable </td>
</tr>
<tr>
<td>3</td>
<td>dac_sw_reset</td>
<td>RW</td>
<td>0x0</td>
<td>0: Reset  <br/>1: Release reset </td>
</tr>
<tr>
<td>2</td>
<td>dac_clk_inv_en</td>
<td>RW</td>
<td>0x0</td>
<td>DAC clock can use the original clock from analog or the invert clock   <br/>0: DAC uses the original clock  <br/>1: DAC uses the invert clock </td>
</tr>
<tr>
<td>1</td>
<td>adc_sw_reset</td>
<td>RW</td>
<td>0x0</td>
<td>0: Reset  <br/>1: Release reset </td>
</tr>
<tr>
<td>0</td>
<td>adc_clk_inv_en</td>
<td>RW</td>
<td>0x0</td>
<td>ADC clock can use the original clock from analog or the invert clock   <br/>0: ADC uses the original clock  <br/>1: ADC uses the invert clock </td>
</tr>
</tbody>
</table>

#### AUDIO_I2S1_TX_RX_CLK_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x40</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:18</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17:16</td>
<td>sspa_func_clk_source_sel</td>
<td>RW</td>
<td>0x0</td>
<td>SSPA function clock source  <br/>0: SSPA_FCLK_SRC = 245.76M  <br/>1: SSPA_FCLK_SRC = 24.576M </td>
</tr>
<tr>
<td>15</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14:4</td>
<td>sspa_func_clk_div</td>
<td>RW</td>
<td>0x9f</td>
<td>SSPA function clock divider  <br/>SSPA_FCLK = SSPA_FCLK_SRC/(SSPA_FCLK_DIV+1) </td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>sspa_func_clk_en</td>
<td>RW</td>
<td>0x0</td>
<td>0: SSPA function clock gated  <br/>1: SSPA function clock open </td>
</tr>
<tr>
<td>1</td>
<td>tx_rx_bus_clk_en</td>
<td>RW</td>
<td>0x0</td>
<td>0: Bus clock gated  <br/>1: Bus clock open </td>
</tr>
<tr>
<td>0</td>
<td>tx_rx_sw_rstn</td>
<td>RW</td>
<td>0x0</td>
<td>Reset control for audio SSPA and ADMA<br/>0: Reset  <br/>1: Release reset </td>
</tr>
</tbody>
</table>

#### AUDIO_HDMI_CLK_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x44</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:18</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17:16</td>
<td>sspa_func_clk_source_sel</td>
<td>RW</td>
<td>0x0</td>
<td>SSPA function clock source  <br/>0: SSPA_FCLK_SRC = 245.76M  <br/>1: SSPA_FCLK_SRC = 24.576M </td>
</tr>
<tr>
<td>15</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14:4</td>
<td>sspa_func_clk_div</td>
<td>RW</td>
<td>0x9f</td>
<td>SSPA function clock divider  <br/>SSPA_FCLK = SSPA_FCLK_SRC/( SSPA_FCLK_DIV+1) </td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>sspa_func_clk_en</td>
<td>RW</td>
<td>0x0</td>
<td>0: SSPA function clock gated  <br/>1: SSPA function clock open </td>
</tr>
<tr>
<td>1</td>
<td>tx_rx_bus_clk_en</td>
<td>RW</td>
<td>0x0</td>
<td>0: Bus clock gated  <br/>1: Bus clock open </td>
</tr>
<tr>
<td>0</td>
<td>tx_rx_sw_rstn</td>
<td>RW</td>
<td>0x0</td>
<td>Reset control for audio SSPA and ADMA  <br/>0: Reset  <br/>1: Release reset </td>
</tr>
</tbody>
</table>

#### AUDIO_I2S0_TX_RX_CLK_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x60</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:18</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17:16</td>
<td>sspa_func_clk_source_sel</td>
<td>RW</td>
<td>0x0</td>
<td>SSPA function clock source  <br/>0: SSPA_FCLK_SRC = 245.76M  <br/>1: SSPA_FCLK_SRC = 24.576M </td>
</tr>
<tr>
<td>15</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14:4</td>
<td>sspa_func_clk_div</td>
<td>RW</td>
<td>0x9f</td>
<td>SSPA function clock divider  <br/>SSPA_FCLK = SSPA_FCLK_SRC/( SSPA_FCLK_DIV+1) </td>
</tr>
<tr>
<td>3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>sspa_func_clk_en</td>
<td>RW</td>
<td>0x0</td>
<td>0: SSPA function clock gated  <br/>1: SSPA function clock open </td>
</tr>
<tr>
<td>1</td>
<td>tx_rx_bus_clk_en</td>
<td>RW</td>
<td>0x0</td>
<td>0: Bus clock gated  <br/>1: Bus clock open </td>
</tr>
<tr>
<td>0</td>
<td>tx_rx_sw_rstn</td>
<td>RW</td>
<td>0x0</td>
<td>Reset control for audio SSPA and ADMA  <br/>0: Reset  <br/>1: Release reset </td>
</tr>
</tbody>
</table>

### AUD_AHBDMA Registers

> **Note.** Base address = **0xC0884000**

#### DMA_DCR REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>DMA Access Mode</td>
<td>RW</td>
<td>0x0</td>
<td>0: Privileged access  <br/>1: User access </td>
</tr>
<tr>
<td>1</td>
<td>DMA Soft Reset</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No effect  <br/>1: Generates a 3-cycle reset pulse </td>
</tr>
<tr>
<td>0</td>
<td>DMA Enable</td>
<td>RW</td>
<td>0x0</td>
<td>0: DMA disable  <br/>1: DMA enable </td>
</tr>
</tbody>
</table>

#### DMA_SR REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15</td>
<td>CH15 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>14</td>
<td>CH14 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>13</td>
<td>CH13 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>12</td>
<td>CH12 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>11</td>
<td>CH11 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>10</td>
<td>CH10 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>9</td>
<td>CH9 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>8</td>
<td>CH8 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>7</td>
<td>CH7 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>6</td>
<td>CH6 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>5</td>
<td>CH5 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>4</td>
<td>CH4 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>3</td>
<td>CH3 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>2</td>
<td>CH2 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>1</td>
<td>CH1 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
<tr>
<td>0</td>
<td>CH0 Int pending</td>
<td>W1C</td>
<td>0x0</td>
<td>0: No interrupt<br/>1: Interrupt is pending<br/>Writing 1 clears the interrupt.</td>
</tr>
</tbody>
</table>

#### DMA_DIMR REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:0</td>
<td>Channel n Interrupt Mask</td>
<td>RW</td>
<td>0xFFFF</td>
<td>Channel n (15 ~ 0) <br/>0: Enables interrupts  <br/>1: Disables interrupts </td>
</tr>
</tbody>
</table>

#### DMA_SARN REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x080+0x40*n</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Source Address</td>
<td>RW</td>
<td>0x0</td>
<td>This register holds the source address from where data is read during a DMA transfer. <br/>DMA does not perform <strong>misaligned accesses</strong>. The alignment behavior depends on the transfer size:<br/>- For <strong>32-bit transfers</strong>, the <strong>lower two bits</strong> of the address are ignored<br/>- For <strong>8-bit transfers</strong>, begin from the exact address specified<br/>> <strong>Note</strong><strong>.</strong><strong> </strong>Software must ensure proper alignment, particularly in systems that do not support non-word-aligned accesses.</td>
</tr>
</tbody>
</table>

#### DMA_DARN REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x084+0x40*n</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Destination Address</td>
<td>RW</td>
<td>0x0</td>
<td>This register holds the destination address from where data is read during a DMA transfer. <br/>DMA does not perform <strong>misaligned accesses</strong>. The alignment behavior depends on the transfer size:<br/>- For <strong>32-bit transfers</strong>, the <strong>lower two bits</strong> of the address are ignored<br/>- For <strong>8-bit transfers</strong>, begin from the exact address specified<br/>> <strong>Note</strong><strong>.</strong> Software must ensure proper alignment, particularly in systems that do not support non-word-aligned accesses.</td>
</tr>
</tbody>
</table>

#### DMA_CNTRN REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x088+0x40*n</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:0</td>
<td>Count</td>
<td>RW</td>
<td>0x0</td>
<td>Contains the number of bytes of data to be transferred during a DMA cycle. </td>
</tr>
</tbody>
</table>

#### DMA_CCRN REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x08c+0x40*n</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:14</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>13:12</td>
<td>Destination Mode</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the destination transfer mode             <br/>0x0: Memory              <br/>0x2: FIFO               <br/>0x1/0x3: Reserved  </td>
</tr>
<tr>
<td>11:10</td>
<td>Source Mode</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the destination transfer mode<br/>0x0: Memory              <br/>0x2: FIFO               <br/>0x1/0x3: Reserved          </td>
</tr>
<tr>
<td>9:8</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7:6</td>
<td>Destination Size</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the destination size of a data transfer.<br/>If the number of bytes to be written is less than the DSIZ setting, only that many bytes will be valid in the DMA write cycle to AHB. However, all DMA write cycles to the destination will be of DSIZ size. DMA always writes data as per DSIZ in all modes.<br/>00: 32-bit destination port<br/>01: 8-bit destination port<br/>10: 16-bit destination port<br/>11: Reserved</td>
</tr>
<tr>
<td>5:4</td>
<td>Source Size</td>
<td>RW</td>
<td>0x0</td>
<td>Selects the source size of a data transfer.<br/>If the number of bytes to be read is less than the SSIZ setting, only that many bytes will be used by the DMA. However, all DMA read cycles to the source will be of SSIZ size.<br/>00: 32-bit source port<br/>01: 8-bit source port<br/>10: 16-bit source port<br/>11: Reserved</td>
</tr>
<tr>
<td>3</td>
<td>Request Enable</td>
<td>RW</td>
<td>0x0</td>
<td>Enables or disables the DMA request signal.<br/>- When REN is set, DMA burst is initiated by the dma_req signal from the I/O FIFO.<br/>- When REN is cleared, DMA transfer is initiated by CEN (Channel Enable).<br/>0: Disables the DMA request signal (when the peripheral asserts a DMA request, no DMA transfer is triggered).<br/>1: Enables the DMA request signal (when the peripheral asserts a DMA request, a DMA transfer is triggered).</td>
</tr>
<tr>
<td>2:1</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>DMA Channel Enable</td>
<td>RW</td>
<td>0x0</td>
<td>> <strong>Note</strong><strong>.</strong> Disabling CEN during an ongoing burst on the AHB will stop the burst in the middle of the transfer.<br/>0: Disables the DMA channel<br/>1: Enables the DMA channel</td>
</tr>
</tbody>
</table>

#### DMA_RSSRN REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x090+0x40*n</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:0</td>
<td>Request Source Select</td>
<td>RW</td>
<td>0x0</td>
<td>Selects 1 of the 64 dma_req signals that initiates DMA transfer cycle for the channel.  <br/>000000: Select dma_req[0]  <br/>000001: Select dma_req [1]  <br/>...  <br/>011111: Select dma_req [31]  <br/>....  <br/>111111: Select dma_req [63] </td>
</tr>
</tbody>
</table>

#### DMA_BLRN REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x094+0x40*n</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:6</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:0</td>
<td>Burst Length</td>
<td>RW</td>
<td>0x0</td>
<td>Contains the number of data bytes that are transferred in a DMA burst.  <br/>000000: 64 bytes read follow 64 bytes write  <br/>000001: 1 byte read follow 1 byte write  <br/>000010: 2 bytes read follow 2 bytes write  <br/>....  <br/>111111: 63 bytes read follow 63 bytes write </td>
</tr>
</tbody>
</table>

#### DMA_TRSF_CNT REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x09c+0x40*n</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:0</td>
<td>TRSF_CNT</td>
<td>RO</td>
<td>0x0</td>
<td>Indicates the number of bytes transferred for the channel   </td>
</tr>
</tbody>
</table>

#### DMA_BTYPE REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0a0+0x40*n</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:2</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1:0</td>
<td>Burst Type</td>
<td>RW</td>
<td>0x0</td>
<td>0x0: INCR<br/>0x2: INCR4<br/>0x3: INCR8<br/>0x4: INCR16                            </td>
</tr>
</tbody>
</table>

### PWM Registers

> **Note.** Base address of PWMn (n = 1, 2, ... 20) is **0xD401A000** with a stride of **0x400**

#### PWM_CRX REGISTER

PWM Control register. This register control the behavior of the PWM module, including:

- Shutdown response configuration
- Clock divisor settings by adjusting the input clock frequency to the PWM control unit which determines the frequency of the scaled counter clock.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0+(n-1)*0x400</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:9</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>8</td>
<td>PWM_OUTCNTen</td>
<td>RW</td>
<td>0x0</td>
<td>PWM Output Counter Register enable<br/>0: Disable<br/>1: Enable</td>
</tr>
<tr>
<td>7</td>
<td>Reserved</td>
<td>RO</td>
<td>0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>6</td>
<td>Pulse Width Modulator Shutdown Mode</td>
<td>RW</td>
<td>0x0</td>
<td>0: Graceful shutdown of PWM when the SoC stops the clock to the PWM.<br/>1: Abrupt shutdown of PWM when the SoC stops the clocks to the PWM.</td>
</tr>
<tr>
<td>5:0</td>
<td>Prescale</td>
<td>RW</td>
<td>0x0</td>
<td>The scaled counter clock frequency is: <br/>Frequency = PSCLK_PWM / (PRESCALE + 1)</td>
</tr>
</tbody>
</table>

#### PWM_DCR REGISTER

PWM Duty Cycle register. This register configures the duty cycle of the corresponding PWM output signals (PWM_OUT).

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4+(n-1)*0x400</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:11</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>10</td>
<td>Full Duty Cycle</td>
<td>RW</td>
<td>0x0</td>
<td>0: The PWM output signal (PWM_OUT) is determined by the &lt;Duty Cycle of PWM_OUT&gt; value.<br/>1: The PWM output signal (PWM_OUT) is continuously asserted (i.e., it remains high).</td>
</tr>
<tr>
<td>9:0</td>
<td>Duty Cycle of PWM_OUT<br/></td>
<td>RW</td>
<td>0x0</td>
<td>Defines the active high period of PWM_OUT:<br/>0: The PWM output signal (PWM_OUT) is continuously de-asserted (i.e., it remains low).<br/>1: The PWM output signal (PWM_OUT) is high for a specific duration with the calculation formula:<br/>High Time = (&lt;PRESCALE&gt; + 1) * (1 / 12.8 MHz), where &lt;PRESCALE&gt; is a field in the PWM Control Registers <br/>> <strong>Note</strong><strong>.</strong> If &lt;Full Duty Cycle&gt; is set to <strong>1</strong>, this filed has no effect on the output of PWM.</td>
</tr>
</tbody>
</table>

#### PWM_PCR REGISTER

PWM Period Control register. This register is used to configure the cycle time of the corresponding PWM_OUT signals. When this register is set to zero (cleared), the PWM output signal (PWM_OUT) will stay in a high state.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x8+(n-1)*0x400</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:10</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>9:0</td>
<td>Period Value</td>
<td>RW</td>
<td>0x4</td>
<td>Defines the the cycle time of the PWM_OUT signal.<br/>- The value written to this field specifies the number of scaled clock cycles per PWM cycle, plus one.<br/>- Formula:<br/>PWM Cycle Time = (<strong>Period Value+ 1</strong>) × (1 / Scaled Clock Frequency)<br/>> <strong>Note</strong><strong>. </strong>Writing all zeros to this field, causes the PWM_OUT signal to remain high continuously.</td>
</tr>
</tbody>
</table>

#### PWM_OUTCNT REGISTER

PWM Output Counter register.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x10+(n-1)*0x400</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>15:0</td>
<td>Counter Value</td>
<td>RW</td>
<td>0x0</td>
<td>Specifies the value of PWM out pulse number.</td>
</tr>
</tbody>
</table>
