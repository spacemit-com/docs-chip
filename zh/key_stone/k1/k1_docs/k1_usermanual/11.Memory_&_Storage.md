# 11. Memory & Storage

```
Last Version: 2025/11/18
```

## 11.1 Overview

K1 supports on-chip memory and various peripheral interfaces connecting to different memory devices such as DDR and NAND/NOR Flash.

## 11.2 On-Chip Memory

### Introduction

K1 includes the following on-chip memory types.

- 128KB boot-ROM
- 256KB SRAM shared by Main CPU and Real CPU

## 11.3 DDR

### Introduction

The DDR controller features a cutting-edge design that optimizes DRAM access by rearranging requests into an efficient order, rather than processing them in their original sequence. It uses re-ordering buffers (ROBs) to reorganize accesses to the SRAM device for improving performance, while maintaining the original transaction order for requests with the same ID on the AXI interface.

Additionally, the DDR controller includes a unified write pool to temporarily store write transactions. Such write pool minimizes write latency and reduces the performance penalty due to switching between read and write operation at the DRAM interface. With a built-in heuristic write buffer control and user-programmable write buffer control, the DDR controller dynamically balances read and write operation performance in real-time.

The DDR controller is also designed to support AMBA AXI4 bus protocols. It is fully scalable and supports up to 4 AXI ports.

The architecture of the DDR controller interface is depicted below.

![](static/DDR_controller.png)

### Features

- Priority-based arbitration with a starvation prevention scheme
- Merge of write operations to the same address by using a write buffer to reduce DDR write operation traffic
- Direct forward of read operations of the write buffer to the ROB without accessing DDR
- Two levels dynamic scheduling with bandwidth guarantee
- Support for power-saving features, including active/pre-charge power-off and self-refresh, with control options available automatically (via idle timer), manually (through registers) or externally (via dedicated ports)
- Support for dynamic frequency change
- Support for JEDEC compliant LPDDR3 and LPDDR4 devices
- Support for DRAM size from 64MB to 16GB
- One DRAM channel with a x32 DDR PHY, programmable by software to support x32, x16 or x8 data width
- Support for x16, x32 DRAM devices (1 DQS per 8 DQ)
- Support for up to 2 Chip Select (CS) or Rank per channel
- Support for up to 8 banks per CS for LPDDRx
- Each CS can be mapped to a different starting address
- Each CS can be programmed for 8MB to 16GB
- DRAM banks can be kept open after access (no auto-pre-charge)
- Support for burst length of 8 and 16 for the applicable DDR type
- Programmable address order
- Flexible bank placement between CS and data width
- Implementation of memory controller performance counters
- Global monitors for RISC-V exclusive load/store access
- Secure access management for DDR transactions
- Frequency change register update: implementation of a register table for hardware-triggered sequence update after frequency changes

### Functional Description

#### DDR Controller Ports Allocation

The DDR Controller supports 4 AXI slave ports with arbitration among them. Details about the port connections to the DDR Controller are tabled below.

<table>
<tbody>
<tr>
<td><strong>Port0</strong></td>
<td><strong>Port1</strong></td>
<td><strong>Port2</strong></td>
<td><strong>Port3</strong></td>
</tr>
<tr>
<td>RISCV X60 Clusters and GPU</td>
<td>GMAC0, GMAC1 and<br/>AXI Fabric1 Port</td>
<td>VPU and PCIE PortA/B/C</td>
<td>Display and ISP</td>
</tr>
</tbody>
</table>

#### Dynamic Schedulin

The DDR Controller uses a priority-based arbitration with a starvation prevention scheme to manage the latency of important accesses.

The DDR Controller schedules transactions based on

- Current DRAM page status
- Transaction priority, determined by the AxQoS[2:0] signals on the AXI interface

The AxQoS are decoded as

- b100: CRITICAL
- b011: TOP
- b010: HIGH
- b001: MED (Guaranteed Bandwidth Feature)
- b000: LOW

The DDR controller can interleave between banks to achieve 100% bus utilization for streaming transactions to different banks, effectively hiding the precharge and activate overheads between read and write commands.

A CRITICAL priority transaction is always served as quickly as possible. It does not check the DRAM page status and is the next transaction to be processed. However, if there are multiple CRITICAL priority transactions, the page status will be considered.

Transactions are served when no higher priority transactions are pending. If lower priority transactions are directed to an already open page, the current higher priority transaction will close that page first.

#### Starvation Prevention

An aging mechanism increases the priority of a transaction when its counter expires to prevent starvation. The starvation counter values for the reading pool and scheduling pool can be configured in the following registers:

- RPP Starvation Control Register (RPP_Starvation_Control)
- Spool Control Register (Spool_Control)

#### Scheduling Algorithm

Scheduling algorithm is implemented in DDR Controller to grant different weights to the following events:

- DRAM pages status regarding to this transaction, it depends on if

  - Page is open
  - Page is closed
  - Page is missing (it is open on another page)
- CS
- Same CS
- Different CS

The scheduler allows out-of-order DRAM execution by re-ordering of data to fit with AXI ordering model. The scheduler would make a decision based on both the queue status and bank status to utilize the DDR bus bandwidth at most.

#### Ports Arbitration

When multi-ports configuration is used, DDR controller uses AXI QoS signal to arbitrate between different AXI ports. If ports have the same QoS priority, then a round-robin arbitration scheme is used.

#### Power-Down Mode

Power-down mode deactivates most I/O buffers on the DRAM module, in particular:

- **Precharge Power-Down**
  Occurs when all banks are closed. If any banks are open, a precharge-all command is issued before entering this mode.

- **Active Power-Down**
  Occurs when at least one bank remains open. If all banks are already closed, an active power-down request behaves as a precharge power-down.

Precharge power-down saves more power than active power-down but closes all banks upon exit, which may reduce performance.

The power-down duration is limited by the auto-refresh interval. If no data requests are pending, the DDR Memory Controller will wake up the DRAM, perform an auto-refresh, and re-enter power-down mode.

For DDR3, there is an option to select fast-exit or slow-exit power-down, which determines whether the DRAM DLL remains active or is frozen during power-down.

#### Self-Refresh Mode

In self-refresh mode, the DRAM automatically refreshes its banks, in particular:

- Within a refresh period, precharge power-down and self-refresh provide similar power savings, but self-refresh has a longer exit delay. Over extended periods, self-refresh is more efficient since precharge power-down requires periodic wake-ups and auto-refresh commands.
- LPDDR and DDR3 support Partial-Array Self-Refresh (PASR), which controls how many banks are refreshed during self-refresh. Each chip-select has a separate PASR configuration in the SDRAM Configuration Register.
- Since PASR allows certain banks to remain unrefreshed, software must track memory usage to prevent data loss in unrefreshed banks.

#### Automatic Clock-Stop

LPDDR allows the DRAM clock to be stopped when there is no pending DRAM operations.

Automatic Clock Stop (ACS) operates separately and can be used alongside other power-saving modes.

#### Power Saving Control

The DDR Memory Controller supports all power-saving features such as clock stop, pre-charge power-down, active power-down, self-refresh and deep power-down.

Power-saving commands can be issued in three ways as follows:

- **External control**
- **Manual issue**
- **Automatic issue**

Power-saving commands can be manually triggered through the User-Initiated Command Register, with each request executed only once. A new request will wake the Memory Controller from its current power-saving mode.

The Memory Controller can also enter a power-saving state (active or precharge power-down) automatically after a set number of idle cycles. However, deep power-down must be entered manually since it shuts off power to the memory array, causing a reset.

#### Dynamic Frequency Change (DFC)

DDR frequency change can be achieved by either hardware (boundary pin handshake) or software (AHB programming), in particular:

- **Hardware DFC**

  - The system must preload a DFC table (a predefined frequency sequence) into SRAM. Each table corresponds to a specific target frequency (e.g. Table 1 for 800MHz, Table 2 for 300MHz).
  - To change frequency, the SoC PMU drives the boundary pin and selects a DFC table. The Memory Controller then executes the DFC sequence automatically and signals the PMU when it is safe to switch clocks and when the process is complete.

- **Software DFC**

  - The DFC sequence is initiated by programming Memory Controller registers, without using SRAM
  - Software must execute the sequence step by step and poll for completion

## 11.4 QSPI Flash

### Introduction

Quad-SPI acts as an interface to external serial flash devices with up to four bidirectional data lines.

### Features

- Flexible sequence engine to support various flash vendor devices
- Single, dual and quad mode operation
- DMA supports reading RX buffer data via AMBA AHB bus (64-bit width interface) or IP register space (32-bit access), and filling TX buffer via IP register space (32-bit access)
- Configurable DMA inner loop size
- Fifteen interrupt conditions
- Memory-mapped read access for connected flash devices
- Programmable sequence engine for future command/protocol changes, and able to support all existing vendor commands and operations
- Support for all types of addressing
- Support for standard SPI, Fast, Dual, Dual I/O, Quad, Quad I/O mode
- Operation up to 104MHz clock frequency

### Functional Description

The QSPI block diagram is depicted below, where

- AHB BUS is used for XIP transfer (not used in current design)
- APB BUS is used to configure registers and write/read/erase external serial flash.

![](static/QSPI_block_diagram.png)

The different phases of the serial flash access scheme are depicted below.

![](static/serial_flash.png)

The different phases and the I/O driving characteristics of the QuadSPI module are characterized in the following way:

- **IDLE**
  Serial flash device is not selected, and there is no interaction. All QSPI_DATx signals remain undriven.

- **INSTRUCTION**
  Serial flash device is selected. And the instruction is sent to the serial flash device.

- **ADDRESS**
  Serial Flash Address is sent to the device.

  > **Note.** This phase is not applicable for all SFM Commands.

- **MODE**
  Mode bytes are sent to the serial flash device, and all QSPI_DATx signals are driven.

  > **Note.** This phase is not applicable for all SFM Commands.

- **DUMMY**
  Dummy clocks are provided to the serial flash device.

  > **Note.** This phase is not applicable for all SFM Commands.

- **DATA**
  Serial flash data is sent to or received from the serial flash device.

  > **Note.** This phase is not applicable for all SFM Commands.

QSPI_CS and QSPI_CLK signals are driven permanently throughout all phases.

## 11.5 SD/eMMC

### Introduction

The SD/eMMC Host Controller is a hardware block that acts as a host of the SD/eMMC interface to transfer data between MMC, SDIO, SD cards and the internal bus master.

### Features

- Compliance with MMC/eMMC 5.1 specification with support for socket 3 (eMMC)
- Support for PIO mode and SDMA mode data transfer
- Support for ADMA1 and ADMA 2 (64-bit addressing) data transfer
- Support for 1-bit/4-bit SD memory and SDIO
- Support for 1-bit/8-bit MMC and CE-ATA cards
- Support for SPI mode for eMMC card
- The following modes are supported for the eMMC device:

  - Legacy (up to 26MB/s, 1.8V signal)
  - High-speed SDR (up to 52MB/s, 1.8V signal)
  - High-speed DDR (up to 52MB/s, 1.8V signal)
  - HS200 (up to 200MB/s, 1.8V signal)
  - HS400 (up to 400MB/s, 1.8V signal)
- The following modes are supported for the SD device:

  - Default Speed (up to 12.5MB/s, 3.3V signal)
  - High Speed (up to 25MB/s, 3.3V signal)
  - SDR12 (up to 25 MHz, 1.8V signal)
  - SDR25 (up to 50 MHz, 1.8V signal)
  - SDR50 (up to 100 MHz, 1.8V signal)
  - SDR104 (up to 208 MHz, 1.8V signal)
  - DDR50 (up to 50 MHz, 1.8V signal)
- Support for read-wait control in SDIO cards
- Support for suspend resume in SDIO cards
- Hardware generation/checking of CRC on all command and data transaction on the card bus
- Card insertion/removal detection for sockets 1 (SD)

> **Note.** For more information about AXI Fabric Specification, please check the description below:
>
> - SD AXI master always generates an INCR (AWBURST/ARBURST = 0x1) burst and 8-bytes burst size (AWSIZE/ARSIZE = 0x3)
> - SD AXI master bursts are normal, non-secure data accesses (AWPROT/ARPROT = 0x2)
> - SD AXI master never generates atomic accesses (AWLOCK/ARLOCK = 0x0)
> - SD AXI slave does not support exclusive, protected or atomic accesses. The response signaling is always “OKAY” (RRESP/BRESP = 0x0) or “DECERR” (RRESP/BRESP = 0x2). The “DECERR” response is signaled if an address is accessed where no registers exist.

### Functional Description

#### Block Diagram

The architecture of SD/eMMC Host Controller is depicted below.

![](static/SD/eMMC_Host_Controller.png)

To be highlighted:

- The system fabric connects through two AXI interfaces:

  - AXI Slave
  - AXI Master
- AHB Slave is used for configuring registers and handling read/write operations in PIO mode
- AHB Master manages data transmission in SDMA/ADMA mode
- A 128 × 64-bit FIFO stores up to two 512-byte packets for data buffering
- Configuration registers synchronize with the SD/eMMC clock domain via a synchronizer to configure the clock, data width, etc.
- Card insertion/removal is detected through GPIO, triggering an interrupt to notify the CPU

#### SD/eMMC Bus Protocol Description

Communication over the SD bus is based on commands and data bit streams that are initiated by a start bit and terminated by a stop bit as follows:

- **Command**
  A command is a token that starts an operation. It is sent from the host to the card(s) and is transferred serially via the SDCMD line (1 bit).

- **Command Response**
  A command response is a token that is sent from an addressed card to the host as a reply to a previously received host command. It is transferred serially via the SDCMD line since the SDCMD line is a bidirectional signal.

- **Data**
  There are 4 data lines. Data can be transferred from the card to the host or vice versa. Data is transferred via Data line, and they are bidirectional signals. In 1-bit mode, SDDATA[0] is used, and the other is in Z-state.

The basic operations of the SD/eMMC cards are depicted below.

**[No Response & No Data Operations]**

![](static/SD/eMMC_1.png)

**[Multiple Block Read Operation]**

![](static/SD/eMMC_2.png)

**[Multiple Block Write Operation]**

![](static/SD/eMMC_3.png)

#### Special Bus Transactions

##### Read Wait Command

During a Read operation, if the host cannot accept more data, it usually stops the clock to pause the Read data output from the card. However, this also prevents the host from issuing any commands.

To avoid this limitation, a Read Wait command allows the host to pause the Read data while keeping the clock running. This command is issued after the data block ends, ensuring that the host can manage data flow without completely stopping communication.

The Read Wait Controlled by Stopping Clock is depicted below.

![](static/Stopping_Clock.png)

##### Packet Format

The formats of commands from the host and responses from cards are depicted below.

**[Command Token Format]**

![](static/ommands_card.png)

**[Response Token Format]**

![](static/ommands_card_1.png)

##### Sequences of Host & Card Interaction

SD cards are connected to the host with a dedicated interface, such as its own SDCLK, SDCMD, or SDDATA[3:0] lines.

After a **power-on reset, software reset or new card insertion**, the host and SD cards go through two phases as follows:

- **Phase 1 - **Card Identification Phase**:

  - The host looks for new cards on the bus
  - While in this phase, the host resets all the cards that are in card identification mode. Any card already identified will not be reset.
  - Then the host:
    - Sends the command to validate operation voltage range
    - Identifies each card and requests its Relative Card Address (RCA)
    - Communicates with each card separately using the **SDCMD line** (in the case of SD memory)
  - All data communication in this phase uses the SDCMD line only

- **Phase 2 - **Data Transfer Phase:**

  - Once all cards are identified, the host enters this phase that is ready to transfer data
  - After the host driver sets up the Host Controller, it starts the transfer by writing to the Command Register which is written last
  - For R1b commands, the Command Inhibit will stay set as long as the busy signal is held low
  - CMD_ COMPLETE will then be set when Command Inhibit changes from 1 to 0

> **Note.** For more information, please refer to SD Host Controller Simplified Specification V3.00

#### Card Detection

The SD/eMMC Host Controller supports card detection (insertion/removal) via the GPIO toggle with software operation.

The card detection features can be accessed though the Normal Interrupt Status Enable bits. When enabled, an interrupt is generated if a logic change is detected on the card-detect switch input. To avoid false triggers, this logic change is debounced before generating an interrupt.

#### SPI Mode

SPI mode is enabled by setting the \<spi_en\> field in the Legacy Register (0x10C). The rest of the flow is similar to the SD flow except for error interrupts.

If an error occurs in SPI mode, then the \<spi_err\> field in the Error Interrupt Status Register will be set. The cause of this error can be identified in the \<spi_err_token\> field in the Legacy Register.

### Register Description

The base addresses of SD/eMMC Host Controller Registers are tabled below.

<table>
<tbody>
<tr>
<td><strong>Name</strong></td>
<td><strong>Address</strong></td>
</tr>
<tr>
<td>SD1_BASE(SD Card)</td>
<td>0xD4280000</td>
</tr>
<tr>
<td>SD2_BASE(SDIO)</td>
<td>0xD4280800</td>
</tr>
<tr>
<td>SD3_BASE(eMMC)</td>
<td>0xD4281000</td>
</tr>
</tbody>
</table>

#### SD_SYS_ADDR REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>DMA_ADDR_H</td>
<td>R/W</td>
<td>0x0000</td>
<td>- DMA Address High: contains 16 MSb of DMA system buffer starting byte address.<br/>- This register is used with the Auto Cmd 23 to set a 32-bit block count value to the argument of cmd23. This register holds the upper 16bits of the cmd23 argument. </td>
</tr>
<tr>
<td>15:0</td>
<td>DMA_ADDR_L</td>
<td>R/W</td>
<td>0x0000</td>
<td>- DMA Address Low: contains 16 LSb of DMA system buffer starting byte address.<br/>- This register is used with the Auto Cmd 23 to set a 32-bit block count value to the argument of cmd23. This register holds the lower 16bits of the cmd23 argument. </td>
</tr>
</tbody>
</table>

#### SD_BLOCK_SIZE_CNT REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>BLOCK_COUNT</td>
<td>R/W</td>
<td>0x0000</td>
<td>Block Count <br/>The Host Controller decrements the block count after each block transfer. <br/>0x1 = 1 block <br/>... <br/>0xFFFF = 65535 blocks <br/>The current value of block count is reflected in the Current Block Count Register.  </td>
</tr>
<tr>
<td>15</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14:12</td>
<td>HOST_DMA_BDRY</td>
<td>R/W</td>
<td>0x0</td>
<td>Host DMA Buffer Boundary <br/>This field specifies the host memory buffer boundary. <br/>If this boundary is crossed, an interrupt (dma_int) is generated. <br/>This interrupt is reflected in &lt;Tx Ready&gt; field of the Normal Interrupt Status Register. <br/>0x0: 4 KB <br/>0x1: 8 KB <br/>0x2: 16 KB <br/>0x3: 32 KB <br/>0x4: 64 KB <br/>0x5: 128 KB <br/>0x6: 256 KB <br/>0x7: 512 KB </td>
</tr>
<tr>
<td>11:0</td>
<td>BLOCK_SIZE</td>
<td>R/W</td>
<td>0x000</td>
<td>Block Size </td>
</tr>
</tbody>
</table>

#### SD_ARG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>ARG_H</td>
<td>R/W</td>
<td>0x0000</td>
<td>Argument High 16 MSb of Command Argument <br/>This value is inserted into 48 bits command token bits[39:24]. </td>
</tr>
<tr>
<td>15:0</td>
<td>ARG_L</td>
<td>R/W</td>
<td>0x0000</td>
<td>Argument Low 16 LSb of Command Argument <br/>This value is inserted into 48 bits command token bits[23:8]. </td>
</tr>
</tbody>
</table>

#### SD_TRANSFER_MODE_CMD REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>29:24</td>
<td>CMD_INDEX</td>
<td>R/W</td>
<td>0x00</td>
<td>Command Index <br/>These bits will be inserted into Command token bits[45:40] </td>
</tr>
<tr>
<td>23:22</td>
<td>CMD_TYPE</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Type <br/>0x0: Normal command <br/>0x1: Suspend command <br/>0x2: Resume command <br/>0x3: Abort command </td>
</tr>
<tr>
<td>21</td>
<td>DATA_PRESENT</td>
<td>R/W</td>
<td>0x0</td>
<td>Data Present <br/>1: Indicates that data is present and will be transferred using the MMC1_DAT[3:0] line. <br/>0: Commands using only MMC1_CMD lines or commands with no data transfer but using busy signal on MMC1_DAT[0] line (for example, CMD 38)  </td>
</tr>
<tr>
<td>20</td>
<td>CMD_INDEX_CHK_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Index Check Enable <br/>1: The Host Controller checks the index field in the response to ensure it matches the command index.<br/>- If there is a mismatch, it is reported as a Command Index Error.</td>
</tr>
<tr>
<td>19</td>
<td>CMD_CRC_CHK_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command CRC Check Enable <br/>1: Host controller checks the CRC field in response. <br/>- If an error is detected, it is reported as a command CRC error. The number of bits checked by the CRC field value changes according to the length of response. </td>
</tr>
<tr>
<td>18</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17:16</td>
<td>RESP_TYPE</td>
<td>R/W</td>
<td>0x0</td>
<td>Response Type Select for SD/SD in SPI Modes For SD mode: <br/>0x0: No response <br/>0x1: Response length is 136 bits <br/>0x2: Response length is 48 bits <br/>0x3: Response length is 48 bits and check busy after response CRC field for R3 and R4 is expected to be all 1 bits. CRC Check should be disabled for these response types.  <br/>For SD in SPI mode: <br/>0x0: Response length is 8 bits <br/>0x1: Response length is 16 bits <br/>0x2: Response length is 40 bits <br/>0x3: Reserved </td>
</tr>
<tr>
<td>15:6</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5</td>
<td>MULTI_BLK_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>Multiple Block Select <br/>This bit should be set to 1 only when multiple blocks are to be transferred. </td>
</tr>
<tr>
<td>4</td>
<td>TO_HOST_DIR</td>
<td>R/W</td>
<td>0x0</td>
<td>Data Transfer Direction Select <br/>This bit defines the direction of the MMC1_DAT[3:0] line data transfer. <br/>1: Transfer data from the SD card to the SD Host Controller, <br/>0: Used for all other commands. </td>
</tr>
<tr>
<td>3:2</td>
<td>AUTO_CMD_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Auto CMD Enable <br/>This field determines use of auto command functions. <br/>0x0: Auto Command disabled <br/>0x1: Auto CMD12 Enable <br/>0x2: Auto CMD23 Enable <br/>0x3: Reserved </td>
</tr>
<tr>
<td>1</td>
<td>BLK_CNT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Block Count Enable <br/>This bit validates the value in the Block Count Register.  </td>
</tr>
<tr>
<td>0</td>
<td>DMA_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>DMA Enable <br/>If Programmed Input/Output (PIO) mode is required, this bit should be reset to 0. </td>
</tr>
</tbody>
</table>

#### SD_RESP_0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x10</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>RESP1</td>
<td>R</td>
<td>0x0000</td>
<td>Response 1 <br/>This register contains bits[39:24] of the response token. </td>
</tr>
<tr>
<td>15:0</td>
<td>RESP0</td>
<td>R</td>
<td>0x0000</td>
<td>Response 0 <br/>This register contains bits[23:8] of the response token. </td>
</tr>
</tbody>
</table>

#### SD_RESP_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x14</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>RESP3</td>
<td>R</td>
<td>0x0000</td>
<td>Response 3 <br/>- For 48-bit response tokens: Not used.<br/>- For 136-bit response tokens: Stores bits [71:56] of the response token.</td>
</tr>
<tr>
<td>15:0</td>
<td>RESP2</td>
<td>R</td>
<td>0x0000</td>
<td>Response 2 <br/>- For 48-bit response tokens: Not used.<br/>- For 136-bit response tokens: Stores bits [55:40] of the response token.</td>
</tr>
</tbody>
</table>

#### SD_RESP_2 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x18</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>RESP5</td>
<td>R</td>
<td>0x0000</td>
<td>Response 5  <br/>- For 48-bit response tokens: Not used.<br/>- For 136-bit response tokens: Stores bits [103:88] of the response token.</td>
</tr>
<tr>
<td>15:0</td>
<td>RESP4</td>
<td>R</td>
<td>0x0000</td>
<td>Response 4 <br/>- For 48-bit response tokens: Not used.<br/>- For 136-bit response tokens: Stores bits [87:72] of the response token.</td>
</tr>
</tbody>
</table>

#### SD_RESP_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>RESP7</td>
<td>R</td>
<td>0x0000</td>
<td>Response 7 <br/>- For 48-bit response tokens: Not used.<br/>- For 136-bit response tokens: Stores bits [127:120] of the response token.<br/>- For Auto CMD12 responses: Stores bits [39:24] of the response token.</td>
</tr>
<tr>
<td>15:0</td>
<td>RESP6</td>
<td>R</td>
<td>0x0000</td>
<td>Response 6 <br/>- For 48-bit response tokens: Not used.<br/>- For 136-bit response tokens: Stores bits [119:104] of the response token.<br/>- For Auto CMD12 responses: Stores bits [23:8] of the response token.</td>
</tr>
</tbody>
</table>

#### SD_BUFFER_DATA_PORT REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x20</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>BUF_DATA</td>
<td>R/W</td>
<td>0x0</td>
<td>Buffer Data</td>
</tr>
</tbody>
</table>

#### SD_PRESENT_STATE_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x24</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:25</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>24</td>
<td>CMD_LEVEL</td>
<td>R</td>
<td>0x1</td>
<td>MMC1_CMD Line Signal Level <br/>This status is used to check the MMC1_CMD line level to recover from errors and for debugging. </td>
</tr>
<tr>
<td>23:20</td>
<td>DAT_LEVEL</td>
<td>R</td>
<td>0xF</td>
<td>MMC1_DAT[3:0] Line Signal Level <br/>This status is used to check the MMC1_DAT[3:0] line level to recover from errors and for debugging. <br/>This is especially useful in detecting the busy signal level from MMC1_DAT[0]. </td>
</tr>
<tr>
<td>19</td>
<td>WRITE_PROT</td>
<td>R</td>
<td>0x0</td>
<td>Write Protect <br/>This field reflects the position of the write_protect latch on the SD card. <br/>This field should be ignored if there is no such feature being provided by the card in use. </td>
</tr>
<tr>
<td>18</td>
<td>CARD_DET</td>
<td>R</td>
<td>0x0</td>
<td>Card Detect <br/>This field reflects the value of the MMC1_CD pin. <br/>0: Card is not detected <br/>1: Card is detected <br/>Note: This field is only used for testing. </td>
</tr>
<tr>
<td>17</td>
<td>CARD_STABLE</td>
<td>R</td>
<td>0x0</td>
<td>Card Stable  <br/>It indicates the debounced value of the card present condition. <br/>0: Card is unstable <br/>1: Card is stable <br/>Note: This field is only used for testing.</td>
</tr>
<tr>
<td>16</td>
<td>CARD_INSERTED</td>
<td>R</td>
<td>0x0</td>
<td>Card Inserted <br/>This field indicates whether an SD card is present or not:. <br/>0: Card is not inserted <br/>1: Card is inserted </td>
</tr>
<tr>
<td>15:12</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11</td>
<td>BUFFER_RD_EN</td>
<td>R</td>
<td>0x0</td>
<td>Buffer Read Enable <br/>This field changes from 0x0 to 0x1 when block data is ready in the buffer, and from 0x1 to 0x0 when all the block data is read from the buffer. </td>
</tr>
<tr>
<td>10</td>
<td>BUFFER_WR_EN</td>
<td>R</td>
<td>0x1</td>
<td>Buffer Write Enable <br/>This field changes from 0x0 to 0x1 when block data can be written to the buffer. So if this bit is set to 0x1, the entire block can be written to the buffer. This field changes from 0x1 to 0x0 when all the block data is written to the buffer. </td>
</tr>
<tr>
<td>9</td>
<td>RX_ACTIVE</td>
<td>R</td>
<td>0x0</td>
<td>Rx Active <br/>This field indicates read transfer is active. <br/>1: Active<br/>0: Inactive</td>
</tr>
<tr>
<td>8</td>
<td>TX_ACTIVE</td>
<td>R</td>
<td>0x0</td>
<td>Tx Active <br/>Indicates write transfer is active. <br/>0: No valid write data exists in the Host Controller <br/>1: active</td>
</tr>
<tr>
<td>7:4</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>RETUNING_REQ</td>
<td>R</td>
<td>0x0</td>
<td>Re-Tuning Request <br/>This field provides the status of the sampling clock. <br/>0: Fixed or well tuned sampling clock <br/>1: Sampling clock needs re-tuning </td>
</tr>
<tr>
<td>2</td>
<td>_DAT_ACTIVE</td>
<td>R</td>
<td>0x0</td>
<td>Data Line Active <br/>This field provides the status of the data line. <br/>0: Data line is free <br/>1: Data line is busy</td>
</tr>
<tr>
<td>1</td>
<td>CMD_INHIBIT_DAT</td>
<td>R</td>
<td>0x0</td>
<td>Command Inhibit Data <br/>This field provides the host driver status for issuing data commands. <br/>0: Data command can be issued <br/>1: Data command cannot be issued </td>
</tr>
<tr>
<td>0</td>
<td>CMD_INHIBIT_CMD</td>
<td>R</td>
<td>0x0</td>
<td>Command Inhibit Command <br/>0: The MMC1_CMD line is available for issuing a new command.<br/>- The host controller can issue a command using MMC1_CMD line.<br/>- This bit is cleared (set to 0) when the command response is received from the device.<br/>- If the &lt;Command Inhibit Data&gt; field is set to 1, commands using only the MMC1_CMD line can still be issued if this bit is 0.<br/>1: The MMC1_CMD line is currently in use or unavailable.<br/>- This bit is set after the command register is written, indicating that a command is in progress.<br/>- It remains set until the command response is received.<br/>When the bit changes from 1 to 0 (indicating that the command response has been received), a command complete interrupt is generated in the Normal Interrupt Status Register. <br/>If the host controller cannot issue a command due to a command conflict error (e.g., attempting to issue a new command while the previous command is still in progress), this bit remains set to 1. </td>
</tr>
</tbody>
</table>

#### SD_HOST_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x28</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:27</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>W_REMOVAL</td>
<td>R/W</td>
<td>0x0</td>
<td>Wakeup on Card Removal <br/>1: Enable wakeup event on card removal detection <br/>0: No wakeup event </td>
</tr>
<tr>
<td>25</td>
<td>W_INSERTION</td>
<td>R/W</td>
<td>0x0</td>
<td>Wakeup on Card Insertion <br/>1: Enable wakeup event on card insertion detection <br/>0: No wakeup event </td>
</tr>
<tr>
<td>24</td>
<td>W_CARD_INT</td>
<td>R/W</td>
<td>0x0</td>
<td>Wakeup on Card Interrupt <br/>1: Enable wakeup event on card interrupt detection <br/>0: No wakeup event </td>
</tr>
<tr>
<td>23:20</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>19</td>
<td>INT_BLK_GAP</td>
<td>R/W</td>
<td>0x0</td>
<td>Block Gap Interrupt <br/>This field is only valid for 4-bit mode. <br/>1: Enables interrupt detection at block gap for multiple block transfers <br/>0: Disables interrupt detection at block gap for multiple block transfers </td>
</tr>
<tr>
<td>18</td>
<td>RD_WAIT_CTL</td>
<td>R/W</td>
<td>0x0</td>
<td>Read Wait Control <br/>- If the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using the MMC1_DAT[2] line by Host hardware. Otherwise, the Host Controller has to stop the SD clock from holding read data. <br/>- When the Host driver detects a card insertion, it will set this bit according to the CCCR of the SDIO card. <br/>- This field is only considered during the block gap phase. Within a block, hardware will stall the clock top stop read data if the host cannot accept any more data (e.g., due to FIFO being full, etc.) <br/>- When this field is cleared by software, operation continues as usual. <br/>- During read wait, software can issue a different commands for different operation as long as it does not require MMC1_DAT[3:0] lines. <br/>- To resume the read operation after waiting, the software must clear this bit (set it to 0)</td>
</tr>
<tr>
<td>17</td>
<td>CONT_REQ</td>
<td>R/WAC</td>
<td>0x0</td>
<td>Continue Request <br/>- This field is used to restart a transaction which was stopped using the &lt;Stop At Block Gap Request&gt;. <br/>- To cancel stop at the block gap, set the &lt;Stop At Block Gap Request&gt; field to 0 and set this field to 1 to restart the transfer. <br/>- The Host Controller automatically clears this field in either of the following cases: <br/>	1. For a read transaction, when the MMC1_DAT[3:0] Line Active changes from 0 to 1, indicating a read transaction restarts.<br/>	2. For a write transaction, when the Write Transfer Active changes from 0 to 1, indicating the write transaction restarts. <br/>	As a result, it is not necessary for the Host driver to set this bit to 0. <br/>- If &lt;Stop At Block Gap Request&gt; is set to 1, any write to this bit is ignored. </td>
</tr>
<tr>
<td>16</td>
<td>STOP_AT_BLOCK_GAP_REQ</td>
<td>R/W</td>
<td>0x0</td>
<td>Stop at Block Gap Request <br/>- This field is used to stop executing a transaction at the next block gap for both DMA and non-DMA transfers. <br/>- The Host driver will leave this bit set to 1 until transfer completion is indicated (when transfer complete is set to 1)<br/>- Clearing both this field and the &lt;Continue Request&gt; field will not cause the transaction to restart. <br/>- For read transactions, Read Wait can be used to stop the transaction at the block gap.<br/>- For write transactions, the host controller will stop the clock at the block gap request.<br/>- For read transactions, if Read Wait Control is set to 0, the Host controller will stop the clock; otherwise, the Host controller will issue a Read Wait command to stop read data.</td>
</tr>
<tr>
<td>15:12</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:9</td>
<td>SD_BUS_VLT</td>
<td>R/W</td>
<td>0x0</td>
<td>SD Bus Voltage <br/>This field reflects the voltage at operating conditions <br/>0x7: 3.3V <br/>0x6: 3.0V <br/>0x5: 1.8V <br/>0x0 to 0x4: Reserved </td>
</tr>
<tr>
<td>8</td>
<td>SD_BUS_POWER</td>
<td>R/W</td>
<td>0x0</td>
<td>SD Bus Power <br/>This field controls the power going out to the SD card. <br/>The field will be cleared if:<br/>- The sd_bus_vlt does not match the voltage support in Capabilities Register 1, or<br/>- A card removal state is detected.</td>
</tr>
<tr>
<td>7</td>
<td>CARD_DET_S</td>
<td>R/W</td>
<td>0x0</td>
<td>Card Detect Signal Selection <br/>This field selects the source for card detection. <br/>0: Card detect input pin <br/>1: Card detect test level (for debugging purposes only) <br/>- When the source for card detection is switched, the interrupt should be disabled during the switching period by clearing the Normal Interrupt Status Enable Register in order to mask unexpected interrupts being caused by the glitch. <br/>- This signal should be disabled via the Normal Interrupt Status Enable Register during debounce period. </td>
</tr>
<tr>
<td>6</td>
<td>CARD_DET_L</td>
<td>R/W</td>
<td>0x0</td>
<td>Card Detect Test Level <br/>1: Card inserted <br/>0: No card inserted </td>
</tr>
<tr>
<td>5</td>
<td>EX_DATA_WIDTH</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit controls the 8-bit mode. <br/>0x0: Data width for bus mode is determined by &lt;DATA_WIDTH&gt;<br/>0x1: 8-bit data width. </td>
</tr>
<tr>
<td>4:3</td>
<td>DMA_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>DMA Select <br/>One of the supported DMA modes is selected. <br/>The host driver checks support for DMA modes using the Capabilities Register 1. Use of the selected DMA is determined by the &lt;DMA Enable&gt; field in the Transfer Mode Register. <br/>0x0: SDMA <br/>0x1: ADMA 1 <br/>0x2: 32-bit address ADMA2 <br/>0x3: Reserved </td>
</tr>
<tr>
<td>2</td>
<td>HI_SPEED_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Extend Data Output Enable <br/>0: Normal <br/>1: MMC1_CMD and MMC1_DAT[3:0] are driven from rising edge of clock </td>
</tr>
<tr>
<td>1</td>
<td>DATA_WIDTH</td>
<td>R/W</td>
<td>0x0</td>
<td>Data Width <br/>1: 4-bit data mode <br/>0: 1-bit data mode, using only MMC1_DAT[0] <br/>Refer to Bit [5] EX_DATA_WIDTH for 8-bit mode support.</td>
</tr>
<tr>
<td>0</td>
<td>LED_CTRL</td>
<td>R/W</td>
<td>0x0</td>
<td>LED Control <br/>1: LED on <br/>0: LED off </td>
</tr>
</tbody>
</table>

#### SD_CLOCK_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x2C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:27</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>SW_RST_DAT</td>
<td>R/WAC</td>
<td>0x0</td>
<td>Soft Reset for Data Port of Logic </td>
</tr>
<tr>
<td>25</td>
<td>SW_RST_CMD</td>
<td>R/WAC</td>
<td>0x0</td>
<td>Soft Reset for Command Part of Logic </td>
</tr>
<tr>
<td>24</td>
<td>SW_RST_ALL</td>
<td>R/WAC</td>
<td>0x0</td>
<td>Software Reset for All <br/>This reset affects the status, state machine, and FIFOs synchronously.  <br/>This field also resets all private registers. </td>
</tr>
<tr>
<td>23:20</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>19:16</td>
<td>TIMEOUT_VALUE</td>
<td>R/W</td>
<td>0x0</td>
<td>Timeout Value <br/>Determines the interval by which MMC1_DAT[3:0] line timeouts are detected. This timeout is initiated in the following cases: <br/>- For read transaction, this timeout is about waiting for data from cards. It refers to the timing value in the SD specification, which specifies the maximum timing from read command to read data (i.e., card data access time);<br/>- For write transaction, this timeout is about waiting for data from AXI slave, AXI Master, or processor, or waiting for CRC status of write block.<br/>- Timeout Calculation:<br/>	1. 0x0: SDCLK x 2^13 <br/>	2. 0x1: SDCLK x 2^14 <br/>	3. ... <br/>	4. 0xE: SDCLK x 2^27   <br/>	For example, <br/>	1. If sd_clk frequency = 200 MHz (base value), then the timeout base = 50 MHz (period = 20 ns).<br/>		- For 0xE setting:<br/>Timeout = 2^27 * 20 ns ≈ 2.684 seconds.<br/>	2. If sd_clk frequency = 50 MHz (base value divided by 4), then the timeout base = 12.5 MHz (period = 80 ns).<br/>		- For 0xE setting:<br/>Timeout = 2^27 * 80 ns ≈ 10.73 seconds.<br/>	0xF is Reserved for future use.<br/>For other transactions, please refer to the SD specification for more information on these fixed values.  </td>
</tr>
<tr>
<td>15:8</td>
<td>SD_FREQ_SEL_LO</td>
<td>R/W</td>
<td>0x00</td>
<td>SDCLK Frequency Select Lower bits <br/>This field, together with the &lt;SD_FREQ_SEL_HI&gt; field, defines the clock divider value to be used by the host controller. The final value for the SD clock frequency divider is determined by combining both fields as follows:<br/>SD_FREQ_SEL = {SD_FREQ_SEL_HI[1:0],SD_FREQ_SEL_LO[7:0]} <br/>The selected value is multiplied by 2 to calculate the actual divide value. The possible SD clock frequency settings are:  <br/>- SD_FREQ_SEL = 0x00: Base clock  <br/>- SD_FREQ_SEL = 0x01: Divide by 2 of base clock <br/>- SD_FREQ_SEL = 0x02: Divide by 4 of base clock  <br/>- SD_FREQ_SEL = 0x3: Divide by 6 of base clock<br/>- ... <br/>- SD_FREQ_SEL = 0x3FF: Divide by 2046 of base clock</td>
</tr>
<tr>
<td>7:6</td>
<td>SD_FREQ_SEL_HI</td>
<td>R/W</td>
<td>0x0</td>
<td>SDCLK Frequency Select Upper bits <br/>This field, together with &lt;SD_FREQ_SEL_LO&gt; defines the clock divider value to be used by the host controller. The final value for the SD clock frequency divider is determined by combining both fields as follows:<br/>SD_FREQ_SEL = {SD_FREQ_SEL_HI[1:0],SD_FREQ_SEL_LO[7:0]}. </td>
</tr>
<tr>
<td>5</td>
<td>CLK_GEN_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>Clock Generator Select <br/>This field is used to select the clock generator mode. <br/>0x1: Programmable Clock Mode <br/>0x0: Divided Clock mode </td>
</tr>
<tr>
<td>4:3</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>SD_CLK_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>SDCLK Clock Enable <br/>This bit controls the SDCLK to the card. <br/>Before using the card, this bit should be set during the initialization phase. </td>
</tr>
<tr>
<td>1</td>
<td>INT_CLK_STABLE</td>
<td>R</td>
<td>0x0</td>
<td>Internal Clock Stable <br/>This field is set to 1 once the controller detects that the internal clock is stable after setting of the &lt;Internal Clock Enable&gt; field. </td>
</tr>
<tr>
<td>0</td>
<td>INT_CLK_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Internal Clock Enable <br/>This field controls the SDCLK to the internal logic. <br/>1: Enable <br/>0: Disable </td>
</tr>
</tbody>
</table>

#### SD_NORMAL_INT_STATUS REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x30</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CRC_STATUS_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>CRC Status Error <br/>It is set to 1 if there is an error in any of the following:<br/>- CRC status start bit <br/>- CRC status end bit <br/>- Boot ACK status<br/>These errors are returned from the card in write transaction</td>
</tr>
<tr>
<td>30</td>
<td>CPL_TIMEOUT_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Command Completion Signal Timeout Error <br/>This field is applicable for CE-ATA mode only. <br/>1: A command completion signal timeout occurred </td>
</tr>
<tr>
<td>29</td>
<td>AXI_RESP_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>AXI Bus Response Error <br/>1: A response other than OKAY was received on the AXI bus. </td>
</tr>
<tr>
<td>28</td>
<td>SPI_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>SPI Mode Error <br/>1: Error occurred in SPI mode for which cause can be determined by reading the &lt;SPI Error Token&gt; field in the SPI Mode Register <br/>0: No error </td>
</tr>
<tr>
<td>27:26</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>25</td>
<td>ADMA_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>ADMA (Advanced Direct Memory Access) Error <br/>This bit is set when the host controller detects any errors during an ADMA-based data transfer. <br/>The state of the ADMA at the time of the error is recorded in the ADMA Error Status Register. <br/>This interrupt is also triggered when the host controller detects invalid descriptor data.<br/>The &lt;ADMA Error State&gt; field in the ADMA Error Status Register indicates the state in which an error occurred. <br/>The host driver may find that a Valid bit is not set at the error descriptor. <br/>1 = Error <br/>0 = No error </td>
</tr>
<tr>
<td>24</td>
<td>AUTO_CMD12_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Auto CMD12 Error occurs when detecting that one of the bits in Auto CMD12 Error Status Register has changed from 0 to 1.  </td>
</tr>
<tr>
<td>23</td>
<td>CUR_LIMIT_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Current Limit Error <br/>> Note. This feature is not supported currently, and this bit will always be read as 0. </td>
</tr>
<tr>
<td>22</td>
<td>RD_DATA_END_BIT_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>ReadData End Bit Error <br/>This bit is set to 1 when a 0 is detected at the end bit position of read data that uses the MMC1_DAT[3:0] line, or at the end bit position of the CRC status.</td>
</tr>
<tr>
<td>21</td>
<td>RD_DATA_CRC_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Read Data CRC Error <br/>This bit is set to 1 when there is a CRC error detected in the read data transferred via the MMC1_DAT[3:0] line, or when the Write CRC status has a value other than 010.</td>
</tr>
<tr>
<td>20</td>
<td>DATA_TIMEOUT_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Data Timeout Error <br/>This bit is set to 1 when a timeout error occurs during data transfer, which could happen in the following scenarios:<br/>- Busy timeout after write CRC status<br/>- Write CRC status timeout<br/>- Read data timeout</td>
</tr>
<tr>
<td>19</td>
<td>CMD_INDEX_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Command Index Error <br/>0: No command index error has occurred in the command response <br/>1: Command index error has occurred in the command response </td>
</tr>
<tr>
<td>18</td>
<td>CMD_END_BIT_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Command End Bit Error <br/>0: Detection of end bit of a command response in 1 <br/>1: Detection of end bit of a command response is 0 </td>
</tr>
<tr>
<td>17</td>
<td>CMD_CRC_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Command CRC Error <br/>This bit is set to 1 in two cases:<br/>- A CRC error is detected in the command response.<br/>- The host controller detects a conflict on the MMC1_CMD line while issuing a command. In this case, the host controller will abort the command by stopping the MMC1_CMD line, and the &lt;Command Timeout Error&gt; field will also be set to 1 to distinguish the MMC1_CMD line conflict.</td>
</tr>
<tr>
<td>16</td>
<td>CMD_TIMEOUT_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Command Timeout Error <br/>1: No response is returned within 64 SDCLK cycles from the end bit of the command </td>
</tr>
<tr>
<td>15</td>
<td>ERR_INT</td>
<td>R</td>
<td>0x0</td>
<td>Error Interrupt <br/>If any of bits in the Error Interrupt Status Register are set, then this bit is set. </td>
</tr>
<tr>
<td>14</td>
<td>CQ_INT</td>
<td>RC</td>
<td>0x0</td>
<td>Command Queuing Interrupt    <br/>This interrupt is asserted when at least one of the bits in the CQIS register is set. <br/>This interrupt is cleared only when the source interrupt in the CQIS register is cleared.</td>
</tr>
<tr>
<td>13</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>12</td>
<td>RETUNING_INT</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Re-tuning Event Interrupt <br/>This status is set when the Re-Tuning Request in the &lt;Present State Register&gt; changes from 0x0 to 0x1. This indicates that the host controller is requesting the host driver to perform re-tuning starting from the next data transfer. The current data transfer can be completed without requiring re-tuning.</td>
</tr>
<tr>
<td>11</td>
<td>INT_C</td>
<td>R/W1C</td>
<td>0x0</td>
<td>This status is set when INT_C is enabled and INT_C# pin is in low level. Writing this bit to 0x1 does not clear this bit. <br/>It is cleared by resetting the INT_C interrupt factor. Refer to shared bus control register (SHARED_BUS_CTRL).  </td>
</tr>
<tr>
<td>10</td>
<td>INT_B</td>
<td>R/W1C</td>
<td>0x0</td>
<td>This status is set when INT_B is enabled and INT_B# pin is in low level. Writing this bit to 0x1 does not clear this bit. <br/>It is cleared by resetting the INT_B interrupt factor. Refer to shared bus control register (SHARED_BUS_CTRL).  </td>
</tr>
<tr>
<td>9</td>
<td>INT_A</td>
<td>R/W1C</td>
<td>0x0</td>
<td>This status is set if INT_A is enabled and INT_A# pin is in low level. Writing this bit to 0x1 does not clear this bit. <br/>It is cleared by resetting the INT_A interrupt factor. Refer to shared bus control register (SHARED_BUS_CTRL).  </td>
</tr>
<tr>
<td>8</td>
<td>CARD_INT</td>
<td>R</td>
<td>0x0</td>
<td>Card Interrupt <br/>1: Host controller detects an interrupt from the card </td>
</tr>
<tr>
<td>7</td>
<td>CARD_REM_INT</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Card Removal Interrupt <br/>1: Card removal event detected </td>
</tr>
<tr>
<td>6</td>
<td>CARD_INS_INT</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Card Insertion Interrupt <br/>1: Card insertion event detected </td>
</tr>
<tr>
<td>5</td>
<td>RX_RDY</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Rx Ready <br/>This status is set when the &lt;Buffer Read Enable&gt; field in the Present State Register 1 changes from 0x0 to 0x1. </td>
</tr>
<tr>
<td>4</td>
<td>TX_RDY</td>
<td>R/W1C</td>
<td>0x1</td>
<td>Tx Ready <br/>This status is set when the &lt;Buffer Write Enable&gt; field in the Present State Register 1 changes from 0x0 to 0x1. </td>
</tr>
<tr>
<td>3</td>
<td>DMA_INT</td>
<td>R/W1C</td>
<td>0x0</td>
<td>DMA Interrupt <br/>This status is set when the Host Controller detects DMA crossing over the &lt;Host DMA Buffer Boundary&gt; field in the Block Size Register. </td>
</tr>
<tr>
<td>2</td>
<td>BLOCK_GAP_EVT</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Block Gap Event <br/>This field is set when a read or write transaction is stopped at a block gap, but only if the &lt;Stop At Block Gap Request&gt; field in the Block Gap Control Register is set.<br/>- If the &lt;Stop At Block Gap Request&gt; field is not set to 1, this bit will remain 0.</td>
</tr>
<tr>
<td>1</td>
<td>XFER_COMPLETE</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Transfer Complete <br/>This bit is set when a read/write transaction is completed.<br/>- For read transactions:<br/>This bit is set at the falling edge of Read Transfer Active Status, and it can occur in two cases:<br/>	1. Data transfer is completed as specified by the data length.<br/>	2. The data transfer is stopped at the block gap and completed after setting the &lt;Stop At Block Gap Request&gt;  field in the SD Block Gap Control Register.<br/>- For write transactions:<br/>This bit is set at the falling edge of the MMC1_DAT[3:0] Line Active status, and it can occur in two cases:<br/>	1. Data transfer is completed as specified by the data length, and the busy signal is released.<br/>	2. The data transfer is stopped at the block gap and completed after setting the &lt;Stop At Block Gap Request&gt; field.</td>
</tr>
<tr>
<td>0</td>
<td>CMD_COMPLETE</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Command Complete <br/>This bit is set when the end bit of the command response (Except Auto CMD12) is received. <br/>> <strong>Note</strong><strong>.</strong> Command Timeout Error has higher priority than Command complete. </td>
</tr>
</tbody>
</table>

#### SD_NORMAL_INT_STATUS_EN REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x34</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CRC_STATUS_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>CRC Status Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>30</td>
<td>CPL_TIMEOUT_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>CPL Timeout Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>29</td>
<td>AXI_RESP_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>AXI Response Error<br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>28</td>
<td>SPI_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>SPI Error Enable <br/>0: Disabled <br/>1: Enabled</td>
</tr>
<tr>
<td>27</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>TUNING_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Tuning Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>25</td>
<td>ADMA_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>ADMA Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>24</td>
<td>AUTO_CMD12_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Auto CMD12 Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>23</td>
<td>CUR_LIM_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Current Limit Error Enable <br/>0: Disabled <br/>1: Enabled</td>
</tr>
<tr>
<td>22</td>
<td>RD_DATA_END_BIT_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Data End Bit Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>21</td>
<td>RD_DATA_CRC_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Data CRC Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>20</td>
<td>DATA_TIMEOUT_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Data Timeout Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>19</td>
<td>CMD_INDEX_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Index Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>18</td>
<td>CMD_END_BIT_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td> Command End Bit Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>17</td>
<td>CMD_CRC_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command CRC Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>16</td>
<td>CMD_TIMEOUT_ERR_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Timeout Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>15</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14</td>
<td>CQ_STATUS_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Queuing Status Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>13</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>12</td>
<td>RETUNE_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Re_tuning Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>11</td>
<td>INT_C_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>INT_C Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>10</td>
<td>INT_B_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>INT_B Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>9</td>
<td>INT_A_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>INT_A Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>8</td>
<td>CARD_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Card Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>7</td>
<td>CARD_REM_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Card Removal Status Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>6</td>
<td>CARD_INS_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Card Insertion Status Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>5</td>
<td>RD_RDY_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Buffer Read Ready Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>4</td>
<td>TX_RDY_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Buffer Write Ready Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>3</td>
<td>DMA_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>DMA Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>2</td>
<td>BLOCK_GAP_EVT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Block Gap Event Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>1</td>
<td>XFER_COMPLETE_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Transfer Complete Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>0</td>
<td>CMD_COMPLETE_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Complete Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
</tbody>
</table>

#### SD_NORMAL_INT_STATUS_INT_EN REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x38</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31<br/></td>
<td>CRC_STATUS_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>CRC Status Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled  </td>
</tr>
<tr>
<td>30</td>
<td>CPL_TIMEOUT_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>CPL Timeout Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>29</td>
<td>AXI_RESP_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>AXI Response Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>28</td>
<td>SPI_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>SPI Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled</td>
</tr>
<tr>
<td>27</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>TUNE_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Tuning Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>25</td>
<td>ADMA_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>ADMA Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled</td>
</tr>
<tr>
<td>24</td>
<td>AUTO_CMD12_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Auto CMD12 Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>23</td>
<td>CUR_LIM_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Current Limit Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled  </td>
</tr>
<tr>
<td>22</td>
<td>RD_DATA_END_BIT_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Data End Bit Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>21</td>
<td>RD_DATA_CRC_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Data CRC Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>20</td>
<td>DATA_TIMEOUT_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Data Timeout Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>19</td>
<td>CMD_INDEX_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Index Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>18</td>
<td>CMD_END_BIT_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command End Bit Interrupt Error Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>17</td>
<td>CMD_CRC_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command CRC Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>16</td>
<td>CMD_TIMEOUT_ERR_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Timeout Error Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>15</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14</td>
<td>CQ_SIGNAL_ENABLE</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Queuing Signal Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>13</td>
<td>CARD_ASYNC_INT_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>SDIO Card Async INT without AXI/SD function clock running Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>12</td>
<td>RETUNE_INT_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Re-Tuning Interrupt Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>11</td>
<td>INT_C_INT_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>INT_C Interrupt Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>10</td>
<td>INT_B_INT_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>INT_B Interrupt Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>9</td>
<td>INT_A_INT_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>INT_A Interrupt Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>8</td>
<td>CARD_INT_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Card Interrupt Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>7</td>
<td>CARD_REM_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Card Removal Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>6</td>
<td>CARD_INS_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Card Insertion Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>5</td>
<td>RX_RDY_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Buffer Read Ready Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>4</td>
<td>TX_RDY_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Buffer Write Ready Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>3</td>
<td>DMA_INT_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>DMA Interrupt Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>2</td>
<td>BLOCK_GAP_EVT_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Block Gap Event Interrupt Enable <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>1</td>
<td>XFER_COMPLETE_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Transfer Complete Interrupt Enable <br/>0: Disabled <br/>1: Enabled</td>
</tr>
<tr>
<td>0</td>
<td>CMD_COMPLETE_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Command Complete Interrupt Enable <br/>0: Disabled <br/>1: Enabled  </td>
</tr>
</tbody>
</table>

#### SD_AUTO_CMD12_ERROR_STATUS REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x3C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>PRE_VAL_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Preset Value Enable <br/>0x1: Automatic selection by Preset Value are Enabled <br/>0x0: SDCLK and Driver Strength are controlled by Host Driver </td>
</tr>
<tr>
<td>30</td>
<td>ASYNC_INT_EN</td>
<td>R/W</td>
<td>0x1</td>
<td>Asynchronous Interrupt Enable  <br/>This bit can be set to 0x1 if a card supports asynchronous interrupts and &lt;async_int_support&gt; is set to 0x1 in the capabilities register. <br/>Asynchronous interrupt is effective when DAT[1] interrupt is used in 4-bit SD mode (and &lt;int_pin_sel&gt; is set to 0 in Shared Bus Control register). <br/>When this bit is set to 0x1, the host driver can stop the SDCLK during asynchronous interrupt period to save power. During this period, the host controller continues to deliver the Card Interrupt to the host when it is asserted by the card.  <br/>0x1: Enabled <br/>0x0: Disabled </td>
</tr>
<tr>
<td>29:24</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23</td>
<td>SAMPLING_CLK_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>Sampling Clock Select <br/>Host controller uses this bit to select sampling clock to receive CMD and DAT. <br/>This bit is set by tuning procedure and valid after the completion of tuning (when &lt;exe_tuning&gt; is cleared). <br/>0x1: Tuned clock is used to sample data (indicating that tuning was successful).<br/>0x0: Fixed clock is used to sample data (indicating that tuning failed).<br/>Writing 0x1 to this bit is meaningless and ignored if tuning is not yet complete. If the bit is written as 0x0, the tuning circuit is reset. However, resetting the tuning circuit requires time to complete the tuning sequence. The host driver should keep this bit set to 0x1 to perform re-tuning quickly when necessary.<br/>Changes to this bit are not allowed while the host controller is receiving responses or a read data block.</td>
</tr>
<tr>
<td>22</td>
<td>EXE_TUNING</td>
<td>R/WAC</td>
<td>0x0</td>
<td>Execute Tuning<br/>This bit is set to 0x1 to start tuning procedure and automatically cleared when tuning procedure is completed. The result of the tuning is reflected in the &lt;sampling_clk_sel&gt;. The tuning procedure is aborted by writing 0x0.  <br/>0x1: Execute Tuning<br/>0x0: Not tuned or Tuning completed</td>
</tr>
<tr>
<td>21:20</td>
<td>DRV_STRENGTH_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>Driver Strength Select. <br/>Host Controller output driver in 1.8V signaling is selected by this field. With 3.3V signaling, this field is not effective. This field can be set depending on Driver Type A, C and D support bits in the Capabilities register.  <br/>This bit depends on the setting of &lt;pre_val_en&gt;. <br/>- If &lt;pre_val_en&gt; = 0x0, this field is set by the host driver. <br/>- If &lt;pre_val_en&gt; = 0x1, this field is automatically set by a value specified in one of the Preset Value registers. <br/>0x0: Driver Type B <br/>0x1: Driver Type A <br/>0x2: Driver Type C <br/>0x3: Driver Type D </td>
</tr>
<tr>
<td>19</td>
<td>SDH_V18_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>1.8V Signaling Enable <br/>0x1: 1.8V Signaling enable <br/>0x0: 3.3V Signaling enable </td>
</tr>
<tr>
<td>18:16</td>
<td>UHS_MODE_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>UHS Mode Select<br/>This field is used to select one of UHS-I modes and effective when &lt;sdh_v18_en&gt; = 0x1. <br/>If &lt;pre_val_en&gt; in the Host Control2 register is set to 0x1, host controller sets SDCLK Frequency select, Clock generator select in the clock control register, and driver strength select according to the Preset Value registers. <br/>In this case, one of the preset value registers is selected by this field. <br/>Host driver should reset &lt;sd_clk_en&gt; before changing this field to avoid generating clock glitch <br/>0x0: SDR12 <br/>0x1: SDR25 <br/>0x2: SDR50 <br/>0x3: SDR104 <br/>0x4: DDR50  <br/>For MMC mode, added two backdoor defined modes: <br/>0x5: HS200 mode   <br/>0x6: HS400 mode<br/>All other values are Reserved </td>
</tr>
<tr>
<td>15:8</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7</td>
<td>CMD_NOT_ISSUED</td>
<td>RC</td>
<td>0x0</td>
<td>Command Not Issued <br/>This is due to auto_cmd12 Error </td>
</tr>
<tr>
<td>6:5</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>AUTO_CMD_INDEX_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Auto CMD12 or Auto CMD23 Error <br/>This error occurs when the command index error occurs in response to a command <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>3</td>
<td>AUTO_CMD_END_BIT_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Auto CMD12 or Auto CMD23 End Bit Error <br/>This error occurs when detecting that the end bit of command response is 0. <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>2</td>
<td>AUTO_CMD_CRC_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Auto CMD12 or Auto CMD23 CRC Error <br/>This error occurs when detecting CRC error in the command response. <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>1</td>
<td>AUTO_CMD_TIMEOUT_ERR</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Auto CMD12 or Auto CMD23 Timeout Error <br/>This error occurs when no response is returned within 64 SDCLK cycles from the end bit of command. <br/>0: Disabled <br/>1: Enabled </td>
</tr>
<tr>
<td>0</td>
<td>AUTO_CMD12_NOT_EXE</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Auto CMD12 Not Executed <br/>This error occurs when host controller cannot issue Auto cmd12 to stop multiple block data transfer due to some errors. <br/>0: Disabled <br/>1: Enabled </td>
</tr>
</tbody>
</table>

#### SD_CAPABILITIES_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x40</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>CFG_SLOT_TYPE</td>
<td>R/W</td>
<td>0x0</td>
<td>Slot Type <br/>This field indicates what type of slot the host controller is connected to. <br/>0x0: Removable card slot <br/>0x1: Embedded slot for one device <br/>0x2: Shared bus slot <br/>0x3: Reserved </td>
</tr>
<tr>
<td>29</td>
<td>ASYNC_INT_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>Asynchronous Interrupt Support. <br/>0x1: Asynchronous Interrupt Supported <br/>0x0: Asynchronous Interrupt not supported </td>
</tr>
<tr>
<td>28</td>
<td>SYS_BUS_64_SUPPORT</td>
<td>R</td>
<td>0x0</td>
<td>64-bit System Bus Support <br/>This bit indicates whether the host controller is capable of 64-bit system bus. <br/>0x1: 64-bit system bus supported<br/>0x0: 64-bit system bus not supported</td>
</tr>
<tr>
<td>27</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>VLG_18_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>Voltage Support 1.8V <br/>This bit indicates whether the host controller is capable of 1.8V. <br/>0x1: 1.8V Supported<br/>0x0: 1.8V not supported</td>
</tr>
<tr>
<td>25</td>
<td>VLG_30_SUPPORT</td>
<td>R</td>
<td>0x0</td>
<td>Voltage Support 3.0V <br/>This bit indicates whether the host controller is capable of 3.0V. <br/>0x1: 3.0V Supported<br/>0x0: 3.0V not supported</td>
</tr>
<tr>
<td>24</td>
<td>VLG_33_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>Voltage Support 3.3V <br/>This bit indicates whether the host controller is capable of 3.3V. <br/>0x1: 3.3V Supported<br/>0x0: 3.3V not supported</td>
</tr>
<tr>
<td>23</td>
<td>SUS_RES_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>Suspend Resume Support <br/>This bit indicates whether the host controller is capable of suspend resume commands. <br/>0x1: Suspend/Resume Supported<br/>0x0: Suspend/Resume not supported. </td>
</tr>
<tr>
<td>22</td>
<td>SDMA_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>SDMA Support <br/>This bit indicates whether the host controller is capable of SDMA. <br/>0x1: SDMA Supported<br/>0x0: SDMA not supported. </td>
</tr>
<tr>
<td>21</td>
<td>HI_SPEED_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>High Speed Support <br/>This bit indicates whether the host controller is capable of high speed mode (25 - 50MHz). <br/>0x1: High speed mode Supported<br/>0x0: High speed mode not supported. </td>
</tr>
<tr>
<td>20</td>
<td>ADMA1_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>ADMA1 Support <br/>This bit indicates whether the host controller is capable of ADMA1. <br/>0x1: ADMA1 Supported<br/>0x0: ADMA1 not supported </td>
</tr>
<tr>
<td>19</td>
<td>ADMA2_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>ADMA2 Support <br/>This bit indicates whether the host controller is capable of ADMA2. <br/>0x1: ADMA2 Supported<br/>0x0: ADMA2 not supported </td>
</tr>
<tr>
<td>18</td>
<td>EX_DATA_WIDTH_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>8-bit Support <br/>This bit indicates whether the host controller is capable of 8-bit bus operation. <br/>0x1: 8-bit Supported <br/>0x0: 8-bit not supported </td>
</tr>
<tr>
<td>17:16</td>
<td>MAX_BLK_LEN</td>
<td>R</td>
<td>0x0</td>
<td>Maximum Block Length  <br/>The maximum block length in bytes.  <br/>0x0: 512 Bytes </td>
</tr>
<tr>
<td>15:8</td>
<td>BASE_FREQ</td>
<td>R</td>
<td>0x00</td>
<td>Base Frequency <br/>The base clock frequency for SDCLK <br/>0xC8: 200 MHz (Actual frequency: 198.24 MHz)<br/>0x0: Get frequency information via another method </td>
</tr>
<tr>
<td>7</td>
<td>TIMEOUT_UNIT</td>
<td>R</td>
<td>0x1</td>
<td>Timeout Unit <br/>The unit of base clock used to detect timeouts. <br/>1: MHz <br/>0: kHz </td>
</tr>
<tr>
<td>6</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:0</td>
<td>TIMEOUT_FREQ</td>
<td>R</td>
<td>0x00</td>
<td>Timeout Frequency <br/>This value indicates the base clock frequency used to detect timeouts. <br/>0x32: 50 MHz (Actual frequency: 49.56 MHz). <br/>0x0: Get frequency information via another method </td>
</tr>
</tbody>
</table>

#### SD_CAPABILITIES_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x44</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:16</td>
<td>&lt;CLK_MULTIPLIER&gt;</td>
<td>R</td>
<td>0x0</td>
<td>Clock Multiplier <br/>This field indicates clock multiplier value of programmable clock generator. <br/>0x0: Host Controller does not support a programmable clock generator. </td>
</tr>
<tr>
<td>15:14</td>
<td>RETUNE_MODES</td>
<td>R</td>
<td>0x0</td>
<td>Re_tuning modes. <br/>This field selects the re-tuning method and limits the maximum data length. <br/>0x0: Mode1, Timer <br/>0x1: Mode2, Timer and Re-Tuning Request <br/>0x2: Mode3, Auto Re-Tuning (for transfer) Timer and Re-Tuning Request <br/>0x3: Reserved</td>
</tr>
<tr>
<td>13</td>
<td>SDR50_TUNE</td>
<td>R</td>
<td>0x1</td>
<td>Use Tuning for SDR50 mode.  <br/>0x1: SDR50 requires tuning <br/>0x0: SDR50 does not require tuning </td>
</tr>
<tr>
<td>12</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:8</td>
<td>TMR_RETUNE</td>
<td>R</td>
<td>0xf</td>
<td>Timer count for Re-Tuning<br/>This field indicates an initial value of the Re-Tuning Timer for Mode 1 to 3. <br/>0xf: Get information from other sources</td>
</tr>
<tr>
<td>7</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6</td>
<td>DRV_TYPE_D</td>
<td>R</td>
<td>0x1</td>
<td>Driver Type D Support <br/>0x1: Driver Type D is supported <br/>0x0: Driver Type D is not supported </td>
</tr>
<tr>
<td>5</td>
<td>DRV_TYPE_C</td>
<td>R</td>
<td>0x1</td>
<td>Driver Type C Support. <br/>0x1: Driver Type C is supported <br/>0x0: Driver Type C is not supported </td>
</tr>
<tr>
<td>4</td>
<td>DRV_TYPE_A</td>
<td>R</td>
<td>0x1</td>
<td>Driver Type A Support <br/>0x1: Driver Type A is supported <br/>0x0: Driver Type A is not supported </td>
</tr>
<tr>
<td>3</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>DDR50_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>DDR50 Support <br/>0x1: DDR50 is supported <br/>0x0: DDR50 is not supported </td>
</tr>
<tr>
<td>1</td>
<td>SDR104_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>SDR104 Support <br/>0x1: SDR104 is supported <br/>0x0: SDR104 is not supported </td>
</tr>
<tr>
<td>0</td>
<td>SDR50_SUPPORT</td>
<td>R</td>
<td>0x1</td>
<td>SDR50 Support <br/>0x1: SDR50 is supported <br/>0x0: SDR50 is not supported </td>
</tr>
</tbody>
</table>

#### SD_MAX_CURRENT_1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x48</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:16</td>
<td>MAX_CUR_18</td>
<td>R</td>
<td>0x0</td>
<td>Maximum Current for 1.8V <br/>0x0:  Get information via another method <br/>0x1: 4 mA<br/>0x2: 8 mA <br/>... <br/>0xFF: 1020 mA</td>
</tr>
<tr>
<td>15:8</td>
<td>MAX_CUR_30</td>
<td>R</td>
<td>0x0</td>
<td>Maximum Current for 3.0V <br/>0x0: Get information via another method <br/>0x1: 4 mA <br/>0x2: 8 mA <br/>... <br/>0xF: 1020 mA </td>
</tr>
<tr>
<td>7:0</td>
<td>MAX_CUR_33</td>
<td>R</td>
<td>0x0</td>
<td>Maximum Current for 3.3V <br/>0x0: Get information via another method <br/>0x1: 4 mA <br/>0x2: 8 mA <br/>... <br/>0xF: 1020 mA </td>
</tr>
</tbody>
</table>

#### SD_MAX_CURRENT_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
</tbody>
</table>

#### SD_FORCE_EVENT_AUTO_CMD12_ERROR REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x50</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>F_CRC_STATUS_ERR</td>
<td>W<br/></td>
<td>0x0</td>
<td>Force Event for CRC Status Error <br/>When 1 is written at this location, it sets the &lt;CRC Status Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>30</td>
<td>F_CPL_TIMEOUT_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for CPL Timeout Error <br/>When 1 is written at this location, it sets the &lt;Command Completion Signal Timeout Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>29</td>
<td>F_AXI_RESP_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for AXI Response Bit Error <br/>When 1 is written at this location, it sets the &lt;AXI Bus Response Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>28</td>
<td>F_SPI_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for SPI Error <br/>When 1 is written at this location, it sets the &lt;SPI Mode Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>27:26</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>25</td>
<td>F_ADMA_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for ADMA Error <br/>When 1 is written at this location, it sets the &lt;ADMA Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>24</td>
<td>F_ACMD12_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Auto Cmd12 Error <br/>When 1 is written at this location, it sets the &lt;Auto CMD12 Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>23</td>
<td>F_CURRENT_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Current Limit Error <br/>When 1 is written at this location, it sets the &lt;Current Limit Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>22</td>
<td>F_DAT_END_BIT_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Data End Bit Error <br/>When 1 is written at this location, it sets the &lt;ReadDataEnd Bit Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>21</td>
<td>F_DAT_CRC_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Data CRC Error <br/>When 1 is written at this location, it sets the &lt;Read Data CRC Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>20</td>
<td>F_DAT_TO_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Data Timeout Error <br/>When 1 is written at this location, it sets the &lt;Read Data CRC Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>19</td>
<td>F_CMD_INDEX_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Command Index Error <br/>When 1 is written at this location, it sets the &lt;Data Timeout Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>18</td>
<td>F_CMD_END_BIT_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Command End Bit Error <br/>When 1 is written at this location, it sets the &lt;Command Index Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>17</td>
<td>F_CMD_CRC_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Command CRC Error <br/>When 1 is written at this location, it sets the &lt;Command CRC Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>16</td>
<td>F_CMD_TO_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Command Timeout Error <br/>When 1 is written at this location, it sets the &lt;Command Timeout Error&gt; field in the Error Interrupt Status Register. </td>
</tr>
<tr>
<td>15:8</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7</td>
<td>F_ACMD12_ISSUE_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Command not Issued by Auto Cmd12 Error <br/>When 1 is written at this location, it sets the &lt;Command Not Issued Due to auto_cmd12 Error&gt; field in the Auto CMD12 Error Status Register. </td>
</tr>
<tr>
<td>6:5</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>4</td>
<td>F_ACMD_INDEX_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Auto Cmd Index Error <br/>When 1 is written at this location, it sets the &lt;Auto CMD Error&gt; field in the Auto CMD Error Status Register. </td>
</tr>
<tr>
<td>3</td>
<td>F__ACMD_EBIT_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Auto Cmd End Bit Error <br/>When 1 is written at this location, it sets the &lt;Auto CMD End Bit Error&gt; field in the Auto CMD Error Status Register. </td>
</tr>
<tr>
<td>2</td>
<td>F_ACMD_CRC_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Auto Cmd CRC Error <br/>When 1 is written at this location, it sets the &lt;Auto CMD CRC Error&gt; field in the Auto CMD Error Status Register. </td>
</tr>
<tr>
<td>1</td>
<td>F_ACMD_TO_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Auto Cmd Timeout Error <br/>When 1 is written at this location, it sets the &lt;Auto CMD Timeout Error&gt; field in the Auto CMD Error Status Register. </td>
</tr>
<tr>
<td>0</td>
<td>F_ACMD12_NEXE_ERR</td>
<td>W</td>
<td>0x0</td>
<td>Force Event for Auto Cmd12 Not Executed Error <br/>When 1 is written at this location, it sets the &lt;Auto CMD12 Not Executed&gt; field in the Auto CMD12 Error Status Register. </td>
</tr>
</tbody>
</table>

#### SD_ADMA_ERROR_STATUS REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x54</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>ADMA_LEN_ERR</td>
<td>R/W</td>
<td>0x0</td>
<td>ADMA Length Mismatch Error <br/>This error occurs in the following two cases: <br/>- While Block Count Enable (in SD_TRANSFER_MODE_CMD Bit[1]) is set, the total data length is specified by the descriptor table, which is different from that specified by the block count and block Length. <br/>- Total data length cannot be divided by block length</td>
</tr>
<tr>
<td>1:0</td>
<td>ADMA_STATE</td>
<td>R/W</td>
<td>0x0</td>
<td>ADMA Error State <br/>This field indicates the state of ADMA when error occurred during ADMA transfer. <br/>This field never indicates 0x2 because ADMA never stops in this state. </td>
</tr>
</tbody>
</table>

#### ADMA SYSTEM ADDRESS REGISTER 1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x58</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>ADMA_SYS_ADDR</td>
<td>R/W</td>
<td>0x0</td>
<td>ADMA System Address <br/>This register holds the byte address of the executing command in the Descriptor table.<br/>- At the start of ADMA, this register should be programmed to point to the starting address of the Descriptor table.<br/>- This register is incremented as the system fetches each descriptor line.<br/>- In case of an ADMA Error Interrupt, this register will contain a valid Descriptor address based on the ADMA state at the time.</td>
</tr>
<tr>
<td>15:0</td>
<td>ADMA_SYS_ADDR</td>
<td>R/W</td>
<td>0x0</td>
<td>ADMA System Address <br/>This register holds the byte address of the executing command in the Descriptor table.<br/>- At the start of ADMA, this register should be programmed to point to the starting address of the Descriptor table.<br/>- This register is incremented as the system fetches each descriptor line.<br/>- In case of an ADMA Error Interrupt, this register will contain a valid Descriptor address based on the ADMA state at the time.</td>
</tr>
</tbody>
</table>

#### SD_ADMA_SYS_ADDR_3 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x</strong><strong>5C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>ADMA_SYS_ADDR</td>
<td>R/W</td>
<td>0x0<br/></td>
<td>ADMA System Address <br/>This register holds the byte address of the executing command in the Descriptor table.<br/>- At the start of ADMA, this register should be programmed to point to the starting address of the Descriptor table.<br/>- This register is incremented as the system fetches each descriptor line.<br/>- In case of an ADMA Error Interrupt, this register will contain a valid Descriptor address based on the ADMA state at the time.</td>
</tr>
<tr>
<td>15:0</td>
<td>ADMA_SYS_ADDR</td>
<td>R/W</td>
<td>0x0</td>
<td>ADMA System Address <br/>This register holds the byte address of the executing command in the Descriptor table.<br/>- At the start of ADMA, this register should be programmed to point to the starting address of the Descriptor table.<br/>- This register is incremented as the system fetches each descriptor line.<br/>- In case of an ADMA Error Interrupt, this register will contain a valid Descriptor address based on the ADMA state at the time.</td>
</tr>
</tbody>
</table>

#### PRESET_VALUE_FOR_INIT REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x60</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>DRV_STRENGTH_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Driver Strength Select Value <br/>Driver strength is supported by 1.8V signaling bus speed modes. The field is not relevant for 3.3V signaling.<br/>0x0: Driver Type B <br/>0x1: Driver Type A <br/>0x2: Driver Type C <br/>0x3: Driver Type D </td>
</tr>
<tr>
<td>29:27</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>CLKGEN_SEL_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Clock Generator Select Value. <br/>This bit is effective when Host Controller supports programmable clock generator. <br/>0x1: Programmable clock generator <br/>0x0: Divided clock </td>
</tr>
<tr>
<td>25:16</td>
<td>SDCLK_FREQ_SEL_VAL</td>
<td>R</td>
<td>0x004</td>
<td>SDCLK Frequency Select Value<br/>10-bit preset value to set &lt;sdclk_freq_sel&gt; in the Clock Control register. </td>
</tr>
<tr>
<td>15:14</td>
<td>DRV_STRENGTH_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Driver Strength Select Value <br/>Driver strength is supported by 1.8V signaling bus speed modes. The field is not relevant for 3.3V signaling. <br/>0x0: Driver Type B <br/>0x1: Driver Type A <br/>0x2: Driver Type C <br/>0x3: Driver Type D </td>
</tr>
<tr>
<td>13:11</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>10</td>
<td>CLKGEN_SEL_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Clock Generator Select Value. <br/>This bit is effective when Host Controller supports programmable clock generator. <br/>0x1: Programmable clock generator <br/>0x0: Divided clock </td>
</tr>
<tr>
<td>9:0</td>
<td>SDCLK_FREQ_SEL_VAL</td>
<td>R</td>
<td>0x100</td>
<td>SDCLK Frequency Select Value <br/>10-bit preset value to set &lt;sdclk_freq_sel&gt; in the Clock Control register. </td>
</tr>
</tbody>
</table>

#### PRESET_VALUE_FOR_HS REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x64</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>DRV_STRENGTH_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Driver Strength Select Value <br/>Driver strength is supported by 1.8V signaling bus speed modes. The field is not relevant for 3.3V signaling. <br/>0x0: Driver Type B <br/>0x1: Driver Type A <br/>0x2: Driver Type C <br/>0x3: Driver Type D  </td>
</tr>
<tr>
<td>29:27</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>CLKGEN_SEL_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Clock Generator Select Value <br/>This bit is effective when Host Controller supports programmable clock generator. <br/>0x1: Programmable clock generator <br/>0x0: Divided clock </td>
</tr>
<tr>
<td>25:16</td>
<td>SDCLK_FREQ_SEL_VAL</td>
<td>R</td>
<td>0x004</td>
<td>SDCLK Frequency Select Value <br/>10-bit preset value to set &lt;sdclk_freq_sel&gt; in the Clock Control register. </td>
</tr>
<tr>
<td>15:14</td>
<td>DRV_STRENGTH_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Driver Strength Select Value <br/>Driver strength is supported by 1.8V signaling bus speed modes. The field is not relevant for 3.3V signaling. <br/>0x0: Driver Type B <br/>0x1: Driver Type A <br/>0x2: Driver Type C <br/>0x3: Driver Type D </td>
</tr>
<tr>
<td>13:11</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>10</td>
<td>CLKGEN_SEL_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Clock Generator Select Value <br/>This bit is effective when Host Controller supports programmable clock generator. <br/>0x1: Programmable clock generator <br/>0x0: Divided clock </td>
</tr>
<tr>
<td>9:0</td>
<td>SDCLK_FREQ_SEL_VAL</td>
<td>R</td>
<td>0x002</td>
<td>SDCLK Frequency Select Value<br/>10-bit preset value to set &lt;sdclk_freq_sel&gt; in the Clock Control register. </td>
</tr>
</tbody>
</table>

#### PRESET_VALUE_FOR_SDR25 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x68</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>DRV_STRENGTH_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Driver Strength Select Value <br/>Driver strength is supported by 1.8V signaling bus speed modes. The field is not relevant for 3.3V signaling. <br/>0x0: Driver Type B <br/>0x1: Driver Type A <br/>0x2: Driver Type C <br/>0x3: Driver Type D </td>
</tr>
<tr>
<td>29:27</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>CLKGEN_SEL_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Clock Generator Select Value <br/>This bit is effective when Host Controller supports programmable clock generator. <br/>0x1: Programmable clock generator <br/>0x0: Divided clock </td>
</tr>
<tr>
<td>25:16</td>
<td>SDCLK_FREQ_SEL_VAL</td>
<td>R</td>
<td>0x004</td>
<td>SDCLK Frequency Select Value 10-bit preset value to set &lt;sdclk_freq_sel&gt; in the Clock Control register. </td>
</tr>
<tr>
<td>15:14</td>
<td>DRV_STRENGTH_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Driver Strength Select Value <br/>Driver strength is supported by 1.8V signaling bus speed modes. The field is not relevant for 3.3V signaling. <br/>0x0: Driver Type B <br/>0x1: Driver Type A <br/>0x2: Driver Type C <br/>0x3: Driver Type D </td>
</tr>
<tr>
<td>13:11</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>10</td>
<td>CLKGEN_SEL_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Clock Generator Select Value<br/>This bit is effective when Host Controller supports programmable clock generator. <br/>0x1: Programmable clock generator <br/>0x0: Divided clock </td>
</tr>
<tr>
<td>9:0</td>
<td>SDCLK_FREQ_SEL_VAL</td>
<td>R</td>
<td>0x002</td>
<td>SDCLK Frequency Select Value<br/>10-bit preset value to set &lt;sdclk_freq_sel&gt; in the Clock Control register. </td>
</tr>
</tbody>
</table>

#### PRESET_VALUE_FOR_SDR104 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x6C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>DRV_STRENGTH_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Driver Strength Select Value <br/>Driver strength is supported by 1.8V signaling bus speed modes. The field is not relevant for 3.3V signaling. <br/>0x0: Driver Type B <br/>0x1: Driver Type A <br/>0x2: Driver Type C <br/>0x3: Driver Type D </td>
</tr>
<tr>
<td>29:27</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>26</td>
<td>CLKGEN_SEL_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Clock Generator Select Value <br/>This bit is effective when Host Controller supports programmable clock generator. <br/>0x1: Programmable clock generator <br/>0x0: Divided clock </td>
</tr>
<tr>
<td>25:16</td>
<td>SDCLK_FREQ_SEL_VAL</td>
<td>R</td>
<td>0x004</td>
<td>SDCLK Frequency Select Value <br/>10-bit preset value to set &lt;sdclk_freq_sel&gt; in the Clock Control register. </td>
</tr>
<tr>
<td>15:14</td>
<td>DRV_STRENGTH_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Driver Strength Select Value <br/>Driver strength is supported by 1.8V signaling bus speed modes. The field is not relevant for 3.3V signaling. <br/>0x0: Driver Type B <br/>0x1: Driver Type A <br/>0x2: Driver Type C <br/>0x3: Driver Type D </td>
</tr>
<tr>
<td>13:11</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>10</td>
<td>CLKGEN_SEL_VAL</td>
<td>R</td>
<td>0x0</td>
<td>Clock Generator Select Value <br/>This bit is effective when Host Controller supports programmable clock generator. <br/>0x1: Programmable clock generator <br/>0x0: Divided clock </td>
</tr>
<tr>
<td>9:0</td>
<td>SDCLK_FREQ_SEL_VAL</td>
<td>R</td>
<td>0x002</td>
<td>SDCLK Frequency Select Value<br/>10-bit preset value to set &lt;sdclk_freq_sel&gt; in the Clock Control register. </td>
</tr>
</tbody>
</table>

#### SHARED_BUS_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xE0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>30:24</td>
<td>BEND_PWR_CTRL</td>
<td>R/W</td>
<td>0x0</td>
<td>Back-End Power Control <br/>Each bit of this field controls back-end power supply for an embedded device. <br/>The maximum number of devices that can be controlled is 7, as specified by &lt;num_clk_pins&gt;. <br/>Each bit is mapped to a device specific, where <br/>- bit[24] corresponds to Device 1 <br/>- bit[30] corresponds to Device 7 <br/>Note: Host interface voltage is not controlled by this field. <br/>The function of each bit is:  <br/>0x0: Back-end power is off <br/>0x1: Back-end power is supplied </td>
</tr>
<tr>
<td>23</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>22:20</td>
<td>INT_PIN_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>Interrupt Pin Select <br/>Interrupt pin inputs are enabled by this field. Enabling an unsupported interrupt pin has no effect. <br/>0x0: Interrupt is detected by interrupt cycle. </td>
</tr>
<tr>
<td>19</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>18:16</td>
<td>CLK_PIN_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>Clock Pin Select <br/>One of the clock pin outputs is selected by this field. <br/>0x0: Clock Pins are disabled </td>
</tr>
<tr>
<td>15</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>14:8</td>
<td>BUS_WIDTH_PRESET</td>
<td>R</td>
<td>0x0</td>
<td>Bus Width Preset <br/>This field defines the bus width preset for devices on a shared bus. <br/>0x0: Bus width defined by &lt;data_transfer_width&gt; <br/>0x1: 8-bit mode </td>
</tr>
<tr>
<td>7:6</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>5:4</td>
<td>NUM_INT_PINS</td>
<td>R</td>
<td>0x0</td>
<td>Number of interrupt input pins <br/>This field defines the number of interrupt input pins supported on shared bus system. <br/>0x0: Interrupt input pin is not supported </td>
</tr>
<tr>
<td>3</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2:0</td>
<td>NUM_CLK_PINS</td>
<td>R</td>
<td>0x0</td>
<td>Number of clock pins <br/>This field indicates whether clock pins are supported for selecting one of the devices on a shared bus.<br/>0x0: Shared bus is not supported </td>
</tr>
</tbody>
</table>

#### SD_SLOT_INT_STATUS REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xFC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>VENDOR_VER</td>
<td>R</td>
<td>0x0</td>
<td>Version Number </td>
</tr>
<tr>
<td>23:16</td>
<td>SD_VER</td>
<td>R</td>
<td>0x2</td>
<td>SD Host Specification Number <br/>0x0: Supports version 1.0 <br/>0x1: Supports version 2.0 <br/>0x2: Supports version 3.0  <br/>All other values are reserved. </td>
</tr>
<tr>
<td>15:2</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1</td>
<td>SLOT_INT1</td>
<td>R</td>
<td>0x0</td>
<td>Interrupt Line for Slot 1 </td>
</tr>
<tr>
<td>0</td>
<td>SLOT_INT0</td>
<td>R</td>
<td>0x0</td>
<td>Interrupt Line for Slot 0 </td>
</tr>
</tbody>
</table>

#### SDHC_VID_PID REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x100</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>VERSION_ID</td>
<td>R</td>
<td>0x1</td>
<td>0x1: The IP version</td>
</tr>
<tr>
<td>27:20</td>
<td>PROJECT_ID</td>
<td>R</td>
<td>0x1</td>
<td>0x1: The project version</td>
</tr>
<tr>
<td>19:0</td>
<td>VENDOR_ID</td>
<td>R</td>
<td>0xa1312</td>
<td>Stands for vendor name</td>
</tr>
</tbody>
</table>

#### SDHC_OP_CTRL REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x104</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15</td>
<td>WR_OSTDG</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls whether outstanding write requests are allowed on AXI.   <br/>0x0: Allow outstanding requests on AXI.   <br/>0x1: DO not allow outstanding requests on AXI. </td>
</tr>
<tr>
<td>14</td>
<td>RD_OSTDG</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls whether outstanding read requests are allowed on AXI.   <br/>0x0: Allow outstanding requests on AXI.   <br/>0x1: DO not allow outstanding requests on AXI. </td>
</tr>
<tr>
<td>13:8</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7</td>
<td>WR_ENDIAN</td>
<td>R/W</td>
<td>0x1</td>
<td>This field determines the endian format for the data being written to the card.<br/>1: Little Endian <br/>0: Big Endian </td>
</tr>
<tr>
<td>6</td>
<td>RD_ENDIAN</td>
<td>R/W</td>
<td>0x1</td>
<td>This field determines the endian format for the data being read from the card.<br/>1: Little Endian <br/>0: Big Endian </td>
</tr>
<tr>
<td>5</td>
<td>AXI_NON_POST_WR</td>
<td>R/W</td>
<td>0x0</td>
<td>AXI Non-post Write <br/>1: All AXI master write requests are non-post write <br/>0: Only the last request is issued as non-post write </td>
</tr>
<tr>
<td>4</td>
<td>PRIORITY</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls the priority level for AXI requests, acting as the most significant bit of the ID when requests are made<br/>0x0: low priority <br/>0x1: high priority <br/>Note: This bit should only be modified before or after the completion of a data command, not during the transaction.</td>
</tr>
<tr>
<td>3:2</td>
<td>DMA_SIZE</td>
<td>R/W</td>
<td>0x3</td>
<td>FIFO Threshold <br/>This field sets the FIFO threshold for the internal FSM to generate a DMA request to the AXI master.<br/>0x0: 64 bytes <br/>0x1: 128 bytes <br/>0x2: 192 bytes <br/>0x3: 256 bytes </td>
</tr>
<tr>
<td>1:0</td>
<td>BRST_SIZE</td>
<td>R/W</td>
<td>0x2</td>
<td>DMA Burst Size on the AXI Fabric <br/>0x0: 32 bytes burst <br/>0x1: 64 bytes burst <br/>0x2: 128 bytes   <br/>0x3: 256 bytes </td>
</tr>
</tbody>
</table>

#### SDHC_OP_EXT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x108</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CEN_DEASSERT</td>
<td>R/W</td>
<td>0x0</td>
<td>Backdoor control bit to deassert the DPSRAM CENA/CENB port. Setting this bit allows DPSRAM CLKPA/CLKPB to receive additional clock cycles.<br/>0: CEN deasserted disable <br/>1: CEN deasserted enable </td>
</tr>
<tr>
<td>30:28</td>
<td>EMA</td>
<td>R/W</td>
<td>0x7</td>
<td>DPSRAM extra time for memory read and write <br/>000: Fastest <br/>111: Slowest </td>
</tr>
<tr>
<td>27:26</td>
<td>EMAW</td>
<td>R/W</td>
<td>0x1</td>
<td>DPSRAM delay for write operation by extending the internal write pulse.  <br/>2'b00: Fastest <br/>2'b11: Slowest </td>
</tr>
<tr>
<td>25</td>
<td>EMAS</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls the extension of the DPSRAM pulse width of the sense-amplifier enable signal.<br/>The default setting is low but when driving high, the pulse is extended. </td>
</tr>
<tr>
<td>24</td>
<td>RET1N</td>
<td>R/W</td>
<td>0x1</td>
<td>Retention mode 1 enable, active low. </td>
</tr>
<tr>
<td>23:20</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>19:16</td>
<td>PRE_GATE_CLK_CNT</td>
<td>R/W</td>
<td>0x9</td>
<td>This field controls the amount of clock cycles that are provided before clock gating is enabled on the sd_clk io pad. </td>
</tr>
<tr>
<td>15</td>
<td>AUTOCMD12_XFER_ENABLE</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit is backdoor enable bit when software executes CMD25 with AutoCMD12.There are two conditions that can trigger a transfer interrupt:<br/>- Write operation busy bit check<br/>- Normal data transfer AUTOCMD12 finished<br/>Normally, a transfer interrupt is triggered only when the write operation busy bit check is completed. However, enabling this bit allows an additional interrupt trigger condition when the normal data transfer of AutoCMD12 is finished.<br/>By default, software can keep this bit set to 0.</td>
</tr>
<tr>
<td>14</td>
<td>PDLVMC</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls some power down function for the internal memory. </td>
</tr>
<tr>
<td>13</td>
<td>PDFVSSM</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls some power down function for the internal memory. </td>
</tr>
<tr>
<td>12</td>
<td>FORCE_CLK_ON</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit forces the SD I/O pad clock to remain on. <br/>Setting this field to 0x1 overrides the SD Clock I/O pad clock gate, ensuring the clock is continuously active. It is typically used together with the &lt;OVRRD_CLK_OEN&gt; field<br/>Bit[12:11] Setting:<br/>2'bx0: setting is ignored (not used) <br/>2'b01: Clocks are forced off<br/>2'b11: Clocks are forced on</td>
</tr>
<tr>
<td>11</td>
<td>OVRRD_CLK_OEN</td>
<td>R/W</td>
<td>0x0</td>
<td>Override Pad Clock Output Enable <br/>Setting this field to 0x1 overrides the SD Pad clock output enable.  It is typically used together with the &lt;FORCE_CLK_ON&gt; field. </td>
</tr>
<tr>
<td>10</td>
<td>CLK_OE_USE_POS</td>
<td>R/W</td>
<td>0x1</td>
<td>This field controls the SD/eMMC bus CLK PAD output enable signal use clock rising edge output or use clock falling edge output <br/>0: Use internal clock falling edge output (to eliminate clock signal Tri-state issue) <br/>1: Use internal clock rising edge output  </td>
</tr>
<tr>
<td>9</td>
<td>CLK_GATE_ON</td>
<td>R/W</td>
<td>0x0</td>
<td>Clock Gate On <br/>0: Enable dynmical clock gate <br/>1: Enable clock free running <br/>This field affects all clock gates in the SD design if the &lt;Clock Gate Ctl&gt; field is set to 1. </td>
</tr>
<tr>
<td>8</td>
<td>CLK_GATE_CTL</td>
<td>R/W</td>
<td>0x0</td>
<td>Clock Gate Control<br/>0: Disable software clock gating override <br/>1: Enable software clock gating override </td>
</tr>
<tr>
<td>7</td>
<td>USE_DAT3</td>
<td>R/W</td>
<td>0x0</td>
<td>This field allows the card detect functionality to be detected using the DAT[3] pin.   <br/>This field controls whether the DAT[3] pin is used for card detection.<br/>0x0: Use dedicated pin for card detection<br/>0x1: Use DAT[3] for card detection</td>
</tr>
<tr>
<td>6</td>
<td>PDWN</td>
<td>R/W</td>
<td>0x0</td>
<td>Power Down <br/>This bit controls the Power Down port on the internal DPFIFO. </td>
</tr>
<tr>
<td>5</td>
<td>FIFO_CS</td>
<td>R/W</td>
<td>0x0</td>
<td>FIFO CS <br/>This field should be written to 0x1 before any toggling of the PDWN bit. </td>
</tr>
<tr>
<td>4</td>
<td>FIFO_CLK</td>
<td>R/W</td>
<td>0x0</td>
<td>FIFO Clock <br/>This field should be set to 0x1 before any toggling of the PDWN bit. </td>
</tr>
<tr>
<td>3:2</td>
<td>WTC</td>
<td>R/W</td>
<td>0x0</td>
<td>WTC <br/>This field is used for FIFO speed setting. </td>
</tr>
<tr>
<td>1:0</td>
<td>RTC</td>
<td>R/W</td>
<td>0x0</td>
<td>RTC <br/>This field is used for FIFO speed setting. </td>
</tr>
</tbody>
</table>

#### SDHC_LEGACY_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x10C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>GEN_PAD_CLK_CNT</td>
<td>R/W</td>
<td>0x4a</td>
<td>Pad Clock Count <br/>This field should be used with &lt;gen_pad_clk_on&gt; <br/>This field configures the number of clock cycles generated on the IO pad. <br/>The default value of 0x4A generates 75 clock cycles. </td>
</tr>
<tr>
<td>23:14</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use<br/></td>
</tr>
<tr>
<td>13:9</td>
<td>SPI_ERR_TOKEN</td>
<td>R/W</td>
<td>0x0</td>
<td>SPI Error Token <br/>This is the SPI Error token received in command response when SPI mode is enabled. </td>
</tr>
<tr>
<td>8</td>
<td>SPI_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Enable SPI Mode <br/>This field indicates whether SPI mode is enabled. When enabled, the host controller drives the signals according to the SPI protocol.<br/>1 = SPI mode enabled <br/>0 = SPI mode disabled </td>
</tr>
<tr>
<td>7</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6</td>
<td>GEN_PAD_CLK_ON</td>
<td>R/WAC</td>
<td>0x0</td>
<td>Generate Pad Clock <br/>This bit works together with the &lt;gen_pad_clk_cnt&gt; field. <br/>Setting this bit to 0x1 will generate the programmed number of clock cycles on the IO pad. </td>
</tr>
<tr>
<td>5</td>
<td>SQU_FULL_CHK</td>
<td>R/W</td>
<td>0x0</td>
<td>SQU Full Check <br/>This bit should be set to 0x1 only when using a specific piece of memory in the SQU in FIFO mode and performing a "read" transaction on the SD device.</td>
</tr>
<tr>
<td>4</td>
<td>SQU_EMPTY_CHK</td>
<td>R/W</td>
<td>0x0</td>
<td>SQU Empty Check <br/>This bit should be set to 0x1 only when using a specific piece of memory in the SQU in FIFO mode and performing a "write" transaction on the SD device.</td>
</tr>
<tr>
<td>3</td>
<td>BOOT_ACK</td>
<td>R/W</td>
<td>0x0</td>
<td>Boot Acknowledgment <br/>If the boot nowledgment mode is enabled in the MMC device, then this field should be written to 0x1 before issuing the alternate boot CMD0. </td>
</tr>
<tr>
<td>2</td>
<td>INAND_SEL</td>
<td>R/W</td>
<td>0x1</td>
<td>When the driver programs the highest byte of Rx0c, the host DAT/CMD line related registers will be reset. <br/>0x1: Enable soft reset when trigger command. <br/>0x0: Disable soft reset when trigger command. </td>
</tr>
<tr>
<td>1</td>
<td>ASYNC_IO_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Asynchronous Read Interface Enable <br/>This bit enables the asynchronous latching of input data. <br/>0x1: Async interface is enabled. The clock used to latch the input data is asynchronous with the internal logic clock. <br/>0x0: Async interface is disabled. </td>
</tr>
<tr>
<td>0</td>
<td>PIO_RDFC</td>
<td>R/W</td>
<td>0x1</td>
<td>PIO mode read operation FIFO check. <br/>0x0: The system checks if all FIFO data has been read by the CPU. If not, the bus clock will stop, and the state will wait until the last block of FIFO data has been read by the CPU. Once the data is done being read, the next block will begin transferring. <br/>0x1 = The system does not check if the FIFO data has been read by the CPU. It is recommended setting this bit to 1 before use PIO mode. This is especially important in high-speed modes like HS200/SDR104, where the software must set this bit to 1 to ensure proper operation. </td>
</tr>
</tbody>
</table>

#### SDHC_LEGACY_CEATA_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x110</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>29:16</td>
<td>CPL_TIMEOUT</td>
<td>R/W</td>
<td>0x3FFF</td>
<td>Command Completion Signal Timeout Value <br/></td>
</tr>
<tr>
<td>15:3</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>CHK_CPL</td>
<td>R/W</td>
<td>0x0</td>
<td>Check Command Completion Signal <br/>When this field is set to 0x1 and the &lt;CE-ATA Card&gt; field is set to 1, indication is sent to the host controller to check for command completion signal from the CE-ATA card. </td>
</tr>
<tr>
<td>1</td>
<td>SND_CPL</td>
<td>R/W</td>
<td>0x0</td>
<td>Send Command Completion Disable Signal <br/>When this field is set to 1 and the &lt;CE-ATA Card&gt; field is set to 1, indication is sent to the host controller to send the command completion disable signal to the CE-ATA card. </td>
</tr>
<tr>
<td>0</td>
<td>CEATA_CARD</td>
<td>R/W</td>
<td>0x0</td>
<td>CE-ATA Card <br/>1: CE-ATA Card mode <br/>0: Non CE-ATA card mode  </td>
</tr>
</tbody>
</table>

#### SDHC_MMC_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x114</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>DAT_LEVEL</td>
<td>R</td>
<td>0xFF</td>
<td>MMC1_DAT[7:0] Line Signal Level <br/>This status is used to check the MMC_DAT[7:0] line level. It is useful for error recovery and debugging.<br/>This helps in detecting issues, especially the busy signal level from MMC_DAT[0]. </td>
</tr>
<tr>
<td>23:13</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>12</td>
<td>MMC_CARD</td>
<td>R/W</td>
<td>0x0</td>
<td>MMC Card <br/>1: MMC Card mode <br/>0: SD Card mode </td>
</tr>
<tr>
<td>11</td>
<td>MMC_RESETN</td>
<td>R/W</td>
<td>0x1</td>
<td>MMC Resetn  <br/>This bit controls the value of the pin MMC_RESETN going to the eMMC device.  </td>
</tr>
<tr>
<td>10</td>
<td>MMC_HS200</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit is set when host read DEVICE_TYPE[196] field of Extended CSD register in MMC card, and the card support HS200 mode. It should be set before the host clock changes to 200Mhz.  <br/>1: MMC HS200 mode enable.  <br/>0: MMC HS200 mode disable</td>
</tr>
<tr>
<td>9</td>
<td>MMC_HS400</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit is set when the host reads the DEVICE_TYPE[196] field of the Extended CSD register in the MMC card, and the card supports HS400 mode. It should be set before the host clock changes to 200 MHz, following the eMMC 5.0 specification.  <br/>1: MMC HS400 mode enable.  <br/>0: MMC HS400 mode disable</td>
</tr>
<tr>
<td>8</td>
<td>ENHANCE_STROBE_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Enhanced Strobe Enable<br/>This bit controls whether the host/PHY will use the delayed strobe signal to sample the CMD response. This feature is part of the eMMC 5.1 specification to enhance HS400 mode. Software (SW) should check the device-related EXT to decide whether the host/PHY should support this feature.</td>
</tr>
<tr>
<td>7</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6</td>
<td>CPL_COMPLETE</td>
<td>R/W1C</td>
<td>0x0</td>
<td>This bit is set to 1 when a command completion signal is detected and the &lt;cpl_complete Enable&gt; field has been set to 1. <br/>The field is cleared by writing 0x1. A write of 0x0 has no effect.</td>
</tr>
<tr>
<td>5</td>
<td>CPL_COMPLETE_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit controls whether the CPL_COMPLETE bit gets set when a command completion signal is detected. <br/>When set to 1, the CPL_COMPLETE bit will be set to 1 when a command completion signal is detected. </td>
</tr>
<tr>
<td>4</td>
<td>CPL_COMPLETE_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>cpl_complete Interrupt Enable <br/>1: An interrupt will be generated when the &lt;cpl_complete&gt; field is set </td>
</tr>
<tr>
<td>3</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>MISC_INT</td>
<td>R/W1C</td>
<td>0x0</td>
<td>Miscellaneous Interrupt<br/>This status bit is set to 1 when the programmed number of clocks in the &lt;gen_pad_clk_cnt&gt; field is completed and the &lt;misc_int_en&gt; field has been set to 0x1.<br/>This field is cleared by writing 0x1. A write of 0x0 has no effect. </td>
</tr>
<tr>
<td>1</td>
<td>MISC_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Miscellaneous Interrupt Status Enable<br/>When this bit is set to 0x1 will enable the misc_int bit to be set to 0x1 when the programmed number of clocks have been generated on the Pad. </td>
</tr>
<tr>
<td>0</td>
<td>MISC_INT_INT_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>misc_int Interrupt Enable <br/>0x1: An interrupt will be generated when the &lt;misc_int&gt; field is set to 0x1. </td>
</tr>
</tbody>
</table>

#### SDHC_RX_CFG_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x118</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:18</td>
<td>TUNING_DLY_INC</td>
<td>R/W</td>
<td>0x0</td>
<td>Tuning Delay Increment<br/>This field defines the increment value used for each step when the hardware performs auto-tuning. When the host controller takes control of the delay value during auto-tuning, this field specifies by how much the delay value will be incremented at each step.</td>
</tr>
<tr>
<td>17:8</td>
<td>SDCLK_DELAY</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls the delay value to the delay element. </td>
</tr>
<tr>
<td>7:4</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3:2</td>
<td>SDCLK_SEL1</td>
<td>R/W</td>
<td>0x0</td>
<td>This field is used for Rx data/CMD sample clock selections.<br/>This field controls the second mux selects.     <br/>0x0: Select the clock from GPIO pad feedback.     <br/>0x1: Select the clock output from DDL. If for software tuning, set this value to 0x1    <br/>0x2: Select internal clock<br/>0x3: Select internal clock</td>
</tr>
<tr>
<td>1:0</td>
<td>SDCLK_SEL0</td>
<td>R/W</td>
<td>0x0</td>
<td>This field is used for the software tuning process.  <br/>This field controls the first mux selects.   <br/>0x0: Select clock from pad   <br/>0x1: Select inverted clock from pad<br/>0x2: Select internal clock<br/>0x3: Select inverted internal clock. </td>
</tr>
</tbody>
</table>

#### SDHC_TX_CFG_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x11C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>TX_MUX_SEL</td>
<td>RW</td>
<td>0x0</td>
<td>TX output clock selection  <br/>0x0: Select clock from inverter of base clock input   <br/>0x1: Select clock from DDLLoutput clock </td>
</tr>
<tr>
<td>30</td>
<td>TX_INT_CLK_SEL</td>
<td>RW</td>
<td>0x0</td>
<td>TX output clock selection.   <br/>0x0: Select the clock from the original inverter of base clock or DDLL output clock   <br/>0x1: Select the clock from the inverter of the internal work clock, ensuring the hold time in default speed mode or high-speed mode. </td>
</tr>
<tr>
<td>29</td>
<td>TX_DLINE_SRC_SEL</td>
<td>RW</td>
<td>0x0</td>
<td>TX delayline clock source selection.   <br/>0x0: Select the base clock as TX delayline input source clock    <br/>0x1: Select the internal work clock as the TX delayline input source clock. Normally, this bit only worked at HS200 mode, but in DDR mode, if TX tuning is required, this TX delayline input clock source bit should be force to 0  </td>
</tr>
<tr>
<td>28:26</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>25:16</td>
<td>TX_HOLD_DELAY1</td>
<td>RW</td>
<td>0x37</td>
<td>This field controls the delay value of the TX delay element for SDR104 mode. </td>
</tr>
<tr>
<td>15:10</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>9:0</td>
<td>TX_HOLD_DELAY0</td>
<td>RW</td>
<td>0xc5</td>
<td>This field controls the delay value of the TX delay element for all modes other than the SDR104 mode. </td>
</tr>
</tbody>
</table>

#### SDHC_HWTUNE_CFG_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x120</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:30</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>29:20</td>
<td>TUNING_CLK_DLY</td>
<td>R</td>
<td>0x0</td>
<td>This read-only field indicates the final DDLL delay counter value after the tuning process is completed. During the tuning process, this field increments step by step. Therefore, it is typically not meaningful to read this value during hardware tuning.</td>
</tr>
<tr>
<td>19:10</td>
<td>TUNING_WD_CNT</td>
<td>R/W</td>
<td>0x0a</td>
<td>This field controls the tuning success window width. <br/>If tuning success times ≥ TUNING_WD_CNT, the tuning is considered successful. Then, hardware will select the middle of the window as the final tuning DDLL delay counter value.  <br/>The default value is 10, which aligns with the specifications, but the driver can adjust this count based on real-world conditions.</td>
</tr>
<tr>
<td>9:0</td>
<td>TUNING_TT_CNT</td>
<td>R/W</td>
<td>0x27</td>
<td>This field controls the total tuning times. <br/>The default value is 40, as specified in the specifications. The driver can adjust this count based on real-world conditions. <br/>The total number of tuning attempts is calculated as TUNING_TT_CNT + 1</td>
</tr>
</tbody>
</table>

#### SDHC_HWTUNE_CFG2_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x124</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:26</td>
<td>RSVD<br/></td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>25:16</td>
<td>TUNING_HW_START_CNT</td>
<td>R/W</td>
<td>0x0</td>
<td>This field allows software to configure the starting DLL counter value for hardware auto-tuning. The value set here determines where the hardware auto-tuning process will begin.</td>
</tr>
<tr>
<td>15:6</td>
<td>_TUNING_SUCCESS_CNT</td>
<td>R</td>
<td>0x0</td>
<td>This field provides software with a reference to determine if the tuning step (TUNING_DLY_INC) or the tuning window count (TUNING_WD_CNT) should be adjusted. It is only valid after the tuning process has completed and failed. Reading this field during the tuning process is meaningless.</td>
</tr>
<tr>
<td>5:4</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3:2</td>
<td>TUNING_HW_SDCLK_SEL1</td>
<td>R</td>
<td>0x0</td>
<td>This field is used for hardware auto-tuning, and its function is similar to the SW tuning definition at 0x118&lt;3:2&gt;.</td>
</tr>
<tr>
<td>1:0</td>
<td>TUNING_HW_SDCLK_SEL0</td>
<td>R/W</td>
<td>0x0</td>
<td>This field allows software to configure the hardware auto-tuning DLL source clock selection. It provides flexibility in choosing the clock source for the tuning process.</td>
</tr>
</tbody>
</table>

#### SDHC_ROUNDTRIP_TIMING_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x128</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:24</td>
<td>DATA0BUSY_WAIT_CYCLES</td>
<td>R/W</td>
<td>0x2</td>
<td>This field controls how many clock cycles the host should wait before checking the DATA0 busy signal after detecting the end bit of the CRC status in a write operation. This setting is mainly applicable to high-speed modes such as HS200, SDR104, and HS400.</td>
</tr>
<tr>
<td>23:20</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>19:16</td>
<td>WRDATA0_WAIT_CYCLES</td>
<td>R/W</td>
<td>0x5</td>
<td>This field is valid only when bit [2], bit [1], or bit [0] of this register is set in the corresponding speed mode.<br/>- If bit [1] or bit [0] is set, this field specifies how many cycles the host controller's internal logic should wait before changing the bus driving direction—from the end bit of DATA0 to the start bit of the CRC status—during a write operation.</td>
</tr>
<tr>
<td>15:12</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>11:8</td>
<td>CMD2RESP_WAIT_CYCLES</td>
<td>R/W</td>
<td>0x5</td>
<td>This field only valid when this register bit[2] or bit[1] or bit[0] be set at corresponding speed mode, if bit[1] or bit[0] be set, this field indicate the host controller internal logic CMD FSM should wait how many clock cycles between the bus driving direction turn around from CMD end bit to  response start bit. <br/>This field is valid only when bit [2], bit [1], or bit [0] of this register is set for the corresponding speed mode.<br/>- If bit [1] or bit [0] is set, this field specifies how many clock cycles the host controller's internal logic should wait before changing the bus driving direction—from the end bit of a CMD to the start bit of the response.</td>
</tr>
<tr>
<td>7:3</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>TRS2RCV_PARAM_EN2</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls whether, in HS400 mode, software can manually configure the number of wait cycles that should be inserted between CMD/DATA transmission and reception during direction turnaround.<br/>In HS400 mode, PHY output and input DLL latency should be enabled when setting this field.</td>
</tr>
<tr>
<td>1</td>
<td>TRS2RCV_PARAM_EN1</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls whether, in DDR50/SDR50 mode, software can manually configure the number of wait cycles that should be inserted between CMD/DATA transmission and reception during direction turnaround.</td>
</tr>
<tr>
<td>0</td>
<td>TRS2RCV_PARAM_EN0</td>
<td>R/W</td>
<td>0x0</td>
<td>This field controls whether, in HS200/SDR104 mode, software can manually configure the number of wait cycles that should be inserted between CMD/DATA transmission and reception during direction turnaround.</td>
</tr>
</tbody>
</table>

#### SDHC_GPIO_CFG_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x12C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>SDHC_GPO</td>
<td>R</td>
<td>0x0</td>
<td>Value to be driven to GPO pins. Software programs these 16-bit fields, and the values will appear on the GPO output ports of the SDHC top module.</td>
</tr>
<tr>
<td>15:0</td>
<td>SDHC_GPI</td>
<td>R</td>
<td>0x0</td>
<td>Value on GPI ports. These 16-bit fields are read-only and reflect the current state of the GPI input ports.</td>
</tr>
</tbody>
</table>

#### SDHC_DLINE_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x130</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>TX_DLINE_CODE</td>
<td>R/W</td>
<td>0x0</td>
<td>Delayline DTC delay control signals for transmission. Software programs this field during the tuning process. </td>
</tr>
<tr>
<td>23:16</td>
<td>RX_DLINE_CODE</td>
<td>R/W</td>
<td>0x0</td>
<td>Delayline DTC delay control signals for reception. Software programs this field during the tuning process. <br/></td>
</tr>
<tr>
<td>15:1</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>DLINE_PU</td>
<td>R/W</td>
<td>0x0</td>
<td>Power-up signal for delayline:   <br/>0: Power down   <br/>1: Power up  <br/>The time period from setting the power-up signal to the internal regulator voltage stabilizing is approximately 100ns.</td>
</tr>
</tbody>
</table>

#### SDHC_DLINE_CFG_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x134</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:25</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>24</td>
<td>TX_DLINE_GAIN</td>
<td>R/W</td>
<td>0x0</td>
<td>This field is only effective when TX_DLINE_REG[6] is set.<br/>1: Extended delayline delay range with decreased resolution. Typically used for a frequency of 100 MHz, where the DLL delayline is still required.<br/>0: Default setting (for 200 MHz)</td>
</tr>
<tr>
<td>23:16</td>
<td>TX_DLINE_REG</td>
<td>R/W</td>
<td>0x0</td>
<td>Set the delay line parameters for the tuned clock in HS200 and DDR52 modes.                            <br/>- Bits 7:6: Reserved<br/>- Bits 5:4: Delay line tuning range (Default: 2'b01).<br/>- Bits 3:2: Delay line LDO output voltage (Default: 2'b11):<br/>	1. 2'b00: 0.7V<br/>	2. 2'b01: 0.8V<br/>	3. 2'b10: 0.85V<br/>	4. 2'b11: 0.9V<br/>- Bit 1: Enable delay line LDO resistor load (Default: 1'b1).<br/>- Bit 0: Enable delay line LDO soft start (Default: 1'b1).</td>
</tr>
<tr>
<td>15:9</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>8</td>
<td>RX_DLINE_GAIN</td>
<td>R/W</td>
<td>0x0</td>
<td>This field is only effective when RX_DLINE_REG[6] is set.<br/>1 = Extended delayline delay range with decreased resolution. Typically used for a frequency of 100 MHz, where the DLL delayline is still required.  <br/>0 = Default (for 200Mhz case)   </td>
</tr>
<tr>
<td>7:0</td>
<td>RX_DLINE_REG</td>
<td>R/W</td>
<td>0x1F</td>
<td>set delay line parameter for tuned clock in HS200 and DDR52 mode.                            <br/>- Bits 7:6: Reserved<br/>- Bits 5:4: Delay line tuning range (Default: 2'b01).<br/>- Bits 3:2: Delay line LDO output voltage (Default: 2'b11):<br/>	1. 2'b00: 0.7V<br/>	2. 2'b01: 0.8V<br/>	3. 2'b10: 0.85V<br/>	4. 2'b11: 0.9V<br/>- Bit 1: Enable delay line LDO resistor load (Default: 1'b1).<br/>- Bit 0: Enable delay line LDO soft start (Default: 1'b1).</td>
</tr>
</tbody>
</table>

#### SDHC_PHY_CTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x160</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>HOST_LEGACY_MODE</td>
<td>R/W</td>
<td>0x0</td>
<td>This field is backdoor register for SW to use old legacy topology host mode. By default, due to EMMC5 PHY/host topology changes, clock generation logic will moved into PHY inside, PHY will output working clock to host. if SW set this bit, below factors will be true:<br/>This field is a backdoor register for software to enable the old legacy topology host mode. By default, the EMMC5 PHY/host topology has changed so that the clock generation logic is moved into the PHY, which outputs the working clock to the host. When this bit is set, the following happens: <br/>- The host will use the internal clock divider to generate the clock.<br/>- SW/HW RX tuning will be affected. The host will use the 0x118/0x130 register settings for DLL slave delayline control, instead of the new 0x168 setting for DLL slave delayline control.<br/>- The host will treat the PHY as just GPIO and use the PHY test mode interface signals (TDI/TDO/TDOE) to output/input data, CMD, and CLK.   <br/>- If the host legacy mode is set, it's recommended not to support HS400 mode. The base clock frequency should be ≤ 200MHz, with a maximum of HS200 mode.<br/>- TBD: Whether to add a backdoor delayline in the RX/TX tuning path for clock tuning (without using the PHY internal delayline).<br/>0x0: Disable Host legacy mode (default, using the new external EMMC5.0/SD PHY topology).<br/>0x1: Enable Host legacy mode.</td>
</tr>
<tr>
<td>30:24</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:16</td>
<td>PHY_DCHNL_STATUS</td>
<td>R</td>
<td>0x01</td>
<td>Indicates the current status of the PHY 8 data channel enable settings. <br/>After a reset, the hardware logic defaults to enabling the 1-bit mode data channel.</td>
</tr>
<tr>
<td>15:8</td>
<td>PHY_DCHNL_SW</td>
<td>R/W</td>
<td>0x0</td>
<td>Software-programmed 8 data channel enable signals. Each bit represents one data channel:<br/>0x1: This data channel is enabled.<br/>0x0: This data channel is disabled.<br/>> <strong>Note</strong><strong>.</strong><strong> </strong>The CMD channel is always enabled inside the PHY.</td>
</tr>
<tr>
<td>7:3</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>PHY_DCHNL_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>Controls the selection method for enabling PHY 8 data channels:  <br/>0x1: PHY data channel function is controlled by software using bits [15:8]. If this bit is set, software must configure [15:8] before using PHY for data transfer.<br/>0x0: PHY data channel function is automatically managed by host hardware.<br/>- In this mode, software can read [23:16] for the current hardware data channel status.<br/>- Normally, for eMMC, the host hardware enables all 8 data channels during initialization.<br/>- For SD, the host hardware enables 4 data channels during initialization.</td>
</tr>
<tr>
<td>1</td>
<td>PHY_PLL_LOCK</td>
<td>R/W</td>
<td>0x0</td>
<td>When following the PHY programming sequence, after enabling the PHY input source clock from APMU offset 0xE0, software should set this bit to 1 to notify the PHY that the internal 400MHz clock source is stable.<br/>0x1: PHY 400MHz clock source is stable.<br/>0x0: PHY 400MHz clock source is unstable.</td>
</tr>
<tr>
<td>0</td>
<td>PHY_FUNC_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit controls the PHY function enable signal, which is used for internal circuit reset. If the host core logic enters a lower power mode with power gating (UDR latch), phy_en should remain 0.<br/>For normal operation, software should set this bit before using the PHY and configure other PHY-related settings beforehand.<br/>- 0x1: PHY function enabled / PHY powered up.<br/>- 0x0: PHY function disabled / PHY enters lower power mode.</td>
</tr>
</tbody>
</table>

#### SDHC_PHY_FUNC_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x164</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:19</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>18</td>
<td>RX_USE_STROBE</td>
<td>R</td>
<td>0x0</td>
<td>Indicates whether the host is in HS400 DDR mode. The value is determined by the following condition:<br/>rx_use_strobe = (uhs_mode[2:0] == 110b) | hs400_mode | enhance_strobe_en; <br/>This means <strong>RX strobe is used</strong> when:<br/>- <strong>UHS mode</strong> is set to 110b<br/>- <strong>HS400 mode</strong> is enabled<br/>- <strong>Enhanced strobe</strong> is enabled</td>
</tr>
<tr>
<td>17</td>
<td>RX_USE_DLYLINE</td>
<td>R</td>
<td>0x0</td>
<td>Indicates that the host is in HS200 or SDR104 mode. The host also has a backdoor register (bit3) to set this bit in SDR50/DDR50(52) modes.</td>
</tr>
<tr>
<td>16</td>
<td>TX_USE_INVERT</td>
<td>R</td>
<td>0x0</td>
<td>This bit is set under either of the following conditions: <br/>- 0x3E&lt;2:0&gt; is set to all SDR modes. <br/>- 0x118&lt;30&gt; = 0 is set. However, when 0x118&lt;30&gt; = 1, it only affects PHY test mode output paths (TDO/TDOE signals), while all functional output data, CMD, and output enable signals are still controlled by PHY logic.</td>
</tr>
<tr>
<td>15</td>
<td>HS200_USE_RFIFO</td>
<td>R/W</td>
<td>0x1</td>
<td>This bit control whether software enables CMD line RFIFO in HS200/HS400 mode:    <br/>0x0: Disables CMD line RFIFO in HS200/HS400 mode (default for HS200 mode). In this case, the data is sampled using the Delayline output clock and directly sampled again by the host internal core clock.<br/>0x1: Enables CMD line RFIFO in HS200/HS400 mode. When RFIFO is enabled, data sampled from the Delayline output clock is sent to the Async FIFO, then popped from the FIFO and sent to the host.</td>
</tr>
<tr>
<td>14</td>
<td>RX_DIS_CKSTOP</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit is a backdoor register added by the host to prevent the clock from being stopped in the middle of a data block during FIFO overflow conditions. The clock can only be stopped during a block gap. <br/>This field is actually a backdoor register for only SDR25/HS50/DDR50 or lower mode, since for HS200/HS400 higher mode SPEC claimed could not stop the bus clock in middle of the data block. </td>
</tr>
<tr>
<td>13</td>
<td>PHY_TDI_SEL</td>
<td>R/W</td>
<td>0x1</td>
<td>This field control PHY test mode input signal TDI source selection:  <br/>0x0: TDI is sampled by PHY internal clock signal, which is the same as the host working clock (cclk_in) from PHY.   <br/>0x1: TDI is directly from PHY internal IO pad DI port. </td>
</tr>
<tr>
<td>12</td>
<td>TX_CKOUT_REVERSE</td>
<td>R/W</td>
<td>0x0</td>
<td>This field is backdoor register to control whether host controller reverse the output data phase:   <br/>0x0: Keep the original clock phase design. The odd phase is always 0, and the even phase is controlled by card_clk_en.<br/>0x1: Reverse the odd phase data to the even output port, and reverse the even phase data to the odd output port.</td>
</tr>
<tr>
<td>11</td>
<td>TX_DDR_REVERSE</td>
<td>R/W</td>
<td>0x0</td>
<td>This field is backdoor register to control whether host controller reverse the output data phase:   <br/>0x0: Keep the original design data for odd/even output phase   <br/>0x1: Reverse the odd phase data to the even output port and the even phase data to the odd output port.</td>
</tr>
<tr>
<td>10</td>
<td>RX_DDR_BKEN</td>
<td>R/W</td>
<td>0x0</td>
<td>This backdoor register controls the DDR mode RX direction in DDR50 mode. It forces PHY to use the delayline output clock to sample bus data on both edges, then outputs dq_in_o[7:0] and dq_in_e[7:0] to the host. The delayline's input clock is cki.<br/>0x1: Backdoor mode is enabled.<br/>0x0: Backdoor mode is disabled.</td>
</tr>
<tr>
<td>9</td>
<td>RFIFO_BYPASS</td>
<td>R/W</td>
<td>0x0</td>
<td>When set, the host bypasses the PHY interface Read FIFO in HS400 mode. If not set, the host uses ck_rx_cmd to directly sample the CMD in certain modes. Normally, RFIFO is used in HS400 mode because the internal clock is asynchronous with the PHY output data/CMD Rx clock. <br/>> <strong>Note</strong><strong>.</strong> This bit only works in HS400 mode. In tuning mode with a free-running clock, the DATA/CMD async read path can choose to use the data async FIFO in the host RX interface (via async_io_en, 0x10C&lt;1&gt;).</td>
</tr>
<tr>
<td>8</td>
<td>CMD_USE_EVEN</td>
<td>R/W</td>
<td>0x1</td>
<td>This bit indicates whether the CMD uses a 3/4T DS sampled signal as the controller input in enhanced HS400 mode. <br/>By default, it uses a 1/4T DS sampled signal.</td>
</tr>
<tr>
<td>7</td>
<td>PHY_TEST_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit enables PHY test mode and controls the source of pad output and output enable signals.<br/>- <strong>0x1</strong>: Enables test mode (PHY bypass mode), where the pad output is controlled by TDO (output data) and TDOE (output enable) from the host. In this mode, the host treats PHY as GPIO and uses the test mode interface signals TDI/TDO/TDOE for data, CMD, and CLK input/output.<br/>- <strong>0x0</strong>: Uses the normal EMMC function for data, CMD, and CLK paths.<br/>This field works differently from <strong>0x160&lt;31&gt; (host_legacy_mode)</strong>. While <strong>host_legacy_mode</strong> has a broader effect, this field only impacts the data, CMD, and CLK input/output paths. If this bit is set, only <strong>item 3 of 0x160&lt;31&gt;</strong> will take effect, meaning:<br/>- <strong>0x1</strong>: The host treats PHY as GPIO and uses the test mode interface signals (TDI/TDO/TDOE) for I/O.<br/>- <strong>0x0</strong>: The host uses the normal EMMC data/CMD/CLK paths.<br/>> <strong>Note</strong>: It is recommended to set this bit in the Bootrom for safety. The <strong>APMU</strong> also has a backdoor register to configure PHY bypass mode, but setting the APMU register will let TDO/TDOE come from other MFPI functions, not the EMMC controller. If this mode is used, it assumes the PHY’s internal clock generation logic is functioning, and this bit is not suitable for DDR mode backup. For full backup mode, use <strong>0x160&lt;31&gt;</strong> to rely solely on PHY’s IO pad.</td>
</tr>
<tr>
<td>6:4</td>
<td>PHY_MODE_STATUS</td>
<td>R</td>
<td>0x0</td>
<td>These 3 bits reflect current PHY working mode selection in host design, <br/>- If PHY_MODE_SWEN = 1, then the value equals PHY_MODE_SW[2:0].<br/>- If PHY_MODE_SWEN = 0, then the value reflects the hardware-controlled signal PHY_MODE_HW[2:0].</td>
</tr>
<tr>
<td>3:1</td>
<td>PHY_MODE_SW</td>
<td>R/W</td>
<td>0x0</td>
<td>These 3 bits are valid only when PHY_MODE_SWEN = 1. When enabled, the host controller uses this field instead of the internally generated PHY_MODE_HW signal.<br/>0x000: MMC Default Speed Mode (≤26 MHz), SD DS/SDR12/SDR25 (≤50 MHz)<br/>0x001: MMC HS Mode (≤50 MHz, SDR protocol), SD SDR50 (≤100 MHz)<br/>0x010: DDR50 (or DDR52)<br/>0x011: HS200 (or SDR104)<br/>0x100: HS400<br/>0x101: HS400 CMD Enhanced Mode<br/>Others: Reserved</td>
</tr>
<tr>
<td>0</td>
<td>PHY_MODE_SWEN</td>
<td>R/W</td>
<td>0x0</td>
<td>This bit allows software to control the PHY working mode selection. If set, software should ensure proper synchronization when setting this bit.</td>
</tr>
</tbody>
</table>

#### SDHC_PHY_DLLCFG_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x168</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>DLL_ENABLE</td>
<td>R/W</td>
<td>0x0</td>
<td>Enable DLL.    <br/>0: DLL function disable (power down)    <br/>1: DLL function enable (power up) </td>
</tr>
<tr>
<td>30</td>
<td>DLL_DELAY_SRC</td>
<td>R/W</td>
<td>0x0</td>
<td>PHY internal dedicated delayline input clock source selection.  <br/>0: Uses PCLK (bus clock feedback) as the default source.<br/>1: Switches to PHY internal cki (cclk_in), typically used for manual tuning in HS200 mode.</td>
</tr>
<tr>
<td>29</td>
<td>DLL_REFRESH_SW</td>
<td>R/W</td>
<td>0x0</td>
<td>Controls manual updates to the DLL_REFRESH signal:<br/>1: Triggers a manual update.<br/>0: Keeps the DLL_REFRESH signal invalid.</td>
</tr>
<tr>
<td>28</td>
<td>DLL_REFRESH_SWEN</td>
<td>R/W</td>
<td>0x0</td>
<td>1: Software manually controls DLL_REFRESH updates.<br/>0: Host Hardware manually controls DLL_REFRESH updates.</td>
</tr>
<tr>
<td>27</td>
<td>DLL_REFRESH_ENABLE</td>
<td>R/W</td>
<td>0x1</td>
<td>1: Host controller generates DLL_REFRESH signal for manually adjusting the delay of strobe signal;    <br/>0: DLL_RERRESH remains inactive</td>
</tr>
<tr>
<td>26:16</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:8</td>
<td>DLL_DELAY_CTRL</td>
<td>R/W</td>
<td>0x0</td>
<td>Controls the delay value for the PHY DLL slave delayline tuning in HS400 mode, used when the PHY does not use the internal DLL master counter to update the DLL slave. This field only takes effect when dll_reg1&lt;1&gt; (0x168&lt;1&gt;) = 1.<br/>> <strong>Note</strong><strong>.</strong><strong> </strong>In the new EMMC5.x topology, the DLL slave delay line is integrated into the PHY. For older topologies (such as those in host_legacy_mode with 0x160&lt;31&gt;=1) or for HS200/DDR50 tuning, the 0x114/0x130/0x134 registers will be used to control the tuning process.</td>
</tr>
<tr>
<td>7:6</td>
<td>DLL_VREG_CTRL</td>
<td>R/W</td>
<td>0x1</td>
<td>DLL regulator output voltage control <br/></td>
</tr>
<tr>
<td>5:4</td>
<td>DLL_FULLDLY_RANGE</td>
<td>R/W</td>
<td>0x1</td>
<td>DLL delayline full delay range </td>
</tr>
<tr>
<td>3:2</td>
<td>DLL_PREDLY_NUM</td>
<td>R/W</td>
<td>0x1</td>
<td>DLL delayline Pre-delay numbers </td>
</tr>
<tr>
<td>1</td>
<td>DLL_BYPASS_ENABLE</td>
<td>R/W</td>
<td>0x0</td>
<td>DLL Master Bypass Enable for HS400   <br/>1: DLL master is bypassed, and DLL_DELAY_CTRL directly controls the slave DLL.   <br/>0: DLL is enabled. Use delay value is from the master DLL. </td>
</tr>
<tr>
<td>0</td>
<td>DLL_REFRESH_METHOD</td>
<td>R/W</td>
<td>0x0</td>
<td>DLL master code refresh method:   <br/>After locked: refreshed by host generated dll_refresh rising edge. <br/>1: Always refreshed by ck_refresh, synchronized to the filter clock.<br/>0: Before lock: refreshed by ck_refresh. After lock: refreshed by the host-generated dll_refresh rising edge.</td>
</tr>
</tbody>
</table>

#### SDHC_PHY_DLLCFG1_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x16C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>DLL_REG4_CTRL</td>
<td>R/W</td>
<td>0x00</td>
<td>Detailed bits refer to analog PHY pin list 'dll_reg4' descriptions </td>
</tr>
<tr>
<td>23:16</td>
<td>DLL_REG3_CTRL</td>
<td>R/W</td>
<td>0x0e</td>
<td>Detailed bits refer to analog PHY pin list 'dll_reg3' descriptions </td>
</tr>
<tr>
<td>15:8</td>
<td>DLL_REG2_CTRL</td>
<td>R/W</td>
<td>0x4a</td>
<td>Detailed bits refer to analog PHY pin list 'dll_reg2' descriptions </td>
</tr>
<tr>
<td>7:0</td>
<td>DLL_REG1_CTRL</td>
<td>R/W</td>
<td>0x00</td>
<td> Detailed bits refer to analog PHY pinlist 'dll_reg1' descriptions </td>
</tr>
</tbody>
</table>

#### SDHC_PHY_DLLSTS_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x170</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>15:8</td>
<td>PHY_WORK_MODE</td>
<td>R</td>
<td>0x0</td>
<td>This field indicates the current PHY working mode flag, from PHY output signal rdo_reg2[7:0]:  <br/>- [7]: SDR26  <br/>- [6]: SDR52  <br/>- [5]: DDR52  <br/>- [4]: HS200  <br/>- [3]: HS400 <br/>- [2]: cmd__extd_mode  <br/>- [1]: start_dll  <br/>- [0]: dll_error   </td>
</tr>
<tr>
<td>7:2</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>1</td>
<td>DLL_REFRESH_STATE</td>
<td>R</td>
<td>0x0</td>
<td>This bit indicates DLL manully refresh mode refresh signal state, this bit only valid when DLL_REFRESH_EN is set.    <br/>0: No refresh    <br/>1: Manully refresh state, is from DLL_REFRESH_HW (host HW control logic) </td>
</tr>
<tr>
<td>0</td>
<td>DLL_LOCK_STATE</td>
<td>R</td>
<td>0x0</td>
<td>This bit indicates whether Master DLL is at LOCK State    <br/>0: UNLOCK State    <br/>1: LOCK State. The RX path only works in <strong>HS400</strong> and <strong>HS400_extend</strong> mode when <strong>dll_lk</strong> is set to 1'b1</td>
</tr>
</tbody>
</table>

#### SDHC_PHY_DLLSTS1_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x174</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>23:16</td>
<td>DLL_MASTER_DELAY</td>
<td>R</td>
<td>0x0</td>
<td>The newest delay value for the delay line in master DLL.   <br/>Note: This field always reflects the most recent value regardless of whether the DLL is locked or not.</td>
</tr>
<tr>
<td>15:8</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>7:0</td>
<td>DLL_SLAVE_DELAY</td>
<td>R</td>
<td>0x0</td>
<td>This field reflects the delay value currently used for Strobe Signal or the final delay value from SW/HW tuning process. </td>
</tr>
</tbody>
</table>

#### SDHC_PHY_PADCFG_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x178</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:22</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21:20</td>
<td>CLK_PU</td>
<td>R/W</td>
<td>0x0</td>
<td>CLK Pullup 2 bits resistor selection:   <br/>- 2'b00: high-Z   <br/>- 2'b01: 50K Ohm    <br/>- 2'b10: 40K Ohm    <br/>- 2'b11: 33K Ohm </td>
</tr>
<tr>
<td>19:18</td>
<td>DS_PU</td>
<td>R/W</td>
<td>0x0</td>
<td>DS Pullup 2 bits resistor selection:   <br/>- 2'b00: high-Z   <br/>- 2'b01: 50K Ohm  <br/>- 2'b10: 40K Ohm    <br/>- 2'b11: 33K Ohm  </td>
</tr>
<tr>
<td>17:16</td>
<td>CMD_PU</td>
<td>R/W</td>
<td>0x2</td>
<td>CMD Pullup 2 bits resistor selection:   <br/>- 2'b00: high-Z   <br/>- 2'b01: 50K Ohm    <br/>- 2'b10: 40K Ohm   <br/>- 2'b11: 33K Ohm   </td>
</tr>
<tr>
<td>15:14</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>13:12</td>
<td>CLK_PD</td>
<td>R/W</td>
<td>0x2</td>
<td>CLK Pulldown 2 bits resistor selection:   <br/>- 2'b00: high-Z   <br/>- 2'b01: 50K Ohm   <br/>- 2'b10: 40K Ohm   <br/>- 2'b11: 33K Ohm </td>
</tr>
<tr>
<td>11:10</td>
<td>DS_PD</td>
<td>R/W</td>
<td>0x2</td>
<td>DS Pulldown 2 bits resistor selection:   <br/>- 2'b00: high-Z   <br/>- 2'b01: 50K Ohm    <br/>- 2'b10: 40K Ohm   <br/>- 2'b11: 33K Ohm </td>
</tr>
<tr>
<td>9:8</td>
<td>CMD_PD</td>
<td>R/W</td>
<td>0x0</td>
<td> CMD Pulldown 2 bits resistor selection:   <br/>- 2'b00: high-Z   <br/>- 2'b01: 50K Ohm   <br/>- 2'b10: 40K Ohm    <br/>- 2'b11: 33K Ohm </td>
</tr>
<tr>
<td>7</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>6</td>
<td>IO_DRV_HZ</td>
<td>R/W</td>
<td>0x0</td>
<td>This backdoor bit enables the bus IO high-Z state after the Analog EMMC PHY fix for the AutoCMD23 timeout issue (when IO becomes floating or uncontrollable) during PHY_EN switching.<br/>- 1'b1: Enable High-Z state    <br/>- 1'b0: Disable High-Z state </td>
</tr>
<tr>
<td>5</td>
<td>RX_BIAS</td>
<td>R/W</td>
<td>0x1</td>
<td>- 1'b0: High current mode    <br/>- 1'b1: Low current mode   </td>
</tr>
<tr>
<td>4:3</td>
<td>SLEW_RATE</td>
<td>R/W</td>
<td>0x0</td>
<td>PAD slew rate control:    <br/>- 2'b00: Low    <br/>- 2'b01: Medium    <br/>- 2'b10: High    <br/>- 2'b11: Very high </td>
</tr>
<tr>
<td>2:0</td>
<td>DRIVE_SEL</td>
<td>R/W</td>
<td>0x4</td>
<td>For Drive Nominal Impedance selection:    <br/>- 3'b000: high-Z    <br/>- 3'b001: 200    <br/>- 3'b010: 100    <br/>- 3'b011: 66    <br/>- 3'b100: 50    <br/>- 3'b101: 40    <br/>- 3'b110: 33    <br/>- 3'b111: 33 </td>
</tr>
</tbody>
</table>

#### SDHC_PHY_PADCFG1_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x17C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>DQX_PU</td>
<td>R/W</td>
<td>0xaaaa</td>
<td>DQ Pullup  Resistor value selection, every two bits stands for one IO  selection:    <br/>- 2'b00: high-Z   <br/>- 2'b01: 50K Ohm    <br/>- 2'b10: 40K Ohm    <br/>- 2'b11: 33K Ohm </td>
</tr>
<tr>
<td>15:0</td>
<td>DQX_PD</td>
<td>R/W</td>
<td>0x0</td>
<td>DQ Pulldown Resistor value selection, every two bits stands for one IO  selection:<br/>- 2'b00: high-Z   <br/>- 2'b01: 50K Ohm    <br/>- 2'b10: 40K Ohm    <br/>- 2'b11: 33K Ohm  </td>
</tr>
</tbody>
</table>

#### SDHC_PHY_LBCTRL_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x180</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CLEAR_LB_ERR_STATUS</td>
<td>W</td>
<td>0x0</td>
<td>Write 1 to clear SDHC_PHY_LBSTS_REG register </td>
</tr>
<tr>
<td>30:3</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>START_STUCK0_DET_CLK</td>
<td>R/WAC</td>
<td>0x0</td>
<td>After operation is finished, check EMMC_LB_Err_Status Register. </td>
</tr>
<tr>
<td>1</td>
<td>START_STUCK1_DET_CLK</td>
<td>R/WAC</td>
<td>0x0</td>
<td>After operation is finished, check EMMC_LB_Err_Status Register. </td>
</tr>
<tr>
<td>0</td>
<td>LB_TEST_TRIGGER</td>
<td>R/WAC</td>
<td>0x0</td>
<td>Triggers Loopback Testing immediately. Before setting this bit, the host driver should configure the SDHC_PHY_LBCNT_REG register (offset: 0x188).<br/>- The test will run until SDHC_PHY_LBCNT_REG reaches 0, at which point the test stops and this bit clears automatically.<br/>- This bit is only effective when Loopback Mode Enable is set.</td>
</tr>
</tbody>
</table>

#### SDHC_PHY_LBFUNC_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x184</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:28</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>27:24</td>
<td>LB_DS_CNT</td>
<td>R/W</td>
<td>0x0</td>
<td>Represents the total latency from TX to RX through the PHY loopback path.<br/>- Software should program this field to match PHY characteristics.<br/>- Recommended values:<br/>	1. HS400 or HS200 with RFIFO mode: Set to 5<br/>	2. Other modes: Set to 4<br/>- Must be greater than 1.<br/>Note: this field should be &gt; 1. </td>
</tr>
<tr>
<td>23:20</td>
<td>LB_FILTER_CNT</td>
<td>R/W</td>
<td>0x0</td>
<td>The first LB_FILTER_CNT bits and the last LB_FILTER_CNT bits are ignored in the comparison process.</td>
</tr>
<tr>
<td>19:17</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>16</td>
<td>LB_CMD_MASK</td>
<td>R/W</td>
<td>0x0</td>
<td>If set, the corresponding path will not perform lookback test. </td>
</tr>
<tr>
<td>15:8</td>
<td>LB_DQ_MASK</td>
<td>R/W</td>
<td>0x0</td>
<td>If set, the corresponding path will not perform lookback test. </td>
</tr>
<tr>
<td>7:4</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3</td>
<td>LB_INVERT_CLK</td>
<td>R/W</td>
<td>0x0</td>
<td>Normally, when loopback test is triggered and data pattern starts to be driven, Ckout_e will become 1 and Ckout_o stays at 0. <br/>If this bit is set, Ckout_e will become 1 and Ckout_o stays at 0. <br/>Only valid when bit[28] is set. </td>
</tr>
<tr>
<td>2</td>
<td>CLK_PASSTH_DS</td>
<td>R/W</td>
<td>0x0</td>
<td>Controls whether the host needs to send clock control signals (wr_ck_o/wr_ck_e/wr_ck_oe) to the PHY during loopback mode.<br/>0: No need to output clock control signals to PHY. Used for HS400 mode with DS test, as the DS in loopback mode comes from the PHY’s internal free-running clock (cki).<br/>1: Required for other working modes in loopback mode. In this case, wr_ck_oe will be 1T earlier than wr_ck_o/wr_ck_e.</td>
</tr>
<tr>
<td>1</td>
<td>LB_PATTERN_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>0: Use programmable 32-bit pattern;    <br/>1: PRBS7 </td>
</tr>
<tr>
<td>0</td>
<td>LB_MODE_EN</td>
<td>R/W</td>
<td>0x0</td>
<td>Enter Loopback Mode. <br/>Normally, host driver shall only change this bit when no other operation is processing. </td>
</tr>
</tbody>
</table>

#### SDHC_PHY_LBCNT_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x188</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>LB_COMP_CNT</td>
<td>R/W</td>
<td>0x0</td>
<td>This field specifies the number of bits to be compared during the current loopback testing.<br/>- Once loopback testing starts, the host controller decrements this counter until it reaches 0.<br/>- Please note that after SW writes this field, the host will dynamically control this counter value. <br/>- During the loopback test process, this counter may be changed cycle by cycle. </td>
</tr>
</tbody>
</table>

#### SDHC_PHY_LBSTS_REG REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x18C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:22</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>21</td>
<td>LB_CLK_STUCK0_ERR</td>
<td>RC</td>
<td>0x0</td>
<td>CLK Path is stuck at 0 </td>
</tr>
<tr>
<td>20</td>
<td>LB_CLK_STUCK1_ERR</td>
<td>RC</td>
<td>0x0</td>
<td>CLK Path is stuck at 1 </td>
</tr>
<tr>
<td>19:18</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>17</td>
<td>LB_CMD_EVEN_ERR</td>
<td>RC</td>
<td>0x0</td>
<td>If set, the CMD line path failed the Loopback testing </td>
</tr>
<tr>
<td>16</td>
<td>LB_CMD_ODD_ERR</td>
<td>RC</td>
<td>0x0</td>
<td>If set, the CMD line path failed the Loopback testing  </td>
</tr>
<tr>
<td>15:8</td>
<td>LB_DQ_EVEN_ERR</td>
<td>RC</td>
<td>0x0</td>
<td>If set, the corresponding data path failed Loopback testing <br/></td>
</tr>
<tr>
<td>7:0</td>
<td>LB_DQ_ODD_ERR</td>
<td>RC</td>
<td>0x0</td>
<td>If set, the corresponding data path failed Loopback testing </td>
</tr>
</tbody>
</table>

#### CQE_CQBDCTRL_REG0 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1F0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>CQE_FSM_RST</td>
<td>R/W</td>
<td>0x0</td>
<td>- This is a backdoor register allowing software to force the CQE state machine into a stable IDLE state if the hardware encounters issues.<br/>- 1: Forces CQE FSM into IDLE state.<br/>- 0: No effect. </td>
</tr>
<tr>
<td>30:4</td>
<td>RSVD</td>
<td>R</td>
<td>0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>3:0</td>
<td>CQE_DEBUG_SEL</td>
<td>R/W</td>
<td>0x0</td>
<td>These 4 bits field register selects which internal 32-bit debug bus signals are presented in the 0x1f4 register:   <br/>- 4'b0000: Slot index & FSM informations   <br/>- 4'b0001: Slot index informations   <br/>- 4'b0010: Internal task slot fetch signals   <br/>- 4'b0011: Internal task ready signals  <br/>> <strong>Note</strong><strong>.</strong> This field is mainly intended for hardware designers to debug. </td>
</tr>
</tbody>
</table>

#### CQE_CQBDCTRL_REG1 REGISTER

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x1F4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>CQE_DEBUG_INFO</td>
<td>R</td>
<td>0x0</td>
<td>32-bit debug signal information output to software. <br/>> <strong>Note</strong><strong>.</strong> These register values may change on each cycle because the internal design logic of the CQE hardware may still be running when the software reads these values. To determine which 32-bit debug bus information is selected for output to this field, refer to 0x1F0&lt;3:0&gt;.</td>
</tr>
</tbody>
</table>
