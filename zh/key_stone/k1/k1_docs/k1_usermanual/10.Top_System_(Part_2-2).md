# 10. Top System (Part 2/2)

```
Last Version: 2025/11/18
```

## 10.1 Overview

The Top System of K1 consists of

**[Chapter 9]**

- Clock & Reset
- JTAG
- DMA
- Crypto

**[Chapter 10]**

- Timer & Watchdog
- RTC
- Mailbox
- Power Management & Lower Power Mode Control

## 10.2 Timer & Watchdog

### Introduction



The K1 includes:

- Three 32-bit general-purpose timers with programmable clock frequency
- One 16-bit Watchdog timer with programmable clock frequency

### Features



**[General-Purpose Timers]**

- Each one consists of a 32-bit Timer Clock Control Register (TCCRn) and operates as an up counter
- Programmable clock frequency with two clock inputs as follows:

  - [For fast clock] 12.8 MHz, 6.4 MHz, 3 MHz, 1 MHz
  - [For slow clock] 32.768 kHz

**[Watchdog Timer]**

- Operative as an up counter
- Programmable clock frequency with two clock inputs as follows:

  - [For fast clock] 12.8 MHz, 6.4 MHz, 3 MHz, 1 MHz
  - [For slow clock] 32.768 kHz

### Functional Description



#### Timer Unit



- **Fast Clock Selection**
  The fast clock is selectable via the Functional Clock Select field in the Clock/Reset Control Register for Timers (APBC_TIMERS_CLK_RST). All three timers (Timer 0/1/2) can operate using either the fast or slow clock

- **Timer Count Registers (TCRn)**
  Each of the three Timer Count Registers (TCRn, where n = 0, 1, or 2) is associated with three 32-bit Timer Match Registers (TMR_Tn_Mm). When the value in the Operating System Count Register (TCRn) matches a value in any of the match registers, and the interrupt-enable bit is set, the corresponding bit in the Timer Status Register (TSR) is set.

- **Interrupt Generation**
  These bits in the TSR are routed to the Interrupt Controller, which can be programmed to generate an interrupt when triggered.

- **Reprogramming Timers**
  Reprogramming any of the timer control registers (TCCR, TPLVRn, TMR_Tn_Mm, TPLCRn, TCMRn, or TILRn) while the timer is operating is not guaranteed to be valid. To safely reprogram these registers,

  - Disable the timer
  - Reprogram the timer
  - Re-enable the timer

  The functionality of one enabled timer is not affected by the programming of another timer.

The architecture of the timer unit is depicted below.

![](static/timer.png)

#### Watchdog Timer



The 16-bit Watchdog timer operates using a timer module-derived clock with a frequency of 256 Hz.

The Watchdog timer initiates a reset event when its value matches the value in the TWMR and if the TWMER[WE] bit is set. This causes the wdt_rst_src# signal to be asserted, initiating a Watchdog Timer Reset event in the system.

- Watchdog Timer Reset Mode: This mode is activated when software does not properly manage the WDT timeout, indicating potential software malfunction or data corruption. In this mode, most internal system registers are reset to their default values, with the exception of the real-time clock, which remains unaffected.
- To avoid a Watchdog Timer Reset, the software must restart the WDT before it reaches the match value, by setting the TWCR[WCR] field to restart the WDT.

> **Note.** The TWSR Register (and some other internal WDT flops), which determines whether a match event has occurred, is reset upon the assertion of power-on-reset or external-master reset. All other registers are reset upon the assertion of power-on-reset, external-master reset, or watchdog-timer reset.

When a WDT reset event occurs, the WDT generates a 4 msec-wide pulse on the wdt_rst_src# output. This keeps the system in a reset state during that period. The system goes through a reset sequence once the reset signal is de-asserted.

Writing to all WDT registers is protected by 2 access registers: TWFAR and TWSAR. Follow the steps below to enable Writes to any WDT register:

- Write the proper key value to the TWFAR register
- Write the proper key value to the TWSAR register
- Perform the write operation on the preferred WDT register.

Once this write operation is completed, the WDT registers are locked again. This process must be repeated for each subsequent write operation.

### Register Description



The base addresses of timer/watchdog registers are tabled below.

<table>
<tbody>
<tr>
<td><strong>Name</strong></td>
<td><strong>Address</strong></td>
</tr>
<tr>
<td>APB_TIMERS1_BASE</td>
<td>0xD4014000</td>
</tr>
<tr>
<td>APB_TIMERS2_BASE</td>
<td>0xD4016000</td>
</tr>
<tr>
<td>PMU_TIMERS_BASE</td>
<td>0xD4080000</td>
</tr>
<tr>
<td>SEC_TIMERS_BASE</td>
<td>0xF0616000</td>
</tr>
</tbody>
</table>

#### Timer Count Enable Register



This register contains a count enable bit for each timer. After being enabled, the corresponding TCR restarts the count from the value prescribed by the TPLVR.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>2</td>
<td>Timer #2 count enable</td>
<td>RW</td>
<td>0x0</td>
<td>Controls whether Timer #2 counts:<br/>0: Counting is disabled.<br/>1: Counting is enabled.<br/>> <strong>Note</strong><strong>.</strong> Changes do not take effect immediately due to synchronization across clock domains.</td>
</tr>
<tr>
<td>1<br/></td>
<td>Timer #1 count enable</td>
<td>RW</td>
<td>0x0</td>
<td>Controls whether Timer #1 counts:<br/>0: Counting is disabled.<br/>1: Counting is enabled.<br/>> <strong>Note</strong><strong>.</strong> Changes do not take effect immediately due to synchronization across clock domains. </td>
</tr>
<tr>
<td>0<br/></td>
<td>Timer #0 count enable</td>
<td>RW</td>
<td>0x0</td>
<td>Controls whether Timer #0 counts:<br/>0: Counting is disabled.<br/>1: Counting is enabled.<br/>> <strong>Note</strong>. Changes do not take effect immediately due to synchronization across clock domains. </td>
</tr>
</tbody>
</table>

#### Timer Count Mode Register



The TCMR contains a count mode bit for each timer. The processor TCR operates only in periodic timer mode, it does not operate in one-shot mode.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>2</td>
<td>Timer #2 count mode</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the mode of Timer #2:<br/>0: Periodic timer mode: Timer re-loads if a match occurs and PLCR != 0<br/>1: Free-run mode: Timer wraps to 0 when it reaches 0xFFFFFFFF. </td>
</tr>
<tr>
<td>1</td>
<td>Timer #1 count mode</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the mode of Timer #1:<br/>0: Periodic timer mode: Timer re-loads if a match occurs and PLCR != 0<br/>1: Free-run mode: Timer wraps to 0 when it reaches 0xFFFFFFFF. </td>
</tr>
<tr>
<td>0</td>
<td>Timer #0 count mode</td>
<td>RW</td>
<td>0x0</td>
<td>Defines the mode of Timer #0:<br/>0: Periodic timer mode: Timer re-loads if a match occurs and PLCR != 0<br/>1: Free-run mode: Timer wraps to 0 when it reaches 0xFFFFFFFF. </td>
</tr>
</tbody>
</table>

#### Timer Count Restart Register



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>2</td>
<td>T2RS</td>
<td>RW</td>
<td>0x0</td>
<td>Timer #2 count restart<br/>0: No effect<br/>1: Counting is restarted<br/>> <strong>Note</strong><strong>.</strong> Configure other registers before setting this bit to 1.</td>
</tr>
<tr>
<td>1</td>
<td>T1RS</td>
<td>RW</td>
<td>0x0</td>
<td>Timer #1 count restart<br/>0: No effect<br/>1: Counting is restarted<br/>> <strong>Note</strong><strong>. </strong>Configure other registers before setting this bit to 1.</td>
</tr>
<tr>
<td>0</td>
<td>T0RS</td>
<td>RW</td>
<td>0x0</td>
<td>Timer #0 count restart<br/>0: No effect<br/>1: Counting is restarted<br/>> <strong>Note</strong><strong>.</strong> Configure other registers before setting this bit to 1.</td>
</tr>
</tbody>
</table>

#### Timer Clock Control Register



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:7</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>6:5</td>
<td>CS_2</td>
<td>RW</td>
<td>0x0</td>
<td>Clock Source for Timer #2.<br/>- 0x0: Fast clock (AP APB Timer clock depending on APBC_TIMERSx_CLK_RST[6:4], CP APB Timer fast can only be 12.8M)<br/>- 0x1: 32.768 kHz<br/>- 0x2: 32.768 kHz<br/>- 0x3: fast clock</td>
</tr>
<tr>
<td>4</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>3:2</td>
<td>CS_1</td>
<td>RW</td>
<td>0x0</td>
<td>Clock Source for Timer #1<br/>- 0x0: Fast clock (AP APB Timer clock depending on APBC_TIMERSx_CLK_RST[6:4],  CP APB Timer fast can only be 12.8M)<br/>- 0x1: 32.768 kHz<br/>- 0x2: 32.768 kHz<br/>- 0x3: Reserved</td>
</tr>
<tr>
<td>1:0</td>
<td>CS_0</td>
<td>RW</td>
<td>0x0</td>
<td>Clock Source for Timer #0<br/>- 0x0: fast clock (AP APB Timer clock depending on APBC_TIMERSx_CLK_RST[6:4],  CP APB Timer fast can only be 12.8M)<br/>- 0x1: 32.768 kHz<br/>- 0x2: Reserved<br/>- 0x3: Fast clock</td>
</tr>
</tbody>
</table>

#### Timer Match Register



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x10~0x18(0x4)/0x20~0x28(0x4)/0x30~0x38(0x4)</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>TMR_TN_MM</td>
<td>RW</td>
<td>0xFFFFFFFF</td>
<td>Timer n Match register m value.<br/>This register holds the value used for the match comparison for Timer n (where n is the timer number, e.g., Timer 0, Timer 1, or Timer 2). When the timer counter reaches this value, a match event occurs.</td>
</tr>
</tbody>
</table>

#### Timer Preload Value Register



Each TCR has a 32-bit-wide Preload Value register that loads the TCRn when a match occurs between TMR_Tn_Mm and TCRn. The corresponding TPLCRn register selects the match comparator.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x40~0x48(0x4)</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>TPLVRn</td>
<td>RW</td>
<td>0x0</td>
<td>Timer n preload value that is loaded into TCRn when a match occurs between TMR_Tn_Tm and TCRn. The corresponding TPLCRn register selects the match comparator. </td>
</tr>
</tbody>
</table>

#### Timer Preload Control Register



Each TCR has a Preload Control register.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x50~0x58(0x4)</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>2</td>
<td>CRPD</td>
<td>RW</td>
<td>0x0</td>
<td>Disable preload when counter restar<br/>- 0x0: Preload the PLCR to counter when the restart bit is set;<br/>- 0x1: Disable preload of the PLCR to counter when the restart bit is set.</td>
</tr>
<tr>
<td>1:0</td>
<td>MCS</td>
<td>RW</td>
<td>0x0</td>
<td>Match comparator selection:<br/>- 0x0: Free running mode (up to max value)<br/>- 0x1: Enable preload with match comparator 0<br/>- 0x2: Enable preload with match comparator 1<br/>- 0x3: Enable preload with match comparator 2</td>
</tr>
</tbody>
</table>

#### Timer Interrupt Enable Register



Each of these three counter registers contain one enable bit, which determines whether a match between a Match register & the operating-system timer counter will set a status bit in the Timer Status Register (TSR) and assert the corresponding timer#_irq output.

> **Note**. Clearing an enable bit does not reset the corresponding interrupt status bit if it has already been set.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x60~0x68(0x4)</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>2</td>
<td>IE2</td>
<td>RW</td>
<td>0x0</td>
<td>Interrupt enable for match comparator 2.<br/>0: Disable interrupt for match between Match register 2 and its OS timer (no interrupt assertion).<br/>1: Enable interrupt for match between Match register 2 and its OS timer (interrupt assertion in TSRn or timer#_irq output). </td>
</tr>
<tr>
<td>1</td>
<td>IE1</td>
<td>RW</td>
<td>0x0</td>
<td>Interrupt enable for match comparator 1.<br/>0: Disable interrupt for match between Match register 1 and its OS timer (no interrupt assertion).<br/>1: Enable interrupt for match between Match register 1 and its OS timer (interrupt assertion in TSRn or timer#_irq output). </td>
</tr>
<tr>
<td>0</td>
<td>IE0</td>
<td>RW</td>
<td>0x0</td>
<td>Interrupt enable for match comparator 0.<br/>0: Disable interrupt for match between Match register 0 and its OS timer (no interrupt assertion).<br/>1: Enable interrupt for match between Match register 0 and its OS timer (interrupt assertion in TSRn or timer#_irq output). </td>
</tr>
</tbody>
</table>

#### Timer Interrupt Clear Register



These three registers contain a separate clear bit for each interrupt source, which is used to reset the level-sensitive interrupt request directed to the interrupt controller. Each match register has its own corresponding clear bit. The interrupt is cleared by writing to the respective bit position.

> **Note.** This register is not applicable for edge-sensitive interrupts.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x70~0x78(0x4)</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>2</td>
<td>TCLR2</td>
<td>WO</td>
<td>0x0</td>
<td>Interrupt clear for match comparator 2<br/>0: No affect<br/>1: Clear the level interrupt and corresponding status bit </td>
</tr>
<tr>
<td>1</td>
<td>TCLR1</td>
<td>WO</td>
<td>0x0</td>
<td>Interrupt clear for match comparator 1<br/>0: No affect<br/>1: Clear the level interrupt and corresponding status bit </td>
</tr>
<tr>
<td>0</td>
<td>TCLR0</td>
<td>WO</td>
<td>0x0</td>
<td>Interrupt clear for match comparator 0<br/>0: No affect<br/>1: Clear the level interrupt and corresponding status bit </td>
</tr>
</tbody>
</table>

#### Timer Status Register



These three Status registers contain status bits indicating whether a match has occurred on any of the three Match registers of a given Timer Count register, in particular:

- These bits are set when a match event occurs on the next rising edge of the respective clock
- They are cleared by writing a logical one to the corresponding bit position of TICLRn

This register reflects level-sensitive interrupt status only, edge-sensitive interrupts are not captured in this register.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x80~0x88(0x4)</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:3</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>2</td>
<td>M2</td>
<td>RO</td>
<td>0x0</td>
<td>Match status of TMR_Tn_M2.<br/>0: Timer Match register TMR_Tn_M2 has not matched the counter since the last interrupt clear.<br/>1: Timer Match register TMR_Tn_M2 has matched the counter since the last interrupt clear </td>
</tr>
<tr>
<td>1</td>
<td>M1</td>
<td>RO</td>
<td>0x0</td>
<td>Match status of TMR_Tn_M1.<br/>0: Timer Match register TMR_Tn_M1 has not matched the counter since the last interrupt clear.<br/>1: Timer Match register TMR_Tn_M1 has matched the counter since the last interrupt clear </td>
</tr>
<tr>
<td>0</td>
<td>M0</td>
<td>RO</td>
<td>0x0</td>
<td>Match status of TMR_Tn_M0.<br/>0: Timer Match register TMR_Tn_M0 has not matched the counter since the last interrupt clear.<br/>1: Timer Match register TMR_Tn_M0 has matched the counter since the last interrupt clear.</td>
</tr>
</tbody>
</table>

#### Timer Count Register



Three read-only Timer Count registers (TCRn, where n = 0, 1, 2) are 32-bit counters that increment on the rising edge of their selected clocks, in particular:

- The Timer Count registers have been synchronized from timer clock domain to APB clock domain. Software can directly read these registers to use.
- The counters are pre-loaded with a value from the TPLVR register. When enabled, counters start from pre-loaded values (defined in the corresponding TPLCRn register), and count up to either a maximum or matched value.
- This request requires up to three timer clock cycles. If the selected timer is working at a slow clock, the request could take longer.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x90~0x98(0x4)</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>TCRN</td>
<td>RO</td>
<td>0x0</td>
<td>Timer n count register.<br/>- The counter is incremented on the rising edge of the selected clock. <br/>- These registers have been synchronized to APB clock domain. </td>
</tr>
</tbody>
</table>

#### Timer Watchdog First Access Register



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xB0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>15:0</td>
<td>KEY</td>
<td>WO</td>
<td>0x0</td>
<td>Watchdog access key.<br/>Writing the value of 0xBABA to this register matches the key.</td>
</tr>
</tbody>
</table>

#### Timer Watchdog Second Access Register



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xB4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>15:0</td>
<td>KEY</td>
<td>WO</td>
<td>0x0</td>
<td>Watchdog access key.<br/>Writing the value of 0xEB10 to this register matches the key.</td>
</tr>
</tbody>
</table>

#### Timer Watchdog Match Enable Register



The Watchdog Enable register contains a WDT enable bit that can only be set by the user. The write access to this register is protected by the TWFAR and TWSAR Access Registers.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xB8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:2</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>1</td>
<td>WRIE</td>
<td>RW</td>
<td>0x0</td>
<td>Watchdog reset/interrupt enable.<br/>0: Watchdog timer expiration generates a watchdog interrupt (no watchdog timer reset)<br/>1: Watchdog timer expiration generates a watchdog timer reset, (no watchdog interrupt) </td>
</tr>
<tr>
<td>0</td>
<td>WE</td>
<td>RW</td>
<td>0x0</td>
<td>WDT count enable.<br/>0 = Disable WDT count, reset WDT's value to zero.<br/>1 = Enable counting, the WDT always starts from zero.<br/>> <strong>Note</strong><strong>. </strong>Due to the chain of synchronizers that transform this signal from domain to domain, the WDT timer enable and disable operation do not occur immediately.</td>
</tr>
</tbody>
</table>

#### Timer Watchdog Match Register



This Match register is compared to the watchdog timer. The watchdog timer resets the processor when a match occurs and the TWER[WRIE] bit is set.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xBC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>15:0</td>
<td>WTM</td>
<td>RW</td>
<td>0xFFFF</td>
<td>16-bit watchdot timer match value</td>
</tr>
</tbody>
</table>

#### Timer Watchdog Status Register



This register indicates whether a WDT reset has occurred and caused a system reset, in particular:

- This bit is set when wdt_src_rst# is asserted
- It is cleared by writing a logical 0 to this register
- Clearing this bit is not required for the WDT to be re-activated after a WDT reset event

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>0</td>
<td>WTS</td>
<td>RW</td>
<td>0x0</td>
<td>Watchdog timer reset indication.<br/>Indicates that reset was caused by the WDT.<br/>Read:<br/>0: Watchdog timer did not cause reset because this bit was cleared.<br/>1: Watchdog timer caused a reset.<br/>Write:<br/>0: Clears the WDT reset status.<br/>1: No affect.</td>
</tr>
</tbody>
</table>

#### Timer Watchdog Interrupt Clear Register



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>0</td>
<td>WICLR</td>
<td>WO</td>
<td>0x0</td>
<td>WDT Interrupt clear.<br/>Write:<br/>0: No affect.<br/>1: Clear interrupt.</td>
</tr>
</tbody>
</table>

#### Timer Watchdog Counter Reset Register



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>0</td>
<td>WCR</td>
<td>WO</td>
<td>0x0</td>
<td>Watchdog timer counter value reset.<br/>Write:<br/>0: No effect.<br/>1: Clears the value of WDT counter.</td>
</tr>
</tbody>
</table>

#### Timer Watchdog Value Register



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xCC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>Reserved</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use.</td>
</tr>
<tr>
<td>15:0</td>
<td>WTV</td>
<td>RO</td>
<td>0x0</td>
<td>Watchdog timer value.<br/>Read the current value of WDT. <br/>Since the register may be in transition during a read operation, software must perform a double read and compare the two values to ensure accuracy.</td>
</tr>
</tbody>
</table>

## 10.3 RTC

### Introduction



The RTC module is capable of counting real time in the unit of seconds independent of the system clock frequency.

### Features



- Count of the number of seconds basing on the internal 1-Hz clock
- Possibility to calibrate the frequency of the internal oscillator
- Support for an alarm interrupt and 1-Hz interrupt

### Functional Description



The RTC module includes a 32-bit counter for recording real time in the unit of seconds. The system clock is divided into an internal 1-Hz clock for real time counting. Users can configure the initial RTC value based on their preferred settings. The counter value is not affected by transitions into and out of sleep or idle modes.

The RTC is configurable to generate two kinds of interrupt as follows:

- Alarm interrupt
- 1-Hz interrupt

There are two RTC modules in the system:

- Non-secure RTC
- Secure RTC

The secure RTC is only accessible by the secured core, and is reseted by power-on reset, not APB bus reset.

### Register Description



The base addresses of RTC registers are tabled below.

<table>
<tbody>
<tr>
<td><strong>Name</strong></td>
<td><strong>Address</strong></td>
</tr>
<tr>
<td>Non-secure RTC</td>
<td>0xD401_0000</td>
</tr>
<tr>
<td>Secure RTC</td>
<td>0xD401_0400</td>
</tr>
</tbody>
</table>

#### RTC COUNTER REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Time Count</td>
<td>RW<br/></td>
<td>0x0</td>
<td>Time Count of the real time counter, updated at a 1-Hz clock rate.</td>
</tr>
</tbody>
</table>

#### RTC ALARM REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Alarm Time </td>
<td>RW<br/></td>
<td>0x0</td>
<td>Alarm Time for interrupt generation.</td>
</tr>
</tbody>
</table>

#### RTC STATUS REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:4</td>
<td>Reserved</td>
<td>RO<br/></td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>3</td>
<td>1-Hz interrupt enable</td>
<td>RW<br/></td>
<td>0x0</td>
<td>Enables 1-Hz interrupt:<br/>0x0: Not Enabled<br/>0x1: Enabled</td>
</tr>
<tr>
<td>2</td>
<td>RTC alarm interrupt enable</td>
<td>RW<br/></td>
<td>0x0</td>
<td>Enables RTC alarm interrupt:<br/>0x0: Not Enabled<br/>0x1: Enabled</td>
</tr>
<tr>
<td>1</td>
<td>1-Hz rising edge detected</td>
<td>W1C</td>
<td>0x0</td>
<td>Flag indicating detection of an 1-Hz rising edge.<br/>Writing 1 clears the 1-Hz interrupt.</td>
</tr>
<tr>
<td>0</td>
<td>RTC alarm detected</td>
<td>W1C</td>
<td>0x0</td>
<td>Flag indicating detection of an RTC alarm.<br/>Writing 1 clears the RTC alarm interrupt.</td>
</tr>
</tbody>
</table>

#### RTC TRIM REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Locking bit for the trim value</td>
<td>RW<br/></td>
<td>0x0</td>
<td>Locking bit for the trim value.</td>
</tr>
<tr>
<td>30:26</td>
<td>Reserved</td>
<td>RO<br/></td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>25:16</td>
<td>Trim delete count</td>
<td>RW<br/></td>
<td>0x0</td>
<td>This value represents the number of 32-kHz clocks to delete when clock trimming begins.</td>
</tr>
<tr>
<td>15:0</td>
<td>Clock divider count</td>
<td>RW<br/></td>
<td>0x7FFF</td>
<td>This value is the integer portion of the clock trim logic.</td>
</tr>
</tbody>
</table>

#### RTC CONTROL REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x10</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>Reserved</td>
<td>RO<br/></td>
<td>0x0</td>
<td>Reserved<br/></td>
</tr>
<tr>
<td>0</td>
<td>Controls the ALARM signal</td>
<td>RW<br/></td>
<td>0x0</td>
<td>This bit enables software control on the ALARM signal that is generated by the processor, and signals any external device that is currently running. So the ALARM signal could be asserted by either software or hardware.<br/>0x0: off (ALARM negated)<br/>0x1: on (ALARM asserted)</td>
</tr>
</tbody>
</table>

#### RTC BACKUP REGISTERS



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x14~0x24</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>Backup data</td>
<td>RW<br/></td>
<td>0x0</td>
<td>The processor RTC has five back-up registers that store erasable data. The processor can read and write all five 32-bit registers.</td>
</tr>
</tbody>
</table>

## 10.4 MailBox

### Introduction



The Mailbox is designed to deliver messages or signals between SoC and MCU subsystem

### Features



- A processor is allow to generate an interrupt for another processor
- Support for a polling word to enable signaling an event from one party to another without the need of interrupts
- Reception of an ACK interrupt indicates that the other party is active
- A processor can wake up another processor (supported)

### Functional Description



The architecture of the Mailbox is depicted below.

![](static/Mailbox.png)

### Register Description



With reference to the previous **Chapter 7** & **Chapter 8**,

- In X60™ subsystem, the mailbox base address is 0xD4013400 and the interrupt number is 52
- In Audio subsystem, the mailbox base address is 0xC088A000 and the interrupt number is 30

#### ISRR REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>reserved</td>
<td>R</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>15:0</td>
<td>APB_MBOX_ISRR</td>
<td>R<br/></td>
<td>0x0</td>
<td>Used to obtain the ISRW value of the other side Mailbox.<br/></td>
</tr>
</tbody>
</table>

#### WDR REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>APB_MBOX_WDR</td>
<td>W<br/></td>
<td>0x0</td>
<td>Write Data<br/>Includes a 32-bit control word to be transferred to the other side (that will poll it). The content of this word is defined by application.</td>
</tr>
</tbody>
</table>

#### ISRW REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>reserved</td>
<td>R</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>15:0</td>
<td>APB_MBOX_ISRW</td>
<td>W</td>
<td>0x0</td>
<td>Interrupt Set<br/>This register allows setting 4 different interrupts in the other side's interrupt controller.<br/>An interrupt can be set by writing 1 to the corresponding interrupt bit in this register, as described below:<br/>- Setting bit [10] would generate a SET_GP_INT in the other side's interrupt controller.<br/>- Setting bit [9] would generate a SET_MSG_INT in the other side's interrupt controller.<br/>- Setting bit [8] would generate a SET_CMD_INT in the other side's interrupt controller.<br/>- Setting any one of bits [7:0] would generate a single interrupt called DATA_ACK interrupt.<br/>Once an interrupt is set, the corresponding bit is automatically cleared by hardware.</td>
</tr>
</tbody>
</table>

#### ICR REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>reserved</td>
<td>R</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>15:0</td>
<td>APB_MBOX_ICR</td>
<td>W</td>
<td>0x0</td>
<td>Interrupt Clear<br/>Used to clear an interrupt asserted by the other side. <br/>- Writing <strong>1</strong> to a specific bit clears the corresponding interrupt. <br/>- No need to write <strong>0</strong> after <strong>1 </strong>— the bit is cleared automatically.</td>
</tr>
</tbody>
</table>

#### IIR REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>reserved</td>
<td>RSVD</td>
<td>0xX</td>
<td>Reserved<br/>Reserved. Always write 0. Ignore read value.</td>
</tr>
<tr>
<td>15:0</td>
<td>APB_MBOX_IIR</td>
<td>RO</td>
<td>0x0</td>
<td>This register is used to read the interrupt source received from the other side. If the Mailbox was identified as the interrupt source, the Interrupt Identification Register can be read to identify which of the 11 possible Mailbox interrupts was asserted.<br/>> <strong>Note</strong><strong>s.</strong><br/>> - When [10:8] were the only bits to be asserted, reading the Interrupt Identification Register is redundant, since there is a one-to-one mapping between the interrupt source and interrupt representation on the Interrupt Identification Register. However, when the received interrupt is DATA_ACK interrupt, the Interrupt Identification Register must be read to identify the interrupt cause.<br/>> - Before reading this register, a dummy write operation (to any Mailbox address range) must be performed to latch the data to the read register. Without performing the write before the read operation, data will not be updated and old data will be read.</td>
</tr>
</tbody>
</table>

#### RDR REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0x14</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:0</td>
<td>APB_MBOX_RDR</td>
<td>RO</td>
<td>0x0</td>
<td>This register is used to poll the Write Data Register of the other side.<br/>> <strong>Note</strong><strong>.</strong> Before reading this register, a dummy write operation (to any Mailbox address range) must be performed to latch the data to the read register. Without performing the write before the read operation, data will not be updated and old data will be read.</td>
</tr>
</tbody>
</table>

## 10.5 Power Management & Lower Power Mode Control

### Introduction



Various power domains and fine-granularity power states are defined and implemented on the chip to achieve significant power-savings.

### Features



- Two power management units distributed on the chip to take control of power-on/off sequence
- Different power domains implemented to achieve power-savings for different scenarios
- Various power states and wake-up events defined to meet various product applications

### Functional Description



#### Power Management Unit (PMU)



A two-level power management strategy is implemented to control various granularities of power consumption. Different power domains and power states are also defined to achieve ultra-low power consumption. The two power management units are as follows:

- **Main PMU (MPMU)**
  The Main PMU is responsible for chip-level power management. Once the Application Subsystem PMU (APMU) enters the lowest power state, the Main PMU takes control of the chip-level low-power states.
  For details of the power on/off sequence, refer to **Section 5.4**

- **Application Subsystem PMU (APMU)**
  The Application Subsystem PMU consists of the following major parts:

  - RISCV X60™ Processor clock and low-power mode state machine.
    This state machine controls clock generation for the RISCV X60™ processors. It also generates the sequence of entry into and exit of the RISCV X60™ processor low-power modes.
  - AXI Fabric and DDR clocking and low power mode state machine.
    This  state machine controls clock generation for both bus-matrix and DDR. Once the RISCV X60™ processor state machine is in low-power mode, it controls the entry and exit sequence into and out of the bus and DDR low-power modes.

The Application Subsystem PMU takes in charge of X60™ and AXI/DDR power management. Once the Application Subsystem PMU enters into low power mode, the Main PMU then takes over control and may place K1 in chip-level sleep mode according to the Main PMU controls.

#### Power Domains & States



A total of 9 power domains are implemented, and they are for

- CPU cores

  > **Note.** Each CPU core has its own power domain independently controlled
  >
- CPU clusters

  > **Note.** Each CPU cluster has its own power domain independently controlled
  >
- Video Encoder/Decoder
- GPU
- HDMI Display Subsystem
- MIPI DSI Subsystem
- Video Input Subsystem
- RCPU (including N308, Audio Codec, RCPU Peripherals)
- Always-On-Domain (AON)

All those power domains, except AON, can be powered off depending on specific application scenarios.

In order to achieve the minimal power consumption, different power states are designed as tabled below:

<table>
<tbody>
<tr>
<td><strong>No.</strong></td>
<td><strong>Power State Name</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>1</td>
<td>ACTIVE </td>
<td>The system is alive and active, with all power domains on, except those power domains with power switches that can be turned off selectively and independently.</td>
</tr>
<tr>
<td>2</td>
<td>CORE-IDLE</td>
<td>Each core stops executing instructions and enters an idle state, with clock gating automatically after a Wait-for-Interrupt (WFI) execution. The core exits this state  when receiving an interrupt routed to it and continues execution.</td>
</tr>
<tr>
<td>3</td>
<td>Core-Power-Off</td>
<td>Each core, when voted, enters a power-off state after Core-Idle sleep mode. The core exits this state when receiving an interrupt, with power turned on and reset released.</td>
</tr>
<tr>
<td>4</td>
<td>CPU-Cluster-Power-Off<br/></td>
<td>Each CPU cluster, when voted, enters this low-power state after all cores within this cluster have entered the Core-Power-Off state, with L2/TCM memory also shut down. <br/>Any active interrupt routing to CPU cores in this cluster would bring CPU cluster out of this state, then power on, clock resume and reset release.  </td>
</tr>
<tr>
<td>5</td>
<td>Home-Screen</td>
<td>The main bus fabric AXI clock is gated off (if voted) after both CPU clusters enter CPU-Cluster-Power-Off mode.<br/>Any interrupt will wake up the chip from this state by resuming the main bus AXI clock, and powering up the corresponding CPU cluster and CPU core to which the interrupt is routed, resuming the CPU clock, and releasing the reset to service the interrupt routine. </td>
</tr>
<tr>
<td>6</td>
<td>Chip-Sleep</td>
<td>This is the most ultra-low power state, with all PLLs/Power islands off. Only 32K RTC clock remains alive, and the 24M VCXO can be configured to be on or off. <br/>In this state only the logic/IO in AON domain alives, and a pin named SLEEP_OUT connected to PMIC would be deasserted to signal PMIC to lower the VCC power supply voltage to reduce lower power comsumption.</td>
</tr>
<tr>
<td>7</td>
<td>RCPU with SOC LP</td>
<td>RCPU power domain is an independent power island and can function in any of above PMU states. RCPU can vote for different SoC low-power states according to its specific scenario requirements. <br/>The RCPU itself has four low-power states as follows: <br/>- Active Mode: Clock running<br/>- ClkGate Mode: Clock gating <br/>- PLL Off Mode: PLL powered off<br/>- Power Off Mode: RCPU power is shut down, but the RCPU AON domain remains alive</td>
</tr>
</tbody>
</table>

> **Note. **VPU, GPU, ISP, DPU power islands can be turned on or off by software, and are independent of the power states No. 1~5 in the table above

#### Wake-Up Resource



In the **Chip-Sleep Low Power State**, the following interrupts or events can wake-up the chip:

- Pad edge detection
- Keypad press
- RTC / Timer / WDT
- USB / RCPU / AP2AUDIO_IPC
- SD / EMMC / PCIE
- PMIC

In the **RCPU Power-Off State**, the following interrupts or events can wake-up RCPU PMU to resume its power supply:

- Audio plug interrupt / Hook key interrupt / Class-G short power interrupt / Audio OCP interrupt
- AP IPC power-on request
- RCPU AON Timer wakeup request
- Sensor-Hub GPIO wakeup request

### Register Description



#### POWER MODE STATUS REGISTER



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4050000+0x1030</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>PWRMODE_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>This field indicates which low power state the system has entered or exited. Each bit corresponds to a different low power mode. If set to 1, it indicates that the respective low power mode has occurred. The status is cleared by setting the corresponding bit in CLR_PWRMODE_STATUS to 1.<br/>- bit0: D1P mode <br/>- bit1: D1PP mode  <br/>- bit2: D1 mode <br/>- bit3: D2 mode <br/>- bit4: D2P  <br/>- bit5: D2PP mode <br/>- bit6: cluster0 M2 <br/>- bit7: cluster1 M2 <br/>- bit8: cluster2 M2  <br/>- bit9: cr5 C2  <br/>- bit10: comm_top D2</td>
</tr>
<tr>
<td>15:0</td>
<td>CLR_PWRMODE_STATUS</td>
<td>RW</td>
<td>0x0</td>
<td>Clear Power Mode Status. <br/>Set 1 to clear the corresponding PWRMODE_STATUS bit. </td>
</tr>
</tbody>
</table>

#### WAKEUP AND CLOCK RESUME LINES STATUS REGISTER (AWUCRS)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4050000+0x10</strong><strong>48</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>Audio</td>
<td>RW</td>
<td>0x0</td>
<td>Audio wake-up</td>
</tr>
<tr>
<td>30</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>29</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>28</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>27</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>26</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>25</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>24</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>23</td>
<td>SDH1_AUDIO</td>
<td>RO</td>
<td>0x0</td>
<td>SDH1 wake-up </td>
</tr>
<tr>
<td>22</td>
<td>SDH2_SDH3</td>
<td>RO</td>
<td>0x0</td>
<td>SDH2/SDH3 wake-up </td>
</tr>
<tr>
<td>21</td>
<td>KEYPRESS</td>
<td>RO</td>
<td>0x0</td>
<td>Key press <br/></td>
</tr>
<tr>
<td>20</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>19</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>18</td>
<td>WDT</td>
<td>RO</td>
<td>0x0</td>
<td>WDT </td>
</tr>
<tr>
<td>17</td>
<td>RTC_ALARM</td>
<td>RO</td>
<td>0x0</td>
<td>RTC ALARM </td>
</tr>
<tr>
<td>16</td>
<td>PMU_TIMER_3</td>
<td>RO</td>
<td>0x0</td>
<td>PMU Timer 3 </td>
</tr>
<tr>
<td>15</td>
<td>PMU_TIMER_2</td>
<td>RO</td>
<td>0x0</td>
<td>PMU Timer 2 </td>
</tr>
<tr>
<td>14</td>
<td>PMU_TIMER_1</td>
<td>RO</td>
<td>0x0</td>
<td>PMU Timer 1 </td>
</tr>
<tr>
<td>13</td>
<td>AP2_TIMER_3</td>
<td>RO</td>
<td>0x0</td>
<td>AP2 Timer 3 </td>
</tr>
<tr>
<td>12</td>
<td>AP2_TIMER_2</td>
<td>RO</td>
<td>0x0</td>
<td>AP2 Timer 2 </td>
</tr>
<tr>
<td>11</td>
<td>AP2_TIMER_1</td>
<td>RO</td>
<td>0x0</td>
<td>AP2 Timer 1 </td>
</tr>
<tr>
<td>10</td>
<td>AP1_2_TIMER_3</td>
<td>RO</td>
<td>0x0</td>
<td>AP1 Timer 3 and SEC Timer 3 </td>
</tr>
<tr>
<td>9</td>
<td>AP1_2_TIMER_2</td>
<td>RO</td>
<td>0x0</td>
<td>AP1 Timer 2 and SEC Timer 2 </td>
</tr>
<tr>
<td>8</td>
<td>AP1_2_TIMER_1</td>
<td>RO</td>
<td>0x0</td>
<td>AP1 Timer 1 and SEC Timer 1 </td>
</tr>
<tr>
<td>7</td>
<td>WAKEUP7</td>
<td>RO</td>
<td>0x0</td>
<td>Wakeup7 line in status </td>
</tr>
<tr>
<td>6</td>
<td>WAKEUP6</td>
<td>RO</td>
<td>0x0</td>
<td>Wakeup6 line in status </td>
</tr>
<tr>
<td>5</td>
<td>WAKEUP5</td>
<td>RO</td>
<td>0x0</td>
<td>Wakeup5 line in status </td>
</tr>
<tr>
<td>4</td>
<td>WAKEUP4</td>
<td>RO</td>
<td>0x0</td>
<td>Wakeup4 line in status </td>
</tr>
<tr>
<td>3</td>
<td>WAKEUP3</td>
<td>RO</td>
<td>0x0</td>
<td>Wakeup3 line in status </td>
</tr>
<tr>
<td>2</td>
<td>WAKEUP2</td>
<td>RO</td>
<td>0x0</td>
<td>Wakeup2 line in status </td>
</tr>
<tr>
<td>1</td>
<td>WAKEUP1</td>
<td>RO</td>
<td>0x0</td>
<td>Wakeup1 line in status </td>
</tr>
<tr>
<td>0</td>
<td>WAKEUP0</td>
<td>RO</td>
<td>0x0</td>
<td>Wakeup0 line in status </td>
</tr>
</tbody>
</table>

#### WAKEUP AND CLOCK RESUME LINES MASK REGISTER (AWUCRM1)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4050000+0x1044</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>0</td>
<td>IPC_AP2AUD_INT</td>
<td>RW</td>
<td>0x0</td>
<td>Enable ipc_ap2aud_int </td>
</tr>
</tbody>
</table>

#### WAKEUP AND CLOCK RESUME LINES STATUS REGISTER (AAWUCRM0)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4050000+0x104C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>AUDIO_WAKEUP</td>
<td>RW</td>
<td>0x0</td>
<td>Enable audio wake-up </td>
</tr>
<tr>
<td>30</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>29</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>28</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>27</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>26</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>25</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>24</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>23</td>
<td>SDH1_AUDIO</td>
<td>RW</td>
<td>0x0</td>
<td>Enable SDH1 wake-up </td>
</tr>
<tr>
<td>22</td>
<td>SDH2_SDH3</td>
<td>RW</td>
<td>0x0</td>
<td>Enable SDH2/SDH3 wake-up </td>
</tr>
<tr>
<td>21</td>
<td>KEYPRESS</td>
<td>RW</td>
<td>0x0</td>
<td>Enable key press wake-up </td>
</tr>
<tr>
<td>20</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>19</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>18</td>
<td>WDT</td>
<td>RW</td>
<td>0x0</td>
<td>Enable WDT </td>
</tr>
<tr>
<td>17</td>
<td>RTC_ALARM</td>
<td>RW</td>
<td>0x0</td>
<td>Enable RTC ALARM </td>
</tr>
<tr>
<td>16</td>
<td>PMU_TIMER_3</td>
<td>RW</td>
<td>0x0</td>
<td>Enable PMU Timer 3 </td>
</tr>
<tr>
<td>15</td>
<td>PMU_TIMER_2</td>
<td>RW</td>
<td>0x0</td>
<td>Enable PMU Timer 2 </td>
</tr>
<tr>
<td>14</td>
<td>PMU_TIMER_1</td>
<td>RW</td>
<td>0x0</td>
<td>Enable PMU Timer 1 </td>
</tr>
<tr>
<td>13</td>
<td>AP2_TIMER_3</td>
<td>RW</td>
<td>0x0</td>
<td>Enable AP2 Timer 3 </td>
</tr>
<tr>
<td>12</td>
<td>AP2_TIMER_2</td>
<td>RW</td>
<td>0x0</td>
<td>Enable AP2 Timer 2 </td>
</tr>
<tr>
<td>11</td>
<td>AP2_TIMER_1</td>
<td>RW</td>
<td>0x0</td>
<td>Enable AP2 Timer 1 </td>
</tr>
<tr>
<td>10</td>
<td>AP1_2_TIMER_3</td>
<td>RW</td>
<td>0x0</td>
<td>Enable AP1 Timer 3 and SEC Timer 3 </td>
</tr>
<tr>
<td>9</td>
<td>AP1_2_TIMER_2</td>
<td>RW</td>
<td>0x0</td>
<td>Enable AP1 Timer 2 and SEC Timer 2 </td>
</tr>
<tr>
<td>8</td>
<td>AP1_2_TIMER_1</td>
<td>RW</td>
<td>0x0</td>
<td>Enable AP1 Timer 1 and SEC Timer 1 </td>
</tr>
<tr>
<td>7</td>
<td>WAKEUP7</td>
<td>RW</td>
<td>0x0</td>
<td>Enable Wakeup7 input to Pm_clkres </td>
</tr>
<tr>
<td>6</td>
<td>WAKEUP6</td>
<td>RW</td>
<td>0x0</td>
<td>Enable Wakeup6 input to Pm_clkres </td>
</tr>
<tr>
<td>5</td>
<td>WAKEUP5</td>
<td>RW</td>
<td>0x0</td>
<td>Enable Wakeup5 input to Pm_clkres </td>
</tr>
<tr>
<td>4</td>
<td>WAKEUP4</td>
<td>RW</td>
<td>0x0</td>
<td>Enable Wakeup4 input to Pm_clkres </td>
</tr>
<tr>
<td>3</td>
<td>WAKEUP3</td>
<td>RW</td>
<td>0x0</td>
<td>Enable Wakeup3 input to Pm_clkres </td>
</tr>
<tr>
<td>2</td>
<td>WAKEUP2</td>
<td>RW</td>
<td>0x0</td>
<td>Enable Wakeup2 input to Pm_clkres </td>
</tr>
<tr>
<td>1</td>
<td>WAKEUP1</td>
<td>RW</td>
<td>0x0</td>
<td>Enable Wakeup1input to Pm_clkres </td>
</tr>
<tr>
<td>0</td>
<td>WAKEUP0</td>
<td>RW</td>
<td>0x0</td>
<td>Enable Wakeup0 input to Pm_clkres </td>
</tr>
</tbody>
</table>

#### WAKEUP AND CLOCK RESUME LINES STATUS REGISTER (AWUCRS1)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4050000+0x1064</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved for future use</td>
</tr>
<tr>
<td>0</td>
<td>IPC_AP2AUD_INT</td>
<td>RO</td>
<td>0x0</td>
<td>IPC_AP2AUD_INT</td>
</tr>
</tbody>
</table>

#### CLUSTER 0 POWER CONTROL REGISTER (APCR_CLUSTER0)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4050000+0x1090</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>AXISDD</td>
<td>RW</td>
<td>0x0</td>
<td>Allows AXI bus and agents to shut down after ASR&lt;var Processor: Application&gt; cores enters idle state. <br/>1'b0: AXI shutdown not allowed<br/>1'b1: AXI shutdown allowed </td>
</tr>
<tr>
<td>30</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Must be 1</td>
</tr>
<tr>
<td>29</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Must be 1</td>
</tr>
<tr>
<td>28</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>27</td>
<td>DDRCORSD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow ASR &lt;var Processor: Application MP&gt; core and TC DDR clocks to  shut down. <br/>The clocks are halted when CPCR[DDRCORSD], APCR[DDRCORSD] & DPCR[DDRCORSD] are set, and ASR &lt;var Processor: Application MP&gt; core is in idle mode.<br/>1'b0: ASR &lt;var Processor: Application MP&gt; core and TC DDR clocks shutdown not allowed <br/>1'b1: ASR &lt;var Processor: Application MP&gt; core and TC DDR clocks shutdown allowed </td>
</tr>
<tr>
<td>26</td>
<td>APBSD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow PMU to shut down APB clocks to all of its recipients, overriding other per-module fields. <br/>The APB clock is shut down once the ASR &lt;var Processor: Application&gt; cores are idle and CPCR[APBSD], APCR[APBSD] & DPCR[APBSD] are set.<br/>1'b0: APB clock shutdown not allowed<br/>1'b1: APB clock shutdown allowed </td>
</tr>
<tr>
<td>25</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Must be 1</td>
</tr>
<tr>
<td>24:20</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>19</td>
<td>VCTCXOSD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow VCTCXO shutdown when the system is in sleep mode. <br/>VCTCXO is shutdown when CPCR[VCTCXOSD], APCR[VCTCXOSD] & DPCR[VCTCXOSD] are set & the system enters sleep mode <br/>1'b0: VCTCXO shutdown not allowed<br/>1'b1: VCTCXO shutdown allowed </td>
</tr>
<tr>
<td>18:15</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved </td>
</tr>
<tr>
<td>14</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>must be 1</td>
</tr>
<tr>
<td>13</td>
<td>STBYEN</td>
<td>RW</td>
<td>0x1</td>
<td>Allow Apps Subsystem to shutdown and go into UDR-mode when AP subsystem is in sleep mode. <br/>UDR is enabled when CPCR[STBYEN], APCR[STBYEN] are both set & AP subsystem enters AP Sleep. </td>
</tr>
<tr>
<td>12:4</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>3</td>
<td>C0_VOTE_AP_SLPEN</td>
<td>RW</td>
<td>0x1</td>
<td>Cluster1 vote APMU sleep enable <br/></td>
</tr>
<tr>
<td>2:0</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
</tbody>
</table>

#### CLUSTER 1 POWER CONTROL REGISTER (APCR_CLUSTER0)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4050000+0x1094</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>AXISDD</td>
<td>RW</td>
<td>0x0</td>
<td>Allows AXI bus and agents to shut down after ASR&lt;var Processor: Application&gt; cores enters idle state. <br/>1'b0: AXI shutdown not allowed<br/>1'b1: AXI shutdown allowed </td>
</tr>
<tr>
<td>30</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Must be 1</td>
</tr>
<tr>
<td>29</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Must be 1</td>
</tr>
<tr>
<td>28</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>27</td>
<td>DDRCORSD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow ASR &lt;var Processor: Application MP&gt; core and TC DDR clocks shutdown. <br/>The clocks are halted when CPCR[DDRCORSD], APCR[DDRCORSD] & DPCR[DDRCORSD] are set and ASR &lt;var Processor: Application MP&gt; core is in idle mode.<br/>1'b0: ASR &lt;var Processor: Application MP&gt; core and TC DDR clocks shutdown not allowed <br/>1'b1: ASR &lt;var Processor: Application MP&gt; core and TC DDR clocks shutdown allowed </td>
</tr>
<tr>
<td>26</td>
<td>APBSD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow PMU to shut down APB clocks to all of its recipients, overriding other per-module fields. <br/>The APB clock is actually shut down once the ASR &lt;var Processor: Application&gt; cores are idle and CPCR[APBSD], APCR[APBSD] & DPCR[APBSD] are set.<br/>1'b0: APB clock shutdown not allowed<br/>1'b1: APB clock shutdown allowed </td>
</tr>
<tr>
<td>25</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>must be 1</td>
</tr>
<tr>
<td>24:20</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>19</td>
<td>VCTCXOSD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow VCTCXO shutdown when the system is in sleep mode. <br/>VCTCXO is shutdown when CPCR[VCTCXOSD], APCR[VCTCXOSD] & DPCR[VCTCXOSD] are set & the system enters sleep mode <br/>1'b0: VCTCXO shutdown not allowed<br/>1'b1: VCTCXO shutdown allowed </td>
</tr>
<tr>
<td>18:15</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved </td>
</tr>
<tr>
<td>14</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Must be 1</td>
</tr>
<tr>
<td>13</td>
<td>STBYEN</td>
<td>RW</td>
<td>0x1</td>
<td>Allow Apps Subsystem to shutdown and go into UDR-mode when AP subsystem is in sleep mode. <br/>UDR is enabled when CPCR[STBYEN], APCR[STBYEN] are both set & AP subsystem enters AP Sleep. </td>
</tr>
<tr>
<td>12:4</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>3</td>
<td>C1_VOTE_AP_SLPEN</td>
<td>RW</td>
<td>0x1</td>
<td>Cluster1 vote APMU sleep enable </td>
</tr>
<tr>
<td>2:0</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
</tbody>
</table>

#### ASR PERIPHERAL 1 POWER CONTROL REGISTER (APCR_PER)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4050000+0x1098</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>AXISDD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow AXI bus and agents to shut down after ASR&lt;var Processor: Application&gt; cores enters idle state. <br/>1'b0: AXI shutdown not allowed<br/>1'b1: AXI shutdown allowed </td>
</tr>
<tr>
<td>30</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>must be 1</td>
</tr>
<tr>
<td>29</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>must be 1</td>
</tr>
<tr>
<td>28</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>27</td>
<td>DDRCORSD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow ASR &lt;var Processor: Application MP&gt; core and TC DDR clocks shutdown. <br/>The clocks are halted when CPCR[DDRCORSD], APCR[DDRCORSD] & DPCR[DDRCORSD] are set and ASR &lt;var Processor: Application MP&gt; core is in idle mode.<br/>1'b0: ASR &lt;var Processor: Application MP&gt; core and TC DDR clocks shutdown not allowed <br/>1'b1: ASR&lt;var Processor: Application MP&gt; core and TC DDR clocks shutdown allowed </td>
</tr>
<tr>
<td>26</td>
<td>APBSD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow PMU to shut down APB clocks to all of its recipients, overriding other per-module fields. <br/>The APB clock is actually shut down once the ASR &lt;var Processor: Comm&gt;/ &lt;var Processor: Application&gt; cores are idle and CPCR[APBSD], APCR[APBSD] & DPCR[APBSD] are set.<br/>1'b0: APB clock shutdown not allowed <br/>1'b1: APB clock shutdown allowed </td>
</tr>
<tr>
<td>25</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>must be 1</td>
</tr>
<tr>
<td>24:20</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>19</td>
<td>VCTCXOSD</td>
<td>RW</td>
<td>0x0</td>
<td>Allow VCTCXO shutdown when the system is in sleep mode. <br/>VCTCXO is shutdown when CPCR[VCTCXOSD], APCR[VCTCXOSD] & DPCR[VCTCXOSD] are set & the system enters sleep mode <br/>0: VCTCXO shutdown not allowed <br/>1: VCTCXO shutdown allowed </td>
</tr>
<tr>
<td>18:15</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>14</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Must be 1</td>
</tr>
<tr>
<td>13</td>
<td>STBYEN</td>
<td>RW</td>
<td>0x1</td>
<td>Allow Apps Subsystem to shutdown and go into UDR-mode when AP subsystem is in sleep mode. <br/>UDR is enabled when CPCR[STBYEN], APCR[STBYEN] are both set & AP subsystem enters AP Sleep. </td>
</tr>
<tr>
<td>12:4</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>3</td>
<td>PE_VOTE_AP_SLPEN</td>
<td>RW</td>
<td>0x1</td>
<td>PE vote APMU sleep enable </td>
</tr>
<tr>
<td>2:0</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
</tbody>
</table>

#### Basing on \<PMU_BASE(0xD4282800)\>



##### SDIO/ROTARY WAKE CLEAR REGISTER (PMU_USB_SD_ROT_WAKE_CLR)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x7C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>USB_WK_INT_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB Wake up status </td>
</tr>
<tr>
<td>30:29</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved0</td>
</tr>
<tr>
<td>28</td>
<td>USB_CHGDET_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB Line charge detect wake up status </td>
</tr>
<tr>
<td>27</td>
<td>USB_ID_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB Line ID wake up status </td>
</tr>
<tr>
<td>26</td>
<td>USB_VBUS_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB Line vbus valid wake up status </td>
</tr>
<tr>
<td>25</td>
<td>USB_LINE1_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB Line state1 wake up status </td>
</tr>
<tr>
<td>24</td>
<td>USB_LINE0_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB Line state0 wake up status </td>
</tr>
<tr>
<td>23</td>
<td>USB_IDDIG_OVRD_VALUE</td>
<td>RO</td>
<td>0x0</td>
<td>USB IDDIG OVERRIDE VALUE </td>
</tr>
<tr>
<td>22</td>
<td>USB_IDDIG_OVRD_EN</td>
<td>RO</td>
<td>0x0</td>
<td>USB IDDIG OVERRIDE ENABLE</td>
</tr>
<tr>
<td>21</td>
<td>USB_VBUS_DRV</td>
<td>RO</td>
<td>0x0</td>
<td>USB VBUS DRV </td>
</tr>
<tr>
<td>20</td>
<td>USB_CHGDET_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line charge detect wake up Clear.<br/>1'b1: Clear <br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>19</td>
<td>USB_ID_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line ID wake up Clear.<br/>1'b1: Clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>18</td>
<td>USB_VBUS_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line vbus valid wake up Clear. <br/>1'b1: Clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>17</td>
<td>USB_LINE1_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line state1 wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>16</td>
<td>USB_LINE0_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line state0 wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>15</td>
<td>USB_WK_INT_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB Wakeup Interrupt Enable.<br/>1'b1: Enable </td>
</tr>
<tr>
<td>14:13</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>12</td>
<td>USB_CHGDET_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line charge detect wake up Enable.<br/>1'b1: Enable </td>
</tr>
<tr>
<td>11</td>
<td>USB_ID_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line ID wake up Enable.<br/>1'b1: Enable </td>
</tr>
<tr>
<td>10</td>
<td>USB_VBUS_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line vbus valid wake up Enable<br/>1'b1: Enable </td>
</tr>
<tr>
<td>9</td>
<td>USB_LINE1_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line state1 wake up Enable <br/>1'b1: Enable </td>
</tr>
<tr>
<td>8</td>
<td>USB_LINE0_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB Line state0 wake up Enable<br/>1'b1: Enable </td>
</tr>
<tr>
<td>7</td>
<td>CS_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>CS wake up status </td>
</tr>
<tr>
<td>6</td>
<td>SDH2_WK_CLR</td>
<td>RW</td>
<td>0x1</td>
<td>SDH2 Wake Clear.<br/>1'b1: SDH2 wake event clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>5</td>
<td>CS_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>Clear of DAP Power Wake Up Request (DAP CSYSPWRUPREQ).<br/>1'b1: Clear DAP_REQ wakeup  </td>
</tr>
<tr>
<td>4</td>
<td>CS_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>DAP Power Wake Up Enable (DAP CSYSPWRUPREQ)<br/>1'b1: Enable </td>
</tr>
<tr>
<td>3</td>
<td>KB_WK_CLR</td>
<td>RW</td>
<td>0x1</td>
<td>Keypad Wake Clear.<br/>1'b1: ROT wake event clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>2</td>
<td>ROT_WK_CLR</td>
<td>RW</td>
<td>0x1</td>
<td>Rotary Wake Clear.<br/>1'b1: ROT wake event clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>1</td>
<td>SDH1_WK_CLR</td>
<td>RW</td>
<td>0x1</td>
<td>SDH1 Wake Clear.<br/>1'b1: SDH1 wake event clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>0</td>
<td>SDH0_WK_CLR</td>
<td>RW</td>
<td>0x1</td>
<td>SDH0 Wake Clear.<br/>1'b1: SDH0 wake event clear<br/>This bit is self-cleared by hardware </td>
</tr>
</tbody>
</table>

##### POWER STABLE TIMER REGISTER (PMU_PWR_STBL_TIMER)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x7C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:24</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>23:16</td>
<td>PWR_CLK_PRE</td>
<td>RW</td>
<td>0x02</td>
<td>Clock Prescaler for Timer Count.<br/>0x0 = Divide by 1<br/>0x1 = Divide by 1<br/>0x2 = Divide by 2 <br/>All other values use an incremental divider. </td>
</tr>
<tr>
<td>15:8</td>
<td>PWR_UP_STBL_TIMER</td>
<td>RW</td>
<td>0x40</td>
<td>Power-Up Stable Timer <br/>Defines the stable time required for power-up during core idle mode in 24 MHz unit </td>
</tr>
<tr>
<td>7:0</td>
<td>PWR_DWN_STBL_TIMER</td>
<td>RW</td>
<td>0x00</td>
<td>Power Down Stable Timer <br/>Defines the stable time required for power-down during core idle mode in 24 MHz unit </td>
</tr>
</tbody>
</table>

##### CORE STATUS REGISTER (PMU_CORE_STATUS)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x90</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>AP_CORE7_C2</td>
<td>RO</td>
<td>0x1</td>
<td>CORE7 in C2 Mode Indication. <br/>Indicates whether CORE7 is in C2 mode. <br/>1'b1: CORE7 is in C2 mode </td>
</tr>
<tr>
<td>30</td>
<td>AP_CORE7_C1</td>
<td>RO</td>
<td>0x0</td>
<td>CORE7 in C1 Mode Indication. <br/>Indicates whether CORE7 is in C1 mode (external mode). <br/>1'b1: CORE7 is in C1 mode </td>
</tr>
<tr>
<td>29</td>
<td>AP_CORE7_WFI_FLAG</td>
<td>RO</td>
<td>0x1</td>
<td>CORE7 WFI Flag <br/>Reflects the WFI flag generated by CORE7<br/>When CORE7 enters WFI, this field is set </td>
</tr>
<tr>
<td>28</td>
<td>AP_CORE6_C2</td>
<td>RO</td>
<td>0x1</td>
<td>CORE6 in C2 Mode Indication.  <br/>Indicates whether CORE6 is in C2 mode. <br/>1'b1: CORE6 is in C2 mode </td>
</tr>
<tr>
<td>27</td>
<td>AP_CORE6_C1</td>
<td>RO</td>
<td>0x0</td>
<td>CORE6 in C1 Mode Indication. <br/>Indicates whether CORE6 is in C1 mode (external mode). <br/>1'b1: CORE6 is in C1 mode </td>
</tr>
<tr>
<td>26</td>
<td>AP_CORE6_WFI_FLAG</td>
<td>RO</td>
<td>0x1</td>
<td>CORE6 WFI Flag <br/>Reflects the WFI flag generated by CORE6<br/>When CORE6 enters WFI, this field is set </td>
</tr>
<tr>
<td>25</td>
<td>AP_CORE5_C2</td>
<td>RO</td>
<td>0x1</td>
<td>CORE5 in C2 Mode Indication.  <br/>Indicates whether CORE5 is in C2 mode. <br/>1'b1: CORE5 is in C2 mode </td>
</tr>
<tr>
<td>24</td>
<td>AP_CORE5_C1</td>
<td>RO</td>
<td>0x0</td>
<td>CORE5 in C1 Mode Indication. <br/>Indicates whether CORE5 is in C1 mode (external mode). <br/>1'b1: CORE5 is in C1 mode </td>
</tr>
<tr>
<td>23</td>
<td>AP_CORE5_WFI_FLAG</td>
<td>RO</td>
<td>0x1</td>
<td>CORE5 WFI Flag <br/>Reflects the WFI flag generated by CORE5<br/>When CORE5 enters WFI, this field is set </td>
</tr>
<tr>
<td>22</td>
<td>AP_CORE4_C2</td>
<td>RO</td>
<td>0x1</td>
<td>CORE4 in C2 Mode Indication.  <br/>Indicates whether CORE4 is in C2 mode. <br/>1'b1: CORE4 is in C2 mode </td>
</tr>
<tr>
<td>21</td>
<td>AP_CORE4_C1</td>
<td>RO</td>
<td>0x0</td>
<td>CORE4 in C1 Mode Indication. <br/>Indicates whether CORE4 is in C1 mode (external mode). <br/>1'b1: CORE4 is in C1 mode </td>
</tr>
<tr>
<td>20</td>
<td>AP_CORE4_WFI_FLAG</td>
<td>RO</td>
<td>0x1</td>
<td>CORE4 WFI Flag <br/>Reflects the WFI flag generated by CORE4<br/>When CORE4 enters WFI, this field is set </td>
</tr>
<tr>
<td>19</td>
<td>AP_C1_MPSUB_M2</td>
<td>RO</td>
<td>0x1</td>
<td>Cluster1 Subsystem idle mode Indication. <br/>Indicates whether cluster1 Subsystem is in M2 mode.<br/>1'b1: Cluster1 Subsystem is in M2 mode </td>
</tr>
<tr>
<td>18</td>
<td>AP_C1_MPSUB_M1</td>
<td>RO</td>
<td>0x0</td>
<td>Cluster1 Subsystem in M1 Mode Indication <br/>Indicates whether Cluster1 Subsystem is in M1 mode (external idle mode).<br/>1'b1: Cluster1 Subsystem is in M1 mode </td>
</tr>
<tr>
<td>17</td>
<td>AP_C1_MPSUB_IDLE_FLAG</td>
<td>RO</td>
<td>0x1</td>
<td>Cluster1  Subsystem Idle Flag <br/>Reflects the AND logic value of SCU_IDLE and L2CLKSTOPPED generated for Cluster1 Subsystem. <br/>1'b1: core0/core1/core2/core3/scu/L2 are all in idle state </td>
</tr>
<tr>
<td>16</td>
<td>SP_IDLE</td>
<td>RO</td>
<td>0x1</td>
<td>Core idle mode Indication <br/>Indicates whether Core is in "core idle mode" mode. <br/>1'b1:  Core is in core idle mode </td>
</tr>
<tr>
<td>15</td>
<td>AP_CORE3_C2</td>
<td>RO</td>
<td>0x1</td>
<td>CORE3 in C2 Mode Indication. <br/>Indicate whether CORE3 is in C2 mode. <br/>1'b1: CORE3 is in C2 mode </td>
</tr>
<tr>
<td>14</td>
<td>AP_CORE3_C1</td>
<td>RO</td>
<td>0x0</td>
<td>CORE3 in C1 Mode Indication. <br/>Indicate whether CORE3 is in C1 mode (external idle mode). <br/>1'b1: CORE3 is in C1 mode</td>
</tr>
<tr>
<td>13</td>
<td>AP_CORE3_WFI_FLAG</td>
<td>RO</td>
<td>0x1</td>
<td>CORE3 WFI Flag <br/>Reflects the WFI flag generated by CORE3. <br/>When CORE3 enters WFI, this field is set.</td>
</tr>
<tr>
<td>12</td>
<td>AP_CORE2_C2</td>
<td>RO</td>
<td>0x1</td>
<td>CORE2 in C2 Mode Indication. <br/>Indicate whether CORE2 is in C2 mode. <br/>1'b1: CORE2 is in C2 mode</td>
</tr>
<tr>
<td>11</td>
<td>AP_CORE2_C1</td>
<td>RO</td>
<td>0x0</td>
<td>CORE2 in C1 Mode Indication. <br/>Indicate whether CORE2 is in C1 mode (external idle mode). <br/>1'b1: CORE2 is in C1 mode </td>
</tr>
<tr>
<td>10</td>
<td>AP_CORE2_WFI_FLAG</td>
<td>RO</td>
<td>0x1</td>
<td>CORE2 WFI Flag <br/>Reflects the WFI flag generated by CORE2. <br/>When CORE2 enters WFI, this field is set.</td>
</tr>
<tr>
<td>9</td>
<td>AP_CORE1_C2</td>
<td>RO</td>
<td>0x1</td>
<td>CORE1 in C2 Mode Indication. <br/>Indicate whether CORE1 is in C2 mode. <br/>1'b1: CORE1 is in C2 mode</td>
</tr>
<tr>
<td>8</td>
<td>AP_CORE1_C1</td>
<td>RO</td>
<td>0x0</td>
<td>CORE1 in C1 Mode Indication. <br/>Indicate whether CORE1 is in C1 mode (external idle mode). <br/>1'b1: CORE1 is in C1 mode </td>
</tr>
<tr>
<td>7</td>
<td>AP_CORE1_WFI_FLAG</td>
<td>RO</td>
<td>0x1</td>
<td>CORE1 WFI Flag <br/>Reflects the WFI flag generated by CORE1. <br/>When CORE1 enters WFI, this field is set.</td>
</tr>
<tr>
<td>6</td>
<td>AP_CORE0_C2</td>
<td>RO</td>
<td>0x0</td>
<td>CORE0 in C2 Mode Indication. <br/>Indicate whether CORE0 is in C2 mode. <br/>1'b1: CORE0 is in C2 mode</td>
</tr>
<tr>
<td>5</td>
<td>AP_CORE0_C1</td>
<td>RO</td>
<td>0x0</td>
<td>CORE0 in C1 Mode Indication. <br/>Indicate whether CORE0 is in C1 mode (external idle mode). <br/>1'b1: CORE0 is in C1 mode </td>
</tr>
<tr>
<td>4</td>
<td>AP_CORE0_WFI_FLAG</td>
<td>RO</td>
<td>0x0</td>
<td>CORE0 WFI Flag <br/>Reflects the WFI flag generated by CORE0. <br/>When CORE0 enters WFI, this field is set.</td>
</tr>
<tr>
<td>3</td>
<td>AP_C0_MPSUB_M2</td>
<td>RO</td>
<td>0x0</td>
<td>Cluster0 Subsystem idle mode Indication. <br/>Indicates whether Cluster1 MP Subsystem is in M2 mode.<br/>1'b1: Cluster0 MP Subsystem is in M2 mode </td>
</tr>
<tr>
<td>2</td>
<td>AP_C0_MPSUB_M1</td>
<td>RO</td>
<td>0x0</td>
<td>Cluster0 Subsystem in M1 Mode Indication <br/>Indicates whether Cluster0 MP Subsystem is in M1 mode (external idle mode).<br/>1'b1: Cluster0 MP Subsystem is in M1 mode </td>
</tr>
<tr>
<td>1</td>
<td>AP_C0_MPSUB_IDLE_FLAG</td>
<td>RO</td>
<td>0x0</td>
<td>Cluster0  Subsystem Idle Flag. <br/>Reflects the AND logic value of SCU_IDLE and L2CLKSTOPPED generated in the Cluster0 MP Subsystem. <br/>1'b1: core0/core1/core2/core3/scu/L2 are all in idle state </td>
</tr>
<tr>
<td>0</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
</tbody>
</table>

#### RESUME FROM SLEEP CLEAR REGISTER (PMU_RES_FRM_SLP_CLR)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x94</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:1</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>0</td>
<td>CLR_RSM_FRM_SLP</td>
<td>RW</td>
<td>0x0</td>
<td>Clear Resume from Sleep Indication<br/>1'b1: Clear the status signal in CIU sys_boot_cntr[14] </td>
</tr>
</tbody>
</table>

##### VPU POWER CONTROL REGISTER (PMU_VPU_PWR_CTRL)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0xA8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>4</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>3</td>
<td>VPU_SLEEP2</td>
<td>RW</td>
<td>0x0</td>
<td>VPU Power Switch Sleep2 </td>
</tr>
<tr>
<td>2</td>
<td>VPU_SLEEP1</td>
<td>RW</td>
<td>0x0</td>
<td>VPU Power Switch Sleep1 </td>
</tr>
<tr>
<td>1</td>
<td>VPU_ISOB</td>
<td>RW</td>
<td>0x0</td>
<td>VPU Isolation Wrapper <br/>1'b0: Enable isolation (VPU power-down mode) <br/>1'b1: disable isolation (VPU active mode) </td>
</tr>
<tr>
<td>0</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
</tbody>
</table>

##### GPU POWER CONTROL REGISTER (PMU_GPU_PWR_CTRL)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0xD0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>4</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>3</td>
<td>GPU_SLEEP2</td>
<td>RW</td>
<td>0x0</td>
<td>GPU Power Switch Sleep2 </td>
</tr>
<tr>
<td>2</td>
<td>GPU_SLEEP1</td>
<td>RW</td>
<td>0x0</td>
<td>GPU Power Switch Sleep1 </td>
</tr>
<tr>
<td>1</td>
<td>GPU_ISOB</td>
<td>RW</td>
<td>0x0</td>
<td>GPU Isolation Wrapper <br/>1'b0: Enable isolation (GPU power-down mode) <br/>1'b1: disable isolation (GPU active mode) </td>
</tr>
<tr>
<td>0</td>
<td>RSVD</td>
<td>RW</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
</tbody>
</table>

##### BLOCK POWER TIMER REGISTER (PMUA_PWR_BLK_TMR_REG)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0xDC</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:16</td>
<td>PWR_ON1_TIMER</td>
<td>RW</td>
<td>0x8</td>
<td>Delay for GPU/VPU/ISP/Audio auto-power on from Sleep1 to Sleep2</td>
</tr>
<tr>
<td>15:8</td>
<td>PWR_ON2_TIMER</td>
<td>RW</td>
<td>0x64</td>
<td>Delay for GPU/VPU/ISP/Audio auto-power on from Sleep2 to clock_en</td>
</tr>
<tr>
<td>7:0</td>
<td>PWR_OFF_TIMER</td>
<td>RW</td>
<td>0x0</td>
<td>Delay for GPU/VPU/ISP/Audio auto-power off from Sleep2 to Sleep1</td>
</tr>
</tbody>
</table>

##### CLUSTER0 MP IDLE CONFIGURATION REGISTER FOR CORE X (PMU_C0_CAPMP_IDLE_CFGX_X;X=0/1/2/3)



This register is used by cluster0 core x to vote MP subsystem low power mode.

PMU_C0_IDLE_CFGx (x=0,1,2,3) are fully symmetric. Each bit of the register takes effect only when all corresponding bits of PMU_C0__IDLE_CFGx are set to 1.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x120/0xE4/0x150/0x154</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:20</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>19</td>
<td>DIS_MP_L2_SLP</td>
<td>RW</td>
<td>0x0</td>
<td>Disable  L2 Power Switch<br/>Disables the MP L2 power switch sleep power down during MP power down mode. <br/>1'b1: Disable MP L2 power switch  </td>
</tr>
<tr>
<td>18</td>
<td>DIS_MP_SLP</td>
<td>RW</td>
<td>0x0</td>
<td>Disable MP Power Switch. <br/>Disables the MP power switch sleep power down during MP subsystem power down mode.<br/>1'b1: Disable MP power switch sleep </td>
</tr>
<tr>
<td>17</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>FRC_L2_SRAM_Off</td>
<td>RW</td>
<td>0x0</td>
<td>Frequency Change L2 SRAM Off.<br/>1'b1: L2 Frequency Change is off </td>
</tr>
<tr>
<td>15:14</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>13</td>
<td>L2_HW_CACHE_FLUSH_EN</td>
<td>RW</td>
<td>0x0</td>
<td>L2 Hardware Cache Flush Enable.<br/>1'b1: Enable   </td>
</tr>
<tr>
<td>12</td>
<td>MASK_SRAM_REPAIR_DONE_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask SRAM Repair Done Check.<br/>1'b1: Mask SRAM repair done check </td>
</tr>
<tr>
<td>11</td>
<td>MASK_CLK_OFF_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask the MP Clock Off State Check.<br/>Masks the MP clock off check during the MP idle process. </td>
</tr>
<tr>
<td>10</td>
<td>MASK_CLK_STBL_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask MP clock stable State Check.<br/>Masks the MP clock stable check during MP wakeup. </td>
</tr>
<tr>
<td>9</td>
<td>MASK_JTAG_IDLE_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask JTAG Idle State Check.<br/>Masks the JTAG idle check during the MP idle entry. <br/>1'b1: Mask JTAG idle check </td>
</tr>
<tr>
<td>8</td>
<td>MASK_IDLE_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask the MP Idle State Check. </td>
</tr>
<tr>
<td>7</td>
<td>ACINACTM_HW_CTRL</td>
<td>RW</td>
<td>0x0</td>
<td>ACINACTM Hardware Control.<br/>1'b0: low power state machine does not control ACINACTM port.  1'b1: low power state machine controls ACINACTM port of MP.  When M2/M1 low power mode is entered, ACINACTM port will be high </td>
</tr>
<tr>
<td>6</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>5</td>
<td>DIS_MC_SW_REQ</td>
<td>RW</td>
<td>0x0</td>
<td>Disable Memory Controller Software Request. <br/>Disables the Memory Controller entry to idle mode using the Memory Controller sleep request bits. The Memory Controller will always enter into idle mode based on the hardware state machine</td>
</tr>
<tr>
<td>4</td>
<td>MP_WAKE_MC_EN</td>
<td>RW</td>
<td>0x0</td>
<td>MP Wake Memory Controller Enable. <br/>Wakes up the Memory Controller when the MP wakes up from idle mode. The Memory Controller is woken up before the interrupt to the core is released. <br/>1'b0: Memory Controller wakes up if MP wakes up from idle mode</td>
</tr>
<tr>
<td>3</td>
<td>MP_SCU_SRAM_PWRDWN</td>
<td>RW</td>
<td>0x0</td>
<td>No Used. <br/>SCU SRAM does not support retention </td>
</tr>
<tr>
<td>2</td>
<td>L2_SRAM_PWRDWN</td>
<td>RW</td>
<td>0x0</td>
<td>L2 Cache SRAM Power Down <br/>This field does not take effect if MP_PWRDWN is 0. <br/>1'b1: When MP is idle, L2 SRAM power will be off.<br/>1'b0: When MP is idle, L2 SRAM is in retention mode </td>
</tr>
<tr>
<td>1</td>
<td>MP_PWRDWN</td>
<td>RW</td>
<td>0x0</td>
<td>MP Power Down. <br/>This field does not take effect if MP_IDLE is 0. <br/>1'b1: When MP is idle, MP will go into deep sleep mode and the MP logic will be power-gated</td>
</tr>
<tr>
<td>0</td>
<td>MP_IDLE</td>
<td>RW</td>
<td>0x0</td>
<td>MP Idle.<br/>1'b1: When MP is idle, the MP clocks will be gated externally </td>
</tr>
</tbody>
</table>

##### POWER STATUS REGISTER (PMUA_PWR_STATUS_REG)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0xF0</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:13</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>12</td>
<td>LCD_HW_PWR_STAT</td>
<td>RO</td>
<td>0x0</td>
<td>HW Power Mode updates the status when the LCD enters/exits its LPM. </td>
</tr>
<tr>
<td>11</td>
<td>AUDIO_HW_PWR_STAT</td>
<td>RO</td>
<td>0x0</td>
<td>HW Power Mode updates the status when the Audio enters/exits its LPM. <br/>1'b0: Audio is powered off<br/>1'b1: Audio is powered on </td>
</tr>
<tr>
<td>10</td>
<td>ISP_HW_PWR_STAT</td>
<td>RO</td>
<td>0x0</td>
<td>HW Power Mode updates the status when the ISP enters/exits its LPM.</td>
</tr>
<tr>
<td>9</td>
<td>VPU_HW_PWR_STAT</td>
<td>RO</td>
<td>0x0</td>
<td>HW Power Mode updates the status when the VPU enters/exits its LPM.  </td>
</tr>
<tr>
<td>8</td>
<td>GPU_HW_PWR_STAT</td>
<td>RO</td>
<td>0x0</td>
<td>HW Power Mode updates the status when the GPU enters/exits its LPM. </td>
</tr>
<tr>
<td>7:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved </td>
</tr>
<tr>
<td>4</td>
<td>LCD_PWR_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>LCD power state including both HW and SW power mode.<br/>1'b1: Power on<br/>1'b0: Power off </td>
</tr>
<tr>
<td>3</td>
<td>AUDIO_PWR_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>Audio Power State including both HW and SW power mode.<br/>1'b1: Power on<br/>1'b0: Power off </td>
</tr>
<tr>
<td>2</td>
<td>ISP_PWR_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>ISP power state  including both HW and SW power mode.<br/>1'b1: Power on<br/>1'b0: Power off </td>
</tr>
<tr>
<td>1</td>
<td>VPU_PWR_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td> VPU power state  including both HW and SW power mode.<br/>1'b1: Power on.<br/>1'b0: Power off </td>
</tr>
<tr>
<td>0</td>
<td>GPU_PWR_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>GPU power state  including both HW and SW power mode.  <br/>1'b1: Power on.<br/>1'b0: Power off </td>
</tr>
</tbody>
</table>

##### USB PHY READ REGISTER (PMUA_USB_PHY_READ)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x118</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:22</td>
<td>RSVD3</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>21</td>
<td>USB3_PHY_RXELECIDLE</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 PHY RXELECIDLE output </td>
</tr>
<tr>
<td>20:19</td>
<td>USB3_PHY_LINESTATE</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 PHY line_state[1:0] output </td>
</tr>
<tr>
<td>18</td>
<td>USB3_PHY_VBUSVALID</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 PHY Vbus Valid output </td>
</tr>
<tr>
<td>17</td>
<td>USB3_PHY_IDDIG</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 PHY ID DIG output </td>
</tr>
<tr>
<td>16</td>
<td>USB3_PHY_CHGDECT</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 PHY CHGDECT output </td>
</tr>
<tr>
<td>15:13</td>
<td>RSVD1</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>12:11</td>
<td>USBP1_PHY_LINESTATE</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 PHY line_state[1:0] output </td>
</tr>
<tr>
<td>10</td>
<td>USBP1_PHY_VBUSVALID</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 PHY VbusValid output </td>
</tr>
<tr>
<td>9</td>
<td>USBP1_PHY_IDDIG</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 PHY ID DIG output </td>
</tr>
<tr>
<td>8</td>
<td>USBP1_PHY_CHGDECT</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 PHY CHGDECT output </td>
</tr>
<tr>
<td>7:5</td>
<td>RSVD0</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>4:3</td>
<td>USB_PHY_LINESTATE</td>
<td>RO</td>
<td>0x0</td>
<td>USB PHY line_state[1:0] output </td>
</tr>
<tr>
<td>2</td>
<td>USB_PHY_VBUSVALID</td>
<td>RO</td>
<td>0x0</td>
<td>USB PHY VbusValid output </td>
</tr>
<tr>
<td>1</td>
<td>USB_PHY_IDDIG</td>
<td>RO</td>
<td>0x0</td>
<td>USB PHY ID DIG output </td>
</tr>
<tr>
<td>0</td>
<td>USB_PHY_CHGDECT</td>
<td>RO</td>
<td>0x0</td>
<td>USB PHY CHGDECT output </td>
</tr>
</tbody>
</table>

##### CORE X  IDLE CONFIGURATION REGISTER (PMU_CAP_COREX_IDLE_CFG_X)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x124/0x128/0x160/0x164/0x304/0x308/0x30C/0x310</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:12</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>11</td>
<td>MASK_CLK_OFF_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask core clock off check during core idle process. </td>
</tr>
<tr>
<td>10</td>
<td>MASK_CLK_STBL_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask core clock stable check during core wakeup. </td>
</tr>
<tr>
<td>9</td>
<td>MASK_JTAG_IDLE_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask the JTAG idle check during MP idle entry.<br/>1'b1: Mask the JTAG idle check. </td>
</tr>
<tr>
<td>8</td>
<td>MASK_CORE_WFI_IDLE_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask the Core WFI IDLE check during MP idle entry.<br/>1'b1: Mask the core wait for interrupt idle check</td>
</tr>
<tr>
<td>7:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>4</td>
<td>MASK_GIC_NFIQ_TO_CORE</td>
<td>RW</td>
<td>0x0</td>
<td>Mask nFIQ generated in GIC for CORE. <br/>Software can set this bit before CORE enter C2. <br/>APMU hardware will automatically clear this bit when CORE enters C2 </td>
</tr>
<tr>
<td>3</td>
<td>MASK_GIC_NIRQ_TO_CORE</td>
<td>RW</td>
<td>0x0</td>
<td>Mask nIRQ generated in GIC for CORE. <br/>Software can set this bit before CORE enter C2. <br/>APMU hardware will automatically clear this bit when CORE enters C2 </td>
</tr>
<tr>
<td>2</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>1</td>
<td>CORE_PWRDWN</td>
<td>RW</td>
<td>0x0</td>
<td>Core Power Down. <br/>This bit does not takes effect if CORE_IDLE is 0. <br/>1'b1: When core issues WFI idle, core goes into deep sleep mode and power is off. <br/>This bit will not take effect if dbgnopwrdwn is set </td>
</tr>
<tr>
<td>0</td>
<td>CORE_IDLE</td>
<td>RW</td>
<td>0x0</td>
<td>Core Idle.<br/>1'b1: When core issues WFI idle, the core clock will be gated externally. <br/>This bit will not take effect if dbgnopwrdwn is set </td>
</tr>
</tbody>
</table>

##### CORE X WAKEUP REGISTER (PMU_CAP_COREX_WAKEUP_X)



This register is used by Core x software to wake up other cores in Cluster0/1.

To avoid software lock issues, other cores in the MP subsystem should not write to this register.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x12C/0x130/0x134/0x138/0x324/0x328/0x32C/0x330</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:8</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved </td>
</tr>
<tr>
<td>7</td>
<td>WAKEUP_CORE7</td>
<td>RW</td>
<td>0x0</td>
<td>Wakeup Core7   <br/>- Writing 1 to this field:<br/>	1. Wakes up Core 7<br/>	2. Has no effect if Core 7 is in C0 mode<br/>- Writing 0 to this field: No effect<br/>The PMU hardware automatically clears this bit when Core 3 exits C1/C2 mode.</td>
</tr>
<tr>
<td>6</td>
<td>WAKEUP_CORE6</td>
<td>RW</td>
<td>0x0</td>
<td>Wakeup Core6   <br/>- Writing 1 to this field:<br/>	1. Wakes up Core 6<br/>	2. Has no effect if Core 6 is in C0 mode<br/>- Writing 0 to this field: No effect<br/>The PMU hardware automatically clears this bit when Core 3 exits C1/C2 mode.</td>
</tr>
<tr>
<td>5</td>
<td>WAKEUP_CORE5</td>
<td>RW</td>
<td>0x0</td>
<td>Wakeup Core5 <br/>- Writing 1 to this field:<br/>	1. Wakes up Core 5<br/>	2. Has no effect if Core 5 is in C0 mode<br/>- Writing 0 to this field: No effect<br/>The PMU hardware automatically clears this bit when Core 3 exits C1/C2 mode.</td>
</tr>
<tr>
<td>4</td>
<td>WAKEUP_CORE4</td>
<td>RW</td>
<td>0x0</td>
<td>Wakeup Core 4 <br/>- Writing 1 to this field:<br/>	1. Wakes up Core 4<br/>	2. Has no effect if Core 4 is in C0 mode<br/>- Writing 0 to this field: No effect<br/>The PMU hardware automatically clears this bit when Core 3 exits C1/C2 mode.</td>
</tr>
<tr>
<td>3</td>
<td>WAKEUP_CORE3</td>
<td>RW</td>
<td>0x0</td>
<td>Wakeup Core3 <br/>- Writing 1 to this field:<br/>	1. Wakes up Core 3<br/>	2. Has no effect if Core 3 is in C0 mode<br/>- Writing 0 to this field: No effect<br/>The PMU hardware automatically clears this bit when Core 3 exits C1/C2 mode.</td>
</tr>
<tr>
<td>2</td>
<td>WAKEUP_CORE2</td>
<td>RW</td>
<td>0x0</td>
<td>Wakeup Core2 <br/>- Writing 1 to this field:<br/>	1. Wakes up Core 2<br/>	2. Has no effect if Core 2 is in C0 mode<br/>- Writing 0 to this field: No effect<br/>The PMU hardware automatically clears this bit when Core 3 exits C1/C2 mode.</td>
</tr>
<tr>
<td>1</td>
<td>WAKEUP_CORE1</td>
<td>RW</td>
<td>0x0</td>
<td>Wakeup Core1 <br/>- Writing 1 to this field:<br/>	1. Wakes up Core 1<br/>	2. Has no effect if Core 1 is in C0 mode<br/>- Writing 0 to this field: No effect<br/>The PMU hardware automatically clears this bit when Core 3 exits C1/C2 mode.</td>
</tr>
<tr>
<td>0</td>
<td>WAKEUP_CORE0</td>
<td>RW</td>
<td>0x0</td>
<td>Wakeup Core 0  <br/>- Writing 1 to this field:<br/>	1. Wakes up Core 0<br/>	2. Has no effect if Core 0 is in C0 mode<br/>- Writing 0 to this field: No effect<br/>The PMU hardware automatically clears this bit when Core 3 exits C1/C2 mode.</td>
</tr>
</tbody>
</table>

##### CLUSTER1 MP IDLE CONFIGURATION REGISTER FOR CORE X (PMU_C1_CAPMP_IDLE_CFGX_X)



This register is used by Cluster 1 - Core x to vote for MP subsystem low power mode, where:

- PMU_C1_IDLE_CFGx (x=0,1,2,3) registers are fully symmetric.
- Each bit in the register takes effect only when all corresponding bits of PMU_C1__IDLE_CFGx are set to 1.

<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x314/0x318/0x31C/0x320</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:20</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>19</td>
<td>DIS_MP_L2_SLP</td>
<td>RW</td>
<td>0x0</td>
<td>Disable  L2 Power Switch. <br/>Disables the MP L2 power switch sleep power down during MP power down mode.<br/>1'b1: Disables MP L2 power switch  </td>
</tr>
<tr>
<td>18</td>
<td>DIS_MP_SLP</td>
<td>RW</td>
<td>0x0</td>
<td>Disable MP Power Switch. <br/>Disables the MP power switch sleep power down during MP subsystem power down mode.<br/>1'b1: Disables MP power switch sleep </td>
</tr>
<tr>
<td>17</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>FRC_L2_SRAM_Off</td>
<td>RW</td>
<td>0x0</td>
<td>Frequency Change L2 SRAM Off.<br/>1'b1: L2 Frequency change is off </td>
</tr>
<tr>
<td>15:14</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>13</td>
<td>L2_HW_CACHE_FLUSH_EN</td>
<td>RW</td>
<td>0x0</td>
<td>L2 Hardware Cache Flush Enable<br/>1'b1: Enable   </td>
</tr>
<tr>
<td>12</td>
<td>MASK_SRAM_REPAIR_DONE_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask SRAM Repair Done Check<br/>1'b1: Mask SRAM repair done check </td>
</tr>
<tr>
<td>11</td>
<td>MASK_CLK_OFF_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask the MP Clock Off State Check.<br/>Masks the MP clock off check during the MP idle process </td>
</tr>
<tr>
<td>10</td>
<td>MASK_CLK_STBL_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask MP clock stable State Check.<br/>Masks the MP clock stable check during MP wakeup. </td>
</tr>
<tr>
<td>9</td>
<td>MASK_JTAG_IDLE_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>MASK_IDLE_CHECK</td>
<td>RW</td>
<td>0x0</td>
<td>Mask the MP Idle State Check. </td>
</tr>
<tr>
<td>7</td>
<td>ACINACTM_HW_CTRL</td>
<td>RW</td>
<td>0x0</td>
<td>ACINACTM Hardware Control<br/>1'b0: The low-power state machine does not control the ACINACTM port.  <br/>1'b1: The low-power state machine controls the ACINACTM port of MP. When M2/M1 low-power mode is entered, ACINACTM port will be set high </td>
</tr>
<tr>
<td>6</td>
<td>RSVD</td>
<td>RO</td>
<td>0</td>
<td>Reserved</td>
</tr>
<tr>
<td>5</td>
<td>DIS_MC_SW_REQ</td>
<td>RW</td>
<td>0x0</td>
<td>Disable Memory Controller Software Request<br/>Disables the Memory Controller entry to idle mode using the Memory Controller sleep request bits. <br/>The Memory Controller will always enter into idle mode based on the hardware state machine</td>
</tr>
<tr>
<td>4</td>
<td>MP_WAKE_MC_EN</td>
<td>RW</td>
<td>0x0</td>
<td>MP Wake Memory Controller Enable<br/>The Memory Controller will wake up before the interrupt to the core is released. <br/>1'b0: Memory Controller will wake up when MP wakes up from idle mode</td>
</tr>
<tr>
<td>3</td>
<td>MP_SCU_SRAM_PWRDWN</td>
<td>RW</td>
<td>0x0</td>
<td>No Used<br/>SCU SRAM does not support retention </td>
</tr>
<tr>
<td>2</td>
<td>L2_SRAM_PWRDWN</td>
<td>RW</td>
<td>0x0</td>
<td>L2 Cache SRAM Power Down <br/>This field does not take effect if MP_PWRDWN is 0.<br/>1'b1: When MP is idle, L2 SRAM power will be off<br/>1'b0: When MP is idle, L2 SRAM is in retention mode </td>
</tr>
<tr>
<td>1</td>
<td>MP_PWRDWN</td>
<td>RW</td>
<td>0x0</td>
<td>MP Power Down<br/>This field does not take effect if MP_IDLE is 0.<br/>1'b1: When the MP is idle, MP enters deep sleep mode and the MP logic will be power-gated</td>
</tr>
<tr>
<td>0</td>
<td>MP_IDLE</td>
<td>RW</td>
<td>0x0</td>
<td>MP Idle<br/>1'b1: When MP is idle, the MP clocks will be gated externally </td>
</tr>
</tbody>
</table>

##### AUDIO POWER CONTROL REGISTER (PMUA_PWR_CTRL_AUDIO)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x378</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>4</td>
<td>HW_MODE</td>
<td>RW</td>
<td>0x0</td>
<td>Hardware Control Mode for AUD Power Up and Power Down </td>
</tr>
<tr>
<td>3</td>
<td>AUD_SLEEP2</td>
<td>RW</td>
<td>0x0</td>
<td>AUD Power Switch Sleep2</td>
</tr>
<tr>
<td>2</td>
<td>AUD_SLEEP1</td>
<td>RW</td>
<td>0x0</td>
<td>AUD Power Switch Sleep1</td>
</tr>
<tr>
<td>1</td>
<td>AUD_ISOB</td>
<td>RW</td>
<td>0x0</td>
<td>AUD Isolation Wrapper<br/>1'b0: Enable isolation (AUD power-down mode)<br/>1'b1: Disable isolation (AUD active mode) </td>
</tr>
<tr>
<td>0</td>
<td>AUD_AUTO_PWR_ON</td>
<td>RW</td>
<td>0x0</td>
<td>AUD Auto Power On <br/>1: Triggers a request to power on the ISP power island.<br/>0: Triggers a request to power down the ISP power island, but only if PWR_CTRL_AUD[4] is set.</td>
</tr>
</tbody>
</table>

##### ISP POWER CONTROL REGISTER (PMUA_PWR_CTRL_ISP)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x37C</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>4</td>
<td>HW_MODE</td>
<td>RW</td>
<td>0x0</td>
<td>Hardware Control Mode for ISP Power Up and Power Down </td>
</tr>
<tr>
<td>3</td>
<td>ISP_SLEEP2</td>
<td>RW</td>
<td>0x0</td>
<td>ISP Power Switch Sleep2 </td>
</tr>
<tr>
<td>2</td>
<td>ISP_SLEEP1</td>
<td>RW</td>
<td>0x0</td>
<td>ISP Power Switch Sleep1 </td>
</tr>
<tr>
<td>1</td>
<td>ISP_ISOB</td>
<td>RW</td>
<td>0x0</td>
<td>ISP Isolation Wrapper.<br/>1'b0: Enable isolation (ISP power-down mode).<br/>1'b1: Disable isolation (ISP active mode) </td>
</tr>
<tr>
<td>0</td>
<td>ISP_AUTO_PWR_ON</td>
<td>RW</td>
<td>0x0</td>
<td>ISP Auto Power On <br/>1: Triggers a request to power on the ISP power island.<br/>0: Triggers a request to power down the ISP power island, but only if PWR_CTRL_ISP[4] is set.</td>
</tr>
</tbody>
</table>

##### LCD POWER CONTROL REGISTER (PMUA_PWR_CTRL_LCD)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x380</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>4</td>
<td>HW_MODE</td>
<td>RW</td>
<td>0x0</td>
<td>Hardware Control Mode for LCD Power Up and Power Down </td>
</tr>
<tr>
<td>3</td>
<td>LCD_SLEEP2</td>
<td>RW</td>
<td>0x0</td>
<td>LCD Power Switch Sleep2 </td>
</tr>
<tr>
<td>2</td>
<td>LCD_SLEEP1</td>
<td>RW</td>
<td>0x0</td>
<td>LCD Power Switch Sleep1 </td>
</tr>
<tr>
<td>1</td>
<td>LCD_ISOB</td>
<td>RW</td>
<td>0x0</td>
<td>LCD Isolation Wrapper.<br/>1'b0: Enable isolation (LCD power-down mode).<br/>1'b1: Disable isolation (LCD active mode) </td>
</tr>
<tr>
<td>0</td>
<td>LCD_AUTO_PWR_ON</td>
<td>RW</td>
<td>0x0</td>
<td>LCD Auto Power On <br/>1: Triggers a request to power on the ISP power island.<br/>0: Triggers a request to power down the ISP power island, but only if PWR_CTRL_LCD[4] is set.</td>
</tr>
</tbody>
</table>

##### HDMI POWER CONTROL REGISTER (PMUA_PWR_CTRL_HDMI)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x3F4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31:5</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>4</td>
<td>HW_MODE</td>
<td>RW</td>
<td>0x0</td>
<td>Hardware Control Mode for HDMI Power Up and Power Down </td>
</tr>
<tr>
<td>3</td>
<td>HDMI_SLEEP2</td>
<td>RW</td>
<td>0x0</td>
<td>HDMI Power Switch Sleep2 </td>
</tr>
<tr>
<td>2</td>
<td>HDMI_SLEEP1</td>
<td>RW</td>
<td>0x0</td>
<td>HDMI</td>
</tr>
<tr>
<td>1</td>
<td>HDMI_ISOB</td>
<td>RW</td>
<td>0x0</td>
<td>HDMI Isolation Wrapper.<br/>1'b0: Enable isolation (HDMI power-down mode)<br/>1'b1: Disable isolation (HDMI active mode) </td>
</tr>
<tr>
<td>0</td>
<td>HDMI_AUTO_PWR_ON</td>
<td>RW</td>
<td>0x0</td>
<td>HDMI Auto Power On <br/>1: Triggers a request to power on the ISP power island.<br/>0: Triggers a request to power down the ISP power island, but only if PWR_CTRL_HDMI[4] is set.</td>
</tr>
</tbody>
</table>

##### USB WAKE CLEAR REGISTER (PMU_USBP1_WAKE_CLR)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x3C4</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>USBP1_WK_INT_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 Wake up status </td>
</tr>
<tr>
<td>30:29</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>28</td>
<td>USBP1_CHGDET_WK_STATUS</td>
<td>RO</td>
<td>0x0<br/></td>
<td>USBP1 Line charge detect wake up status </td>
</tr>
<tr>
<td>27</td>
<td>USBP1_ID_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 Line ID wake up status </td>
</tr>
<tr>
<td>26</td>
<td>USBP1_VBUS_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 Line vbus valid wake up status </td>
</tr>
<tr>
<td>25</td>
<td>USBP1_LINE1_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 Line state1 wake up status </td>
</tr>
<tr>
<td>24</td>
<td>USBP1_LINE0_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 Line state0 wake up status </td>
</tr>
<tr>
<td>23</td>
<td>USBP1_IDDIG_OVRD_VALUE</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 IDDIG OVERRIDE VALUE </td>
</tr>
<tr>
<td>22</td>
<td>USBP1_IDDIG_OVRD_EN</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 IDDIG OVERRIDE ENABLE</td>
</tr>
<tr>
<td>21</td>
<td>USBP1_VBUS_DRV</td>
<td>RO</td>
<td>0x0</td>
<td>USBP1 VBUS DRV </td>
</tr>
<tr>
<td>20</td>
<td>USBP1_CHGDET_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Line charge detect wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>19</td>
<td>USBP1_ID_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Line ID wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>18</td>
<td>USBP1_VBUS_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Line vbus valid wake up Clear<br/>1'b1: Clear. This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>17</td>
<td>USBP1_LINE1_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Line state1 wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>16</td>
<td>USBP1_LINE0_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Line state0 wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware </td>
</tr>
<tr>
<td>15</td>
<td>USBP1_WK_INT_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Wakeup Interrupt Enable<br/>1’b1: Enable </td>
</tr>
<tr>
<td>14:13</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved </td>
</tr>
<tr>
<td>12</td>
<td>USBP1_CHGDET_WK_MASK</td>
<td>RW</td>
<td>0x0<br/></td>
<td>USBP1 Line charge detect wake up Enable<br/>1’b1: Enable</td>
</tr>
<tr>
<td>11</td>
<td>USBP1_ID_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Line ID wake up Enable<br/>1’b1: Enable</td>
</tr>
<tr>
<td>10</td>
<td>USBP1_VBUS_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Line vbus valid wake up Enable<br/>1’b1: Enable </td>
</tr>
<tr>
<td>9</td>
<td>USBP1_LINE1_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Line state1 wake up Enable<br/>1’b1: Enable</td>
</tr>
<tr>
<td>8</td>
<td>USBP1_LINE0_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USBP1 Line state0 wake up Enable<br/>1’b1: Enable</td>
</tr>
<tr>
<td>7:0</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
</tbody>
</table>

##### USB3 WAKE CLEAR REGISTER (PMU_USB3_WAKE_CLR)



<table>
<tbody>
<tr>
<td rowspan=1 colspan=5><strong>Offset: 0xD4282800+0x3C8</strong></td>
</tr>
<tr>
<td><strong>Bits</strong></td>
<td><strong>Field</strong></td>
<td><strong>Type</strong></td>
<td><strong>Reset</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr>
<td>31</td>
<td>USB3_WK_INT_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 Wake up status </td>
</tr>
<tr>
<td>30</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
<tr>
<td>29</td>
<td>USB3_LFPS_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 LFPS wake up status </td>
</tr>
<tr>
<td>28</td>
<td>USB3_CHGDET_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 Line charge detect wake up status </td>
</tr>
<tr>
<td>27</td>
<td>USB3_ID_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 Line ID wake up status </td>
</tr>
<tr>
<td>26<br/></td>
<td>USB3_VBUS_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 Line vbus valid wake up status </td>
</tr>
<tr>
<td>25</td>
<td>USB3_LINE1_WK_STATUS</td>
<td>RO</td>
<td>0x0<br/></td>
<td>USB3 Line state1 wake up status </td>
</tr>
<tr>
<td>24</td>
<td>USB3_LINE0_WK_STATUS</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 Line state0 wake up status </td>
</tr>
<tr>
<td>23</td>
<td>USB3_IDDIG_OVRD_VALUE</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 IDDIG OVERRIDE VALUE </td>
</tr>
<tr>
<td>22</td>
<td>USB3_IDDIG_OVRD_EN</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 IDDIG OVERRIDE ENABLE</td>
</tr>
<tr>
<td>21</td>
<td>USB3_VBUS_DRV</td>
<td>RO</td>
<td>0x0</td>
<td>USB3 VBUS DRV </td>
</tr>
<tr>
<td>20</td>
<td>USB3_CHGDET_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Line charge detect wake up Clear <br/>1'b1: Clear<br/>This bit is self-cleared by hardware.</td>
</tr>
<tr>
<td>19</td>
<td>USB3_ID_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Line ID wake up Clear. <br/>1'b1: Clear<br/>This bit is self-cleared by hardware.</td>
</tr>
<tr>
<td>18<br/></td>
<td>USB3_VBUS_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Line vbus valid wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware.</td>
</tr>
<tr>
<td>17</td>
<td>USB3_LINE1_WK_CLR</td>
<td>RW<br/></td>
<td>0x0</td>
<td>USB3 Line state1 wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware.</td>
</tr>
<tr>
<td>16</td>
<td>USB3_LINE0_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Line state0 wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware.</td>
</tr>
<tr>
<td>15</td>
<td>USB3_WK_INT_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Wakeup Interrupt Enable<br/>1'b1: Enable </td>
</tr>
<tr>
<td>14</td>
<td>USB3_LFPS_WK_CLR</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 LFPS wake up Clear<br/>1'b1: Clear<br/>This bit is self-cleared by hardware.</td>
</tr>
<tr>
<td>13</td>
<td>USB3_LFPS_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 LFPS wake up Enable<br/>1'b1: Enable</td>
</tr>
<tr>
<td>12</td>
<td>USB3_CHGDET_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Line charge detect wake up Enable <br/>1'b1: Enable</td>
</tr>
<tr>
<td>11</td>
<td>USB3_ID_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Line ID wake up Enable<br/>1'b1: Enable</td>
</tr>
<tr>
<td>10</td>
<td>USB3_VBUS_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Line vbus valid wake up Enable<br/>1'b1: Enable</td>
</tr>
<tr>
<td>9</td>
<td>USB3_LINE1_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Line state1 wake up Enable  <br/>1'b1: Enable</td>
</tr>
<tr>
<td>8</td>
<td>USB3_LINE0_WK_MASK</td>
<td>RW</td>
<td>0x0</td>
<td>USB3 Line state0 wake up Enable<br/>1'b1: Enable </td>
</tr>
<tr>
<td>7:0</td>
<td>RSVD</td>
<td>RO</td>
<td>0x0</td>
<td>Reserved</td>
</tr>
</tbody>
</table>
